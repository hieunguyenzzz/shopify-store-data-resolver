export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  ARN: { input: any; output: any; }
  BigInt: { input: any; output: any; }
  Color: { input: any; output: any; }
  Date: { input: any; output: any; }
  DateTime: { input: string; output: string; }
  Decimal: { input: number; output: number; }
  FormattedString: { input: any; output: any; }
  HTML: { input: any; output: any; }
  JSON: { input: any; output: any; }
  Money: { input: any; output: any; }
  StorefrontID: { input: any; output: any; }
  URL: { input: string; output: string; }
  UnsignedInt64: { input: any; output: any; }
  UtcOffset: { input: any; output: any; }
};

export type AbandonedCheckout = Navigable & Node & {
  abandonedCheckoutUrl: Scalars['URL']['output'];
  billingAddress?: Maybe<MailingAddress>;
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  customAttributes: Array<Attribute>;
  customer?: Maybe<Customer>;
  defaultCursor: Scalars['String']['output'];
  discountCodes: Array<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lineItems: AbandonedCheckoutLineItemConnection;
  /** @deprecated Use [AbandonedCheckoutLineItem.quantity](https://shopify.dev/api/admin-graphql/unstable/objects/AbandonedCheckoutLineItem#field-quantity) instead. */
  lineItemsQuantity: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  note: Scalars['String']['output'];
  shippingAddress?: Maybe<MailingAddress>;
  subtotalPriceSet: MoneyBag;
  taxLines: Array<TaxLine>;
  taxesIncluded: Scalars['Boolean']['output'];
  totalDiscountSet: MoneyBag;
  totalDutiesSet?: Maybe<MoneyBag>;
  totalLineItemsPriceSet: MoneyBag;
  totalPriceSet: MoneyBag;
  totalTaxSet?: Maybe<MoneyBag>;
  updatedAt: Scalars['DateTime']['output'];
};


export type AbandonedCheckoutLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AbandonedCheckoutConnection = {
  edges: Array<AbandonedCheckoutEdge>;
  nodes: Array<AbandonedCheckout>;
  pageInfo: PageInfo;
};

export type AbandonedCheckoutEdge = {
  cursor: Scalars['String']['output'];
  node: AbandonedCheckout;
};

export type AbandonedCheckoutLineItem = Node & {
  components?: Maybe<Array<AbandonedCheckoutLineItemComponent>>;
  customAttributes: Array<Attribute>;
  discountAllocations: DiscountAllocationConnection;
  discountedTotalPriceSet: MoneyBag;
  discountedTotalPriceWithCodeDiscount: MoneyBag;
  discountedUnitPriceSet: MoneyBag;
  discountedUnitPriceWithCodeDiscount: MoneyBag;
  id: Scalars['ID']['output'];
  image?: Maybe<Image>;
  originalTotalPriceSet: MoneyBag;
  originalUnitPriceSet: MoneyBag;
  product?: Maybe<Product>;
  quantity: Scalars['Int']['output'];
  sku?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  variant?: Maybe<ProductVariant>;
  variantTitle?: Maybe<Scalars['String']['output']>;
};


export type AbandonedCheckoutLineItemDiscountAllocationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AbandonedCheckoutLineItemComponent = {
  id: Scalars['ID']['output'];
  image?: Maybe<Image>;
  quantity: Scalars['Int']['output'];
  title: Scalars['String']['output'];
  variantTitle?: Maybe<Scalars['String']['output']>;
};

export type AbandonedCheckoutLineItemConnection = {
  edges: Array<AbandonedCheckoutLineItemEdge>;
  nodes: Array<AbandonedCheckoutLineItem>;
  pageInfo: PageInfo;
};

export type AbandonedCheckoutLineItemEdge = {
  cursor: Scalars['String']['output'];
  node: AbandonedCheckoutLineItem;
};

export const AbandonedCheckoutSortKeys = {
  CheckoutId: 'CHECKOUT_ID',
  CreatedAt: 'CREATED_AT',
  CustomerName: 'CUSTOMER_NAME',
  Id: 'ID',
  Relevance: 'RELEVANCE',
  TotalPrice: 'TOTAL_PRICE'
} as const;

export type AbandonedCheckoutSortKeys = typeof AbandonedCheckoutSortKeys[keyof typeof AbandonedCheckoutSortKeys];
export type Abandonment = Node & {
  abandonedCheckoutPayload?: Maybe<AbandonedCheckout>;
  abandonmentType: AbandonmentAbandonmentType;
  app: App;
  cartUrl?: Maybe<Scalars['URL']['output']>;
  createdAt: Scalars['DateTime']['output'];
  customer: Customer;
  customerHasNoDraftOrderSinceAbandonment: Scalars['Boolean']['output'];
  customerHasNoOrderSinceAbandonment: Scalars['Boolean']['output'];
  daysSinceLastAbandonmentEmail: Scalars['Int']['output'];
  emailSentAt?: Maybe<Scalars['DateTime']['output']>;
  emailState?: Maybe<AbandonmentEmailState>;
  hoursSinceLastAbandonedCheckout?: Maybe<Scalars['Float']['output']>;
  id: Scalars['ID']['output'];
  inventoryAvailable: Scalars['Boolean']['output'];
  isFromCustomStorefront: Scalars['Boolean']['output'];
  isFromOnlineStore: Scalars['Boolean']['output'];
  isFromShopApp: Scalars['Boolean']['output'];
  isFromShopPay: Scalars['Boolean']['output'];
  isMostSignificantAbandonment: Scalars['Boolean']['output'];
  lastBrowseAbandonmentDate: Scalars['DateTime']['output'];
  lastCartAbandonmentDate: Scalars['DateTime']['output'];
  lastCheckoutAbandonmentDate: Scalars['DateTime']['output'];
  mostRecentStep: AbandonmentAbandonmentType;
  productsAddedToCart: CustomerVisitProductInfoConnection;
  productsViewed: CustomerVisitProductInfoConnection;
  visitStartedAt?: Maybe<Scalars['DateTime']['output']>;
};


export type AbandonmentProductsAddedToCartArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type AbandonmentProductsViewedArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export const AbandonmentAbandonmentType = {
  Browse: 'BROWSE',
  Cart: 'CART',
  Checkout: 'CHECKOUT'
} as const;

export type AbandonmentAbandonmentType = typeof AbandonmentAbandonmentType[keyof typeof AbandonmentAbandonmentType];
export const AbandonmentDeliveryState = {
  NotSent: 'NOT_SENT',
  Scheduled: 'SCHEDULED',
  Sent: 'SENT'
} as const;

export type AbandonmentDeliveryState = typeof AbandonmentDeliveryState[keyof typeof AbandonmentDeliveryState];
export const AbandonmentEmailState = {
  NotSent: 'NOT_SENT',
  Scheduled: 'SCHEDULED',
  Sent: 'SENT'
} as const;

export type AbandonmentEmailState = typeof AbandonmentEmailState[keyof typeof AbandonmentEmailState];
export type AbandonmentEmailStateUpdatePayload = {
  abandonment?: Maybe<Abandonment>;
  userErrors: Array<AbandonmentEmailStateUpdateUserError>;
};

export type AbandonmentEmailStateUpdateUserError = DisplayableError & {
  code?: Maybe<AbandonmentEmailStateUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const AbandonmentEmailStateUpdateUserErrorCode = {
  AbandonmentNotFound: 'ABANDONMENT_NOT_FOUND'
} as const;

export type AbandonmentEmailStateUpdateUserErrorCode = typeof AbandonmentEmailStateUpdateUserErrorCode[keyof typeof AbandonmentEmailStateUpdateUserErrorCode];
export type AbandonmentUpdateActivitiesDeliveryStatusesPayload = {
  abandonment?: Maybe<Abandonment>;
  userErrors: Array<AbandonmentUpdateActivitiesDeliveryStatusesUserError>;
};

export type AbandonmentUpdateActivitiesDeliveryStatusesUserError = DisplayableError & {
  code?: Maybe<AbandonmentUpdateActivitiesDeliveryStatusesUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const AbandonmentUpdateActivitiesDeliveryStatusesUserErrorCode = {
  AbandonmentNotFound: 'ABANDONMENT_NOT_FOUND',
  DeliveryStatusInfoNotFound: 'DELIVERY_STATUS_INFO_NOT_FOUND',
  MarketingActivityNotFound: 'MARKETING_ACTIVITY_NOT_FOUND'
} as const;

export type AbandonmentUpdateActivitiesDeliveryStatusesUserErrorCode = typeof AbandonmentUpdateActivitiesDeliveryStatusesUserErrorCode[keyof typeof AbandonmentUpdateActivitiesDeliveryStatusesUserErrorCode];
export type AccessScope = {
  description: Scalars['String']['output'];
  handle: Scalars['String']['output'];
};

export const AccountType = {
  Collaborator: 'COLLABORATOR',
  CollaboratorTeamMember: 'COLLABORATOR_TEAM_MEMBER',
  Invited: 'INVITED',
  InvitedStoreOwner: 'INVITED_STORE_OWNER',
  Regular: 'REGULAR',
  Requested: 'REQUESTED',
  Restricted: 'RESTRICTED',
  Saml: 'SAML'
} as const;

export type AccountType = typeof AccountType[keyof typeof AccountType];
export type AddAllProductsOperation = Node & ResourceOperation & {
  id: Scalars['ID']['output'];
  processedRowCount?: Maybe<Scalars['Int']['output']>;
  rowCount?: Maybe<RowCount>;
  status: ResourceOperationStatus;
};

export type AdditionalFee = Node & {
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  price: MoneyBag;
  taxLines: Array<TaxLine>;
};

export type AdditionalFeeSale = Sale & {
  actionType: SaleActionType;
  additionalFee: SaleAdditionalFee;
  id: Scalars['ID']['output'];
  lineType: SaleLineType;
  quantity?: Maybe<Scalars['Int']['output']>;
  taxes: Array<SaleTax>;
  totalAmount: MoneyBag;
  totalDiscountAmountAfterTaxes: MoneyBag;
  totalDiscountAmountBeforeTaxes: MoneyBag;
  totalTaxAmount: MoneyBag;
};

export type AdjustmentSale = Sale & {
  actionType: SaleActionType;
  id: Scalars['ID']['output'];
  lineType: SaleLineType;
  quantity?: Maybe<Scalars['Int']['output']>;
  taxes: Array<SaleTax>;
  totalAmount: MoneyBag;
  totalDiscountAmountAfterTaxes: MoneyBag;
  totalDiscountAmountBeforeTaxes: MoneyBag;
  totalTaxAmount: MoneyBag;
};

export const AdjustmentsSortKeys = {
  Id: 'ID',
  Relevance: 'RELEVANCE',
  Time: 'TIME'
} as const;

export type AdjustmentsSortKeys = typeof AdjustmentsSortKeys[keyof typeof AdjustmentsSortKeys];
export type AllDiscountItems = {
  allItems: Scalars['Boolean']['output'];
};

export type AndroidApplication = {
  appLinksEnabled: Scalars['Boolean']['output'];
  applicationId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  sha256CertFingerprints: Array<Scalars['String']['output']>;
};

export type ApiVersion = {
  displayName: Scalars['String']['output'];
  handle: Scalars['String']['output'];
  supported: Scalars['Boolean']['output'];
};

export type App = Node & {
  apiKey: Scalars['String']['output'];
  appStoreAppUrl?: Maybe<Scalars['URL']['output']>;
  appStoreDeveloperUrl?: Maybe<Scalars['URL']['output']>;
  availableAccessScopes: Array<AccessScope>;
  banner: Image;
  description?: Maybe<Scalars['String']['output']>;
  developerName?: Maybe<Scalars['String']['output']>;
  developerType: AppDeveloperType;
  /** @deprecated Use `appStoreDeveloperUrl` instead. */
  developerUrl: Scalars['URL']['output'];
  embedded: Scalars['Boolean']['output'];
  failedRequirements: Array<FailedRequirement>;
  features: Array<Scalars['String']['output']>;
  feedback?: Maybe<AppFeedback>;
  handle?: Maybe<Scalars['String']['output']>;
  icon: Image;
  id: Scalars['ID']['output'];
  installUrl?: Maybe<Scalars['URL']['output']>;
  installation?: Maybe<AppInstallation>;
  isPostPurchaseAppInUse: Scalars['Boolean']['output'];
  /** @deprecated Use AppInstallation.launchUrl instead */
  launchUrl: Scalars['URL']['output'];
  /** @deprecated Use AppInstallation.navigationItems instead */
  navigationItems: Array<NavigationItem>;
  optionalAccessScopes: Array<AccessScope>;
  previouslyInstalled: Scalars['Boolean']['output'];
  pricingDetails?: Maybe<Scalars['String']['output']>;
  pricingDetailsSummary: Scalars['String']['output'];
  privacyPolicyUrl?: Maybe<Scalars['URL']['output']>;
  publicCategory: AppPublicCategory;
  published: Scalars['Boolean']['output'];
  requestedAccessScopes: Array<AccessScope>;
  screenshots: Array<Image>;
  shopifyDeveloped: Scalars['Boolean']['output'];
  title: Scalars['String']['output'];
  uninstallMessage: Scalars['String']['output'];
  /** @deprecated Use AppInstallation.uninstallUrl instead */
  uninstallUrl?: Maybe<Scalars['URL']['output']>;
  webhookApiVersion: Scalars['String']['output'];
};

export type AppCatalog = Catalog & Node & {
  apps: AppConnection;
  id: Scalars['ID']['output'];
  operations: Array<ResourceOperation>;
  priceList?: Maybe<PriceList>;
  publication?: Maybe<Publication>;
  status: CatalogStatus;
  title: Scalars['String']['output'];
};


export type AppCatalogAppsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AppConnection = {
  edges: Array<AppEdge>;
  nodes: Array<App>;
  pageInfo: PageInfo;
};

export type AppCredit = Node & {
  amount: MoneyV2;
  createdAt: Scalars['DateTime']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  test: Scalars['Boolean']['output'];
};

export type AppCreditConnection = {
  edges: Array<AppCreditEdge>;
  nodes: Array<AppCredit>;
  pageInfo: PageInfo;
};

export type AppCreditEdge = {
  cursor: Scalars['String']['output'];
  node: AppCredit;
};

export const AppDeveloperType = {
  Merchant: 'MERCHANT',
  Partner: 'PARTNER',
  Shopify: 'SHOPIFY',
  Unknown: 'UNKNOWN'
} as const;

export type AppDeveloperType = typeof AppDeveloperType[keyof typeof AppDeveloperType];
export type AppDiscountType = {
  app: App;
  appBridge: FunctionsAppBridge;
  appKey: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  discountClass: DiscountClass;
  functionId: Scalars['String']['output'];
  targetType: DiscountApplicationTargetType;
  title: Scalars['String']['output'];
};

export type AppEdge = {
  cursor: Scalars['String']['output'];
  node: App;
};

export type AppFeedback = {
  app: App;
  feedbackGeneratedAt: Scalars['DateTime']['output'];
  link?: Maybe<Link>;
  messages: Array<UserError>;
  state: ResourceFeedbackState;
};

export type AppInstallation = HasMetafields & Node & {
  accessScopes: Array<AccessScope>;
  activeSubscriptions: Array<AppSubscription>;
  allSubscriptions: AppSubscriptionConnection;
  app: App;
  /** @deprecated Use `publication` instead. */
  channel?: Maybe<Channel>;
  credits: AppCreditConnection;
  id: Scalars['ID']['output'];
  launchUrl: Scalars['URL']['output'];
  metafield?: Maybe<Metafield>;
  metafields: MetafieldConnection;
  oneTimePurchases: AppPurchaseOneTimeConnection;
  publication?: Maybe<Publication>;
  revenueAttributionRecords: AppRevenueAttributionRecordConnection;
  /** @deprecated Use `activeSubscriptions` instead. */
  subscriptions: Array<AppSubscription>;
  uninstallUrl?: Maybe<Scalars['URL']['output']>;
};


export type AppInstallationAllSubscriptionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<AppSubscriptionSortKeys>;
};


export type AppInstallationCreditsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<AppTransactionSortKeys>;
};


export type AppInstallationMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type AppInstallationMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type AppInstallationOneTimePurchasesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<AppTransactionSortKeys>;
};


export type AppInstallationRevenueAttributionRecordsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<AppRevenueAttributionRecordSortKeys>;
};

export const AppInstallationCategory = {
  Channel: 'CHANNEL',
  PosEmbedded: 'POS_EMBEDDED'
} as const;

export type AppInstallationCategory = typeof AppInstallationCategory[keyof typeof AppInstallationCategory];
export type AppInstallationConnection = {
  edges: Array<AppInstallationEdge>;
  nodes: Array<AppInstallation>;
  pageInfo: PageInfo;
};

export type AppInstallationEdge = {
  cursor: Scalars['String']['output'];
  node: AppInstallation;
};

export const AppInstallationPrivacy = {
  Private: 'PRIVATE',
  Public: 'PUBLIC'
} as const;

export type AppInstallationPrivacy = typeof AppInstallationPrivacy[keyof typeof AppInstallationPrivacy];
export const AppInstallationSortKeys = {
  AppTitle: 'APP_TITLE',
  Id: 'ID',
  InstalledAt: 'INSTALLED_AT',
  Relevance: 'RELEVANCE'
} as const;

export type AppInstallationSortKeys = typeof AppInstallationSortKeys[keyof typeof AppInstallationSortKeys];
export type AppPlanInput = {
  appRecurringPricingDetails?: InputMaybe<AppRecurringPricingInput>;
  appUsagePricingDetails?: InputMaybe<AppUsagePricingInput>;
};

export type AppPlanV2 = {
  pricingDetails: AppPricingDetails;
};

export type AppPricingDetails = AppRecurringPricing | AppUsagePricing;

export const AppPricingInterval = {
  Annual: 'ANNUAL',
  Every_30Days: 'EVERY_30_DAYS'
} as const;

export type AppPricingInterval = typeof AppPricingInterval[keyof typeof AppPricingInterval];
export const AppPublicCategory = {
  Custom: 'CUSTOM',
  Other: 'OTHER',
  Private: 'PRIVATE',
  Public: 'PUBLIC'
} as const;

export type AppPublicCategory = typeof AppPublicCategory[keyof typeof AppPublicCategory];
export type AppPurchase = {
  createdAt: Scalars['DateTime']['output'];
  name: Scalars['String']['output'];
  price: MoneyV2;
  status: AppPurchaseStatus;
  test: Scalars['Boolean']['output'];
};

export type AppPurchaseOneTime = AppPurchase & Node & {
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  price: MoneyV2;
  status: AppPurchaseStatus;
  test: Scalars['Boolean']['output'];
};

export type AppPurchaseOneTimeConnection = {
  edges: Array<AppPurchaseOneTimeEdge>;
  nodes: Array<AppPurchaseOneTime>;
  pageInfo: PageInfo;
};

export type AppPurchaseOneTimeCreatePayload = {
  appPurchaseOneTime?: Maybe<AppPurchaseOneTime>;
  confirmationUrl?: Maybe<Scalars['URL']['output']>;
  userErrors: Array<UserError>;
};

export type AppPurchaseOneTimeEdge = {
  cursor: Scalars['String']['output'];
  node: AppPurchaseOneTime;
};

export const AppPurchaseStatus = {
  Accepted: 'ACCEPTED',
  Active: 'ACTIVE',
  Declined: 'DECLINED',
  Expired: 'EXPIRED',
  Pending: 'PENDING'
} as const;

export type AppPurchaseStatus = typeof AppPurchaseStatus[keyof typeof AppPurchaseStatus];
export type AppRecurringPricing = {
  discount?: Maybe<AppSubscriptionDiscount>;
  interval: AppPricingInterval;
  price: MoneyV2;
};

export type AppRecurringPricingInput = {
  discount?: InputMaybe<AppSubscriptionDiscountInput>;
  interval?: InputMaybe<AppPricingInterval>;
  price: MoneyInput;
};

export type AppRevenueAttributionRecord = Node & {
  amount: MoneyV2;
  capturedAt: Scalars['DateTime']['output'];
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  idempotencyKey: Scalars['String']['output'];
  test: Scalars['Boolean']['output'];
  type: AppRevenueAttributionType;
};

export type AppRevenueAttributionRecordConnection = {
  edges: Array<AppRevenueAttributionRecordEdge>;
  nodes: Array<AppRevenueAttributionRecord>;
  pageInfo: PageInfo;
};

export type AppRevenueAttributionRecordEdge = {
  cursor: Scalars['String']['output'];
  node: AppRevenueAttributionRecord;
};

export const AppRevenueAttributionRecordSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type AppRevenueAttributionRecordSortKeys = typeof AppRevenueAttributionRecordSortKeys[keyof typeof AppRevenueAttributionRecordSortKeys];
export const AppRevenueAttributionType = {
  ApplicationPurchase: 'APPLICATION_PURCHASE',
  ApplicationSubscription: 'APPLICATION_SUBSCRIPTION',
  ApplicationUsage: 'APPLICATION_USAGE',
  Other: 'OTHER'
} as const;

export type AppRevenueAttributionType = typeof AppRevenueAttributionType[keyof typeof AppRevenueAttributionType];
export type AppRevokeAccessScopesAppRevokeScopeError = DisplayableError & {
  code?: Maybe<AppRevokeAccessScopesAppRevokeScopeErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const AppRevokeAccessScopesAppRevokeScopeErrorCode = {
  ApplicationCannotBeFound: 'APPLICATION_CANNOT_BE_FOUND',
  AppNotInstalled: 'APP_NOT_INSTALLED',
  CannotRevokeImpliedScopes: 'CANNOT_REVOKE_IMPLIED_SCOPES',
  CannotRevokeRequiredScopes: 'CANNOT_REVOKE_REQUIRED_SCOPES',
  CannotRevokeUndeclaredScopes: 'CANNOT_REVOKE_UNDECLARED_SCOPES',
  MissingSourceApp: 'MISSING_SOURCE_APP',
  UnknownScopes: 'UNKNOWN_SCOPES'
} as const;

export type AppRevokeAccessScopesAppRevokeScopeErrorCode = typeof AppRevokeAccessScopesAppRevokeScopeErrorCode[keyof typeof AppRevokeAccessScopesAppRevokeScopeErrorCode];
export type AppRevokeAccessScopesPayload = {
  revoked?: Maybe<Array<AccessScope>>;
  userErrors: Array<AppRevokeAccessScopesAppRevokeScopeError>;
};

export type AppSubscription = Node & {
  createdAt: Scalars['DateTime']['output'];
  currentPeriodEnd?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  lineItems: Array<AppSubscriptionLineItem>;
  name: Scalars['String']['output'];
  returnUrl: Scalars['URL']['output'];
  status: AppSubscriptionStatus;
  test: Scalars['Boolean']['output'];
  trialDays: Scalars['Int']['output'];
};

export type AppSubscriptionCancelPayload = {
  appSubscription?: Maybe<AppSubscription>;
  userErrors: Array<UserError>;
};

export type AppSubscriptionConnection = {
  edges: Array<AppSubscriptionEdge>;
  nodes: Array<AppSubscription>;
  pageInfo: PageInfo;
};

export type AppSubscriptionCreatePayload = {
  appSubscription?: Maybe<AppSubscription>;
  confirmationUrl?: Maybe<Scalars['URL']['output']>;
  userErrors: Array<UserError>;
};

export type AppSubscriptionDiscount = {
  durationLimitInIntervals?: Maybe<Scalars['Int']['output']>;
  priceAfterDiscount: MoneyV2;
  remainingDurationInIntervals?: Maybe<Scalars['Int']['output']>;
  value: AppSubscriptionDiscountValue;
};

export type AppSubscriptionDiscountAmount = {
  amount: MoneyV2;
};

export type AppSubscriptionDiscountInput = {
  durationLimitInIntervals?: InputMaybe<Scalars['Int']['input']>;
  value?: InputMaybe<AppSubscriptionDiscountValueInput>;
};

export type AppSubscriptionDiscountPercentage = {
  percentage: Scalars['Float']['output'];
};

export type AppSubscriptionDiscountValue = AppSubscriptionDiscountAmount | AppSubscriptionDiscountPercentage;

export type AppSubscriptionDiscountValueInput = {
  amount?: InputMaybe<Scalars['Decimal']['input']>;
  percentage?: InputMaybe<Scalars['Float']['input']>;
};

export type AppSubscriptionEdge = {
  cursor: Scalars['String']['output'];
  node: AppSubscription;
};

export type AppSubscriptionLineItem = {
  id: Scalars['ID']['output'];
  plan: AppPlanV2;
  usageRecords: AppUsageRecordConnection;
};


export type AppSubscriptionLineItemUsageRecordsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<AppUsageRecordSortKeys>;
};

export type AppSubscriptionLineItemInput = {
  plan: AppPlanInput;
};

export type AppSubscriptionLineItemUpdatePayload = {
  appSubscription?: Maybe<AppSubscription>;
  confirmationUrl?: Maybe<Scalars['URL']['output']>;
  userErrors: Array<UserError>;
};

export const AppSubscriptionReplacementBehavior = {
  ApplyImmediately: 'APPLY_IMMEDIATELY',
  ApplyOnNextBillingCycle: 'APPLY_ON_NEXT_BILLING_CYCLE',
  Standard: 'STANDARD'
} as const;

export type AppSubscriptionReplacementBehavior = typeof AppSubscriptionReplacementBehavior[keyof typeof AppSubscriptionReplacementBehavior];
export const AppSubscriptionSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type AppSubscriptionSortKeys = typeof AppSubscriptionSortKeys[keyof typeof AppSubscriptionSortKeys];
export const AppSubscriptionStatus = {
  Accepted: 'ACCEPTED',
  Active: 'ACTIVE',
  Cancelled: 'CANCELLED',
  Declined: 'DECLINED',
  Expired: 'EXPIRED',
  Frozen: 'FROZEN',
  Pending: 'PENDING'
} as const;

export type AppSubscriptionStatus = typeof AppSubscriptionStatus[keyof typeof AppSubscriptionStatus];
export type AppSubscriptionTrialExtendPayload = {
  appSubscription?: Maybe<AppSubscription>;
  userErrors: Array<AppSubscriptionTrialExtendUserError>;
};

export type AppSubscriptionTrialExtendUserError = DisplayableError & {
  code?: Maybe<AppSubscriptionTrialExtendUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const AppSubscriptionTrialExtendUserErrorCode = {
  SubscriptionNotActive: 'SUBSCRIPTION_NOT_ACTIVE',
  SubscriptionNotFound: 'SUBSCRIPTION_NOT_FOUND',
  TrialNotActive: 'TRIAL_NOT_ACTIVE'
} as const;

export type AppSubscriptionTrialExtendUserErrorCode = typeof AppSubscriptionTrialExtendUserErrorCode[keyof typeof AppSubscriptionTrialExtendUserErrorCode];
export const AppTransactionSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type AppTransactionSortKeys = typeof AppTransactionSortKeys[keyof typeof AppTransactionSortKeys];
export type AppUsagePricing = {
  balanceUsed: MoneyV2;
  cappedAmount: MoneyV2;
  interval: AppPricingInterval;
  terms: Scalars['String']['output'];
};

export type AppUsagePricingInput = {
  cappedAmount: MoneyInput;
  terms: Scalars['String']['input'];
};

export type AppUsageRecord = Node & {
  createdAt: Scalars['DateTime']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  idempotencyKey?: Maybe<Scalars['String']['output']>;
  price: MoneyV2;
  subscriptionLineItem: AppSubscriptionLineItem;
};

export type AppUsageRecordConnection = {
  edges: Array<AppUsageRecordEdge>;
  nodes: Array<AppUsageRecord>;
  pageInfo: PageInfo;
};

export type AppUsageRecordCreatePayload = {
  appUsageRecord?: Maybe<AppUsageRecord>;
  userErrors: Array<UserError>;
};

export type AppUsageRecordEdge = {
  cursor: Scalars['String']['output'];
  node: AppUsageRecord;
};

export const AppUsageRecordSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type AppUsageRecordSortKeys = typeof AppUsageRecordSortKeys[keyof typeof AppUsageRecordSortKeys];
export type AppleApplication = {
  appClipApplicationId?: Maybe<Scalars['String']['output']>;
  appClipsEnabled: Scalars['Boolean']['output'];
  appId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  sharedWebCredentialsEnabled: Scalars['Boolean']['output'];
  universalLinksEnabled: Scalars['Boolean']['output'];
};

export type Article = HasEvents & HasMetafieldDefinitions & HasMetafields & HasPublishedTranslations & Navigable & Node & {
  author?: Maybe<ArticleAuthor>;
  blog: Blog;
  body: Scalars['HTML']['output'];
  comments: CommentConnection;
  commentsCount?: Maybe<Count>;
  createdAt: Scalars['DateTime']['output'];
  defaultCursor: Scalars['String']['output'];
  events: EventConnection;
  handle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  image?: Maybe<Image>;
  isPublished: Scalars['Boolean']['output'];
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  summary?: Maybe<Scalars['HTML']['output']>;
  tags: Array<Scalars['String']['output']>;
  templateSuffix?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  translations: Array<Translation>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


export type ArticleCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ArticleCommentsCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
};


export type ArticleEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type ArticleMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type ArticleMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type ArticleMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ArticleTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export type ArticleAuthor = {
  name: Scalars['String']['output'];
};

export type ArticleBlogInput = {
  title: Scalars['String']['input'];
};

export type ArticleConnection = {
  edges: Array<ArticleEdge>;
  nodes: Array<Article>;
  pageInfo: PageInfo;
};

export type ArticleCreateInput = {
  author: AuthorInput;
  blogId?: InputMaybe<Scalars['ID']['input']>;
  body?: InputMaybe<Scalars['HTML']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<ArticleImageInput>;
  isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  publishDate?: InputMaybe<Scalars['DateTime']['input']>;
  summary?: InputMaybe<Scalars['HTML']['input']>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
  title: Scalars['String']['input'];
};

export type ArticleCreatePayload = {
  article?: Maybe<Article>;
  userErrors: Array<ArticleCreateUserError>;
};

export type ArticleCreateUserError = DisplayableError & {
  code?: Maybe<ArticleCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ArticleCreateUserErrorCode = {
  AmbiguousAuthor: 'AMBIGUOUS_AUTHOR',
  AmbiguousBlog: 'AMBIGUOUS_BLOG',
  AuthorFieldRequired: 'AUTHOR_FIELD_REQUIRED',
  AuthorMustExist: 'AUTHOR_MUST_EXIST',
  Blank: 'BLANK',
  BlogReferenceRequired: 'BLOG_REFERENCE_REQUIRED',
  Invalid: 'INVALID',
  InvalidPublishDate: 'INVALID_PUBLISH_DATE',
  InvalidType: 'INVALID_TYPE',
  InvalidValue: 'INVALID_VALUE',
  NotFound: 'NOT_FOUND',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  UploadFailed: 'UPLOAD_FAILED'
} as const;

export type ArticleCreateUserErrorCode = typeof ArticleCreateUserErrorCode[keyof typeof ArticleCreateUserErrorCode];
export type ArticleDeletePayload = {
  deletedArticleId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<ArticleDeleteUserError>;
};

export type ArticleDeleteUserError = DisplayableError & {
  code?: Maybe<ArticleDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ArticleDeleteUserErrorCode = {
  NotFound: 'NOT_FOUND'
} as const;

export type ArticleDeleteUserErrorCode = typeof ArticleDeleteUserErrorCode[keyof typeof ArticleDeleteUserErrorCode];
export type ArticleEdge = {
  cursor: Scalars['String']['output'];
  node: Article;
};

export type ArticleImageInput = {
  altText?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export const ArticleSortKeys = {
  Author: 'AUTHOR',
  BlogTitle: 'BLOG_TITLE',
  Id: 'ID',
  PublishedAt: 'PUBLISHED_AT',
  Relevance: 'RELEVANCE',
  Title: 'TITLE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type ArticleSortKeys = typeof ArticleSortKeys[keyof typeof ArticleSortKeys];
export const ArticleTagSort = {
  Alphabetical: 'ALPHABETICAL',
  Popular: 'POPULAR'
} as const;

export type ArticleTagSort = typeof ArticleTagSort[keyof typeof ArticleTagSort];
export type ArticleUpdateInput = {
  author?: InputMaybe<AuthorInput>;
  blogId?: InputMaybe<Scalars['ID']['input']>;
  body?: InputMaybe<Scalars['HTML']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  image?: InputMaybe<ArticleImageInput>;
  isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  publishDate?: InputMaybe<Scalars['DateTime']['input']>;
  redirectNewHandle?: InputMaybe<Scalars['Boolean']['input']>;
  summary?: InputMaybe<Scalars['HTML']['input']>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ArticleUpdatePayload = {
  article?: Maybe<Article>;
  userErrors: Array<ArticleUpdateUserError>;
};

export type ArticleUpdateUserError = DisplayableError & {
  code?: Maybe<ArticleUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ArticleUpdateUserErrorCode = {
  AmbiguousAuthor: 'AMBIGUOUS_AUTHOR',
  AmbiguousBlog: 'AMBIGUOUS_BLOG',
  AuthorMustExist: 'AUTHOR_MUST_EXIST',
  Blank: 'BLANK',
  Invalid: 'INVALID',
  InvalidPublishDate: 'INVALID_PUBLISH_DATE',
  NotFound: 'NOT_FOUND',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  UploadFailed: 'UPLOAD_FAILED'
} as const;

export type ArticleUpdateUserErrorCode = typeof ArticleUpdateUserErrorCode[keyof typeof ArticleUpdateUserErrorCode];
export type Attribute = {
  key: Scalars['String']['output'];
  value?: Maybe<Scalars['String']['output']>;
};

export type AttributeInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type AuthorInput = {
  name?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type AutomaticDiscountApplication = DiscountApplication & {
  allocationMethod: DiscountApplicationAllocationMethod;
  index: Scalars['Int']['output'];
  targetSelection: DiscountApplicationTargetSelection;
  targetType: DiscountApplicationTargetType;
  title: Scalars['String']['output'];
  value: PricingValue;
};

export const AutomaticDiscountSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type AutomaticDiscountSortKeys = typeof AutomaticDiscountSortKeys[keyof typeof AutomaticDiscountSortKeys];
export type AvailableChannelDefinitionsByChannel = {
  channelDefinitions: Array<ChannelDefinition>;
  channelName: Scalars['String']['output'];
};

export const BadgeType = {
  Attention: 'ATTENTION',
  Critical: 'CRITICAL',
  Default: 'DEFAULT',
  Info: 'INFO',
  Success: 'SUCCESS',
  Warning: 'WARNING'
} as const;

export type BadgeType = typeof BadgeType[keyof typeof BadgeType];
export const BalanceTransactionSortKeys = {
  Amount: 'AMOUNT',
  Fee: 'FEE',
  Id: 'ID',
  Net: 'NET',
  OrderName: 'ORDER_NAME',
  PaymentMethodName: 'PAYMENT_METHOD_NAME',
  PayoutDate: 'PAYOUT_DATE',
  PayoutStatus: 'PAYOUT_STATUS',
  ProcessedAt: 'PROCESSED_AT',
  Relevance: 'RELEVANCE',
  TransactionType: 'TRANSACTION_TYPE'
} as const;

export type BalanceTransactionSortKeys = typeof BalanceTransactionSortKeys[keyof typeof BalanceTransactionSortKeys];
export type BasePaymentDetails = {
  paymentMethodName?: Maybe<Scalars['String']['output']>;
};

export type BasicEvent = Event & Node & {
  action: Scalars['String']['output'];
  additionalContent?: Maybe<Scalars['JSON']['output']>;
  additionalData?: Maybe<Scalars['JSON']['output']>;
  appTitle?: Maybe<Scalars['String']['output']>;
  arguments?: Maybe<Scalars['JSON']['output']>;
  attributeToApp: Scalars['Boolean']['output'];
  attributeToUser: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  criticalAlert: Scalars['Boolean']['output'];
  hasAdditionalContent: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  message: Scalars['FormattedString']['output'];
  secondaryMessage?: Maybe<Scalars['FormattedString']['output']>;
  subject?: Maybe<HasEvents>;
  subjectId: Scalars['ID']['output'];
  subjectType: EventSubjectType;
};

export type BillingAttemptUserError = DisplayableError & {
  code?: Maybe<BillingAttemptUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const BillingAttemptUserErrorCode = {
  BillingCycleChargeBeforeExpectedDate: 'BILLING_CYCLE_CHARGE_BEFORE_EXPECTED_DATE',
  BillingCycleSkipped: 'BILLING_CYCLE_SKIPPED',
  Blank: 'BLANK',
  ContractNotFound: 'CONTRACT_NOT_FOUND',
  ContractPaused: 'CONTRACT_PAUSED',
  ContractTerminated: 'CONTRACT_TERMINATED',
  ContractUnderReview: 'CONTRACT_UNDER_REVIEW',
  CycleIndexOutOfRange: 'CYCLE_INDEX_OUT_OF_RANGE',
  CycleStartDateOutOfRange: 'CYCLE_START_DATE_OUT_OF_RANGE',
  Invalid: 'INVALID',
  OriginTimeBeforeContractCreation: 'ORIGIN_TIME_BEFORE_CONTRACT_CREATION',
  OriginTimeOutOfRange: 'ORIGIN_TIME_OUT_OF_RANGE',
  UpcomingCycleLimitExceeded: 'UPCOMING_CYCLE_LIMIT_EXCEEDED'
} as const;

export type BillingAttemptUserErrorCode = typeof BillingAttemptUserErrorCode[keyof typeof BillingAttemptUserErrorCode];
export type Blog = HasEvents & HasMetafieldDefinitions & HasMetafields & HasPublishedTranslations & Node & {
  articles: ArticleConnection;
  articlesCount?: Maybe<Count>;
  commentPolicy: CommentPolicy;
  createdAt: Scalars['DateTime']['output'];
  events: EventConnection;
  feed?: Maybe<BlogFeed>;
  handle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  tags: Array<Scalars['String']['output']>;
  templateSuffix?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  translations: Array<Translation>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};


export type BlogArticlesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type BlogEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type BlogMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type BlogMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type BlogMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type BlogTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export type BlogConnection = {
  edges: Array<BlogEdge>;
  nodes: Array<Blog>;
  pageInfo: PageInfo;
};

export type BlogCreateInput = {
  commentPolicy?: InputMaybe<CommentPolicy>;
  handle?: InputMaybe<Scalars['String']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
  title: Scalars['String']['input'];
};

export type BlogCreatePayload = {
  blog?: Maybe<Blog>;
  userErrors: Array<BlogCreateUserError>;
};

export type BlogCreateUserError = DisplayableError & {
  code?: Maybe<BlogCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const BlogCreateUserErrorCode = {
  Inclusion: 'INCLUSION',
  Invalid: 'INVALID',
  InvalidType: 'INVALID_TYPE',
  InvalidValue: 'INVALID_VALUE',
  TooLong: 'TOO_LONG'
} as const;

export type BlogCreateUserErrorCode = typeof BlogCreateUserErrorCode[keyof typeof BlogCreateUserErrorCode];
export type BlogDeletePayload = {
  deletedBlogId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<BlogDeleteUserError>;
};

export type BlogDeleteUserError = DisplayableError & {
  code?: Maybe<BlogDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const BlogDeleteUserErrorCode = {
  NotFound: 'NOT_FOUND'
} as const;

export type BlogDeleteUserErrorCode = typeof BlogDeleteUserErrorCode[keyof typeof BlogDeleteUserErrorCode];
export type BlogEdge = {
  cursor: Scalars['String']['output'];
  node: Blog;
};

export type BlogFeed = {
  location: Scalars['URL']['output'];
  path: Scalars['String']['output'];
};

export const BlogSortKeys = {
  Handle: 'HANDLE',
  Id: 'ID',
  Relevance: 'RELEVANCE',
  Title: 'TITLE'
} as const;

export type BlogSortKeys = typeof BlogSortKeys[keyof typeof BlogSortKeys];
export type BlogUpdateInput = {
  commentPolicy?: InputMaybe<CommentPolicy>;
  handle?: InputMaybe<Scalars['String']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  redirectArticles?: InputMaybe<Scalars['Boolean']['input']>;
  redirectNewHandle?: InputMaybe<Scalars['Boolean']['input']>;
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type BlogUpdatePayload = {
  blog?: Maybe<Blog>;
  userErrors: Array<BlogUpdateUserError>;
};

export type BlogUpdateUserError = DisplayableError & {
  code?: Maybe<BlogUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const BlogUpdateUserErrorCode = {
  Blank: 'BLANK',
  Inclusion: 'INCLUSION',
  Invalid: 'INVALID',
  NotFound: 'NOT_FOUND',
  TooLong: 'TOO_LONG'
} as const;

export type BlogUpdateUserErrorCode = typeof BlogUpdateUserErrorCode[keyof typeof BlogUpdateUserErrorCode];
export const BulkMutationErrorCode = {
  InternalFileServerError: 'INTERNAL_FILE_SERVER_ERROR',
  InvalidMutation: 'INVALID_MUTATION',
  InvalidStagedUploadFile: 'INVALID_STAGED_UPLOAD_FILE',
  NoSuchFile: 'NO_SUCH_FILE',
  OperationInProgress: 'OPERATION_IN_PROGRESS'
} as const;

export type BulkMutationErrorCode = typeof BulkMutationErrorCode[keyof typeof BulkMutationErrorCode];
export type BulkMutationUserError = DisplayableError & {
  code?: Maybe<BulkMutationErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type BulkOperation = Node & {
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  errorCode?: Maybe<BulkOperationErrorCode>;
  fileSize?: Maybe<Scalars['UnsignedInt64']['output']>;
  id: Scalars['ID']['output'];
  objectCount: Scalars['UnsignedInt64']['output'];
  partialDataUrl?: Maybe<Scalars['URL']['output']>;
  query: Scalars['String']['output'];
  rootObjectCount: Scalars['UnsignedInt64']['output'];
  status: BulkOperationStatus;
  type: BulkOperationType;
  url?: Maybe<Scalars['URL']['output']>;
};

export type BulkOperationCancelPayload = {
  bulkOperation?: Maybe<BulkOperation>;
  userErrors: Array<UserError>;
};

export const BulkOperationErrorCode = {
  AccessDenied: 'ACCESS_DENIED',
  InternalServerError: 'INTERNAL_SERVER_ERROR',
  Timeout: 'TIMEOUT'
} as const;

export type BulkOperationErrorCode = typeof BulkOperationErrorCode[keyof typeof BulkOperationErrorCode];
export type BulkOperationRunMutationPayload = {
  bulkOperation?: Maybe<BulkOperation>;
  userErrors: Array<BulkMutationUserError>;
};

export type BulkOperationRunQueryPayload = {
  bulkOperation?: Maybe<BulkOperation>;
  userErrors: Array<BulkOperationUserError>;
};

export const BulkOperationStatus = {
  Canceled: 'CANCELED',
  Canceling: 'CANCELING',
  Completed: 'COMPLETED',
  Created: 'CREATED',
  Expired: 'EXPIRED',
  Failed: 'FAILED',
  Running: 'RUNNING'
} as const;

export type BulkOperationStatus = typeof BulkOperationStatus[keyof typeof BulkOperationStatus];
export const BulkOperationType = {
  Mutation: 'MUTATION',
  Query: 'QUERY'
} as const;

export type BulkOperationType = typeof BulkOperationType[keyof typeof BulkOperationType];
export type BulkOperationUserError = DisplayableError & {
  code?: Maybe<BulkOperationUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const BulkOperationUserErrorCode = {
  Invalid: 'INVALID',
  OperationInProgress: 'OPERATION_IN_PROGRESS'
} as const;

export type BulkOperationUserErrorCode = typeof BulkOperationUserErrorCode[keyof typeof BulkOperationUserErrorCode];
export type BulkProductResourceFeedbackCreatePayload = {
  feedback?: Maybe<Array<ProductResourceFeedback>>;
  userErrors: Array<BulkProductResourceFeedbackCreateUserError>;
};

export type BulkProductResourceFeedbackCreateUserError = DisplayableError & {
  code?: Maybe<BulkProductResourceFeedbackCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const BulkProductResourceFeedbackCreateUserErrorCode = {
  Blank: 'BLANK',
  Invalid: 'INVALID',
  LessThanOrEqualTo: 'LESS_THAN_OR_EQUAL_TO',
  MaximumFeedbackLimitExceeded: 'MAXIMUM_FEEDBACK_LIMIT_EXCEEDED',
  OutdatedFeedback: 'OUTDATED_FEEDBACK',
  Present: 'PRESENT',
  ProductNotFound: 'PRODUCT_NOT_FOUND'
} as const;

export type BulkProductResourceFeedbackCreateUserErrorCode = typeof BulkProductResourceFeedbackCreateUserErrorCode[keyof typeof BulkProductResourceFeedbackCreateUserErrorCode];
export type BundlesDraftOrderBundleLineItemComponentInput = {
  quantity: Scalars['Int']['input'];
  uuid?: InputMaybe<Scalars['String']['input']>;
  variantId?: InputMaybe<Scalars['ID']['input']>;
};

export type BundlesFeature = {
  eligibleForBundles: Scalars['Boolean']['output'];
  ineligibilityReason?: Maybe<Scalars['String']['output']>;
  sellsBundles: Scalars['Boolean']['output'];
};

export const BusinessCustomerErrorCode = {
  Blank: 'BLANK',
  FailedToDelete: 'FAILED_TO_DELETE',
  InternalError: 'INTERNAL_ERROR',
  Invalid: 'INVALID',
  InvalidInput: 'INVALID_INPUT',
  LimitReached: 'LIMIT_REACHED',
  NoInput: 'NO_INPUT',
  Required: 'REQUIRED',
  ResourceNotFound: 'RESOURCE_NOT_FOUND',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  UnexpectedType: 'UNEXPECTED_TYPE'
} as const;

export type BusinessCustomerErrorCode = typeof BusinessCustomerErrorCode[keyof typeof BusinessCustomerErrorCode];
export type BusinessCustomerUserError = DisplayableError & {
  code?: Maybe<BusinessCustomerErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type BusinessEntity = Node & {
  address: BusinessEntityAddress;
  companyName?: Maybe<Scalars['String']['output']>;
  displayName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  primary: Scalars['Boolean']['output'];
  shopifyPaymentsAccount?: Maybe<ShopifyPaymentsAccount>;
};

export type BusinessEntityAddress = {
  address1?: Maybe<Scalars['String']['output']>;
  address2?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  countryCode: CountryCode;
  province?: Maybe<Scalars['String']['output']>;
  zip?: Maybe<Scalars['String']['output']>;
};

export type BuyerExperienceConfiguration = {
  checkoutToDraft: Scalars['Boolean']['output'];
  deposit?: Maybe<DepositConfiguration>;
  editableShippingAddress: Scalars['Boolean']['output'];
  /** @deprecated Please use `checkoutToDraft`(must be false) and `paymentTermsTemplate`(must be nil) to derive this instead. */
  payNowOnly: Scalars['Boolean']['output'];
  paymentTermsTemplate?: Maybe<PaymentTermsTemplate>;
};

export type BuyerExperienceConfigurationInput = {
  checkoutToDraft?: InputMaybe<Scalars['Boolean']['input']>;
  deposit?: InputMaybe<DepositInput>;
  editableShippingAddress?: InputMaybe<Scalars['Boolean']['input']>;
  paymentTermsTemplateId?: InputMaybe<Scalars['ID']['input']>;
};

export type CalculateExchangeLineItemInput = {
  appliedDiscount?: InputMaybe<ExchangeLineItemAppliedDiscountInput>;
  quantity: Scalars['Int']['input'];
  variantId?: InputMaybe<Scalars['ID']['input']>;
};

export type CalculateReturnInput = {
  exchangeLineItems?: InputMaybe<Array<CalculateExchangeLineItemInput>>;
  orderId: Scalars['ID']['input'];
  returnLineItems?: InputMaybe<Array<CalculateReturnLineItemInput>>;
  returnShippingFee?: InputMaybe<ReturnShippingFeeInput>;
};

export type CalculateReturnLineItemInput = {
  fulfillmentLineItemId: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
  restockingFee?: InputMaybe<RestockingFeeInput>;
};

export type CalculatedAutomaticDiscountApplication = CalculatedDiscountApplication & {
  allocationMethod: DiscountApplicationAllocationMethod;
  appliedTo: DiscountApplicationLevel;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  targetSelection: DiscountApplicationTargetSelection;
  targetType: DiscountApplicationTargetType;
  value: PricingValue;
};

export type CalculatedDiscountAllocation = {
  allocatedAmountSet: MoneyBag;
  discountApplication: CalculatedDiscountApplication;
};

export type CalculatedDiscountApplication = {
  allocationMethod: DiscountApplicationAllocationMethod;
  appliedTo: DiscountApplicationLevel;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  targetSelection: DiscountApplicationTargetSelection;
  targetType: DiscountApplicationTargetType;
  value: PricingValue;
};

export type CalculatedDiscountApplicationConnection = {
  edges: Array<CalculatedDiscountApplicationEdge>;
  nodes: Array<CalculatedDiscountApplication>;
  pageInfo: PageInfo;
};

export type CalculatedDiscountApplicationEdge = {
  cursor: Scalars['String']['output'];
  node: CalculatedDiscountApplication;
};

export type CalculatedDiscountCodeApplication = CalculatedDiscountApplication & {
  allocationMethod: DiscountApplicationAllocationMethod;
  appliedTo: DiscountApplicationLevel;
  code: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  targetSelection: DiscountApplicationTargetSelection;
  targetType: DiscountApplicationTargetType;
  value: PricingValue;
};

export type CalculatedDraftOrder = {
  acceptAutomaticDiscounts?: Maybe<Scalars['Boolean']['output']>;
  alerts: Array<ResourceAlert>;
  allVariantPricesOverridden: Scalars['Boolean']['output'];
  anyVariantPricesOverridden: Scalars['Boolean']['output'];
  appliedDiscount?: Maybe<DraftOrderAppliedDiscount>;
  availableShippingRates: Array<ShippingRate>;
  billingAddressMatchesShippingAddress: Scalars['Boolean']['output'];
  currencyCode: CurrencyCode;
  customer?: Maybe<Customer>;
  discountCodes: Array<Scalars['String']['output']>;
  lineItems: Array<CalculatedDraftOrderLineItem>;
  lineItemsSubtotalPrice: MoneyBag;
  /** @deprecated This field is now incompatible with Markets. */
  marketName: Scalars['String']['output'];
  /** @deprecated This field is now incompatible with Markets. */
  marketRegionCountryCode: CountryCode;
  phone?: Maybe<Scalars['String']['output']>;
  platformDiscounts: Array<DraftOrderPlatformDiscount>;
  presentmentCurrencyCode: CurrencyCode;
  purchasingEntity?: Maybe<PurchasingEntity>;
  shippingLine?: Maybe<ShippingLine>;
  /** @deprecated Use `subtotalPriceSet` instead. */
  subtotalPrice: Scalars['Money']['output'];
  subtotalPriceSet: MoneyBag;
  taxLines: Array<TaxLine>;
  taxesIncluded: Scalars['Boolean']['output'];
  totalDiscountsSet: MoneyBag;
  totalLineItemsPriceSet: MoneyBag;
  /** @deprecated Use `totalPriceSet` instead. */
  totalPrice: Scalars['Money']['output'];
  totalPriceSet: MoneyBag;
  totalQuantityOfLineItems: Scalars['Int']['output'];
  /** @deprecated Use `totalShippingPriceSet` instead. */
  totalShippingPrice: Scalars['Money']['output'];
  totalShippingPriceSet: MoneyBag;
  /** @deprecated Use `totalTaxSet` instead. */
  totalTax: Scalars['Money']['output'];
  totalTaxSet: MoneyBag;
  transformerFingerprint?: Maybe<Scalars['String']['output']>;
  warnings: Array<DraftOrderWarning>;
};

export type CalculatedDraftOrderLineItem = {
  appliedDiscount?: Maybe<DraftOrderAppliedDiscount>;
  approximateDiscountedUnitPriceSet: MoneyBag;
  bundleComponents: Array<CalculatedDraftOrderLineItem>;
  custom: Scalars['Boolean']['output'];
  customAttributes: Array<Attribute>;
  customAttributesV2: Array<TypedAttribute>;
  discountedTotal: MoneyV2;
  discountedTotalSet: MoneyBag;
  /** @deprecated Use `approximateDiscountedUnitPriceSet` instead. */
  discountedUnitPrice: MoneyV2;
  /** @deprecated Use `approximateDiscountedUnitPriceSet` instead. */
  discountedUnitPriceSet: MoneyBag;
  fulfillmentService?: Maybe<FulfillmentService>;
  image?: Maybe<Image>;
  isGiftCard: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  originalTotal: MoneyV2;
  originalTotalSet: MoneyBag;
  originalUnitPrice: MoneyV2;
  originalUnitPriceSet: MoneyBag;
  originalUnitPriceWithCurrency?: Maybe<MoneyV2>;
  priceOverride?: Maybe<MoneyV2>;
  product?: Maybe<Product>;
  quantity: Scalars['Int']['output'];
  requiresShipping: Scalars['Boolean']['output'];
  sku?: Maybe<Scalars['String']['output']>;
  taxable: Scalars['Boolean']['output'];
  title: Scalars['String']['output'];
  totalDiscount: MoneyV2;
  totalDiscountSet: MoneyBag;
  uuid: Scalars['String']['output'];
  variant?: Maybe<ProductVariant>;
  variantTitle?: Maybe<Scalars['String']['output']>;
  vendor?: Maybe<Scalars['String']['output']>;
  weight?: Maybe<Weight>;
};

export type CalculatedExchangeLineItem = {
  calculatedDiscountAllocations: Array<CalculatedDiscountAllocation>;
  discountedUnitPriceSet: MoneyBag;
  id?: Maybe<Scalars['ID']['output']>;
  originalUnitPriceSet: MoneyBag;
  quantity: Scalars['Int']['output'];
  subtotalSet: MoneyBag;
  totalTaxSet: MoneyBag;
  variant?: Maybe<ProductVariant>;
};

export type CalculatedLineItem = {
  calculatedDiscountAllocations: Array<CalculatedDiscountAllocation>;
  customAttributes: Array<Attribute>;
  /** @deprecated Use `calculatedDiscountAllocations` instead. */
  discountAllocations: Array<DiscountAllocation>;
  discountedUnitPriceSet: MoneyBag;
  editableQuantity: Scalars['Int']['output'];
  editableQuantityBeforeChanges: Scalars['Int']['output'];
  editableSubtotalSet: MoneyBag;
  hasStagedLineItemDiscount: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  image?: Maybe<Image>;
  originalUnitPriceSet: MoneyBag;
  quantity: Scalars['Int']['output'];
  restockable: Scalars['Boolean']['output'];
  restocking: Scalars['Boolean']['output'];
  sku?: Maybe<Scalars['String']['output']>;
  stagedChanges: Array<OrderStagedChange>;
  title: Scalars['String']['output'];
  uneditableSubtotalSet: MoneyBag;
  variant?: Maybe<ProductVariant>;
  variantTitle?: Maybe<Scalars['String']['output']>;
};

export type CalculatedLineItemConnection = {
  edges: Array<CalculatedLineItemEdge>;
  nodes: Array<CalculatedLineItem>;
  pageInfo: PageInfo;
};

export type CalculatedLineItemEdge = {
  cursor: Scalars['String']['output'];
  node: CalculatedLineItem;
};

export type CalculatedManualDiscountApplication = CalculatedDiscountApplication & {
  allocationMethod: DiscountApplicationAllocationMethod;
  appliedTo: DiscountApplicationLevel;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  targetSelection: DiscountApplicationTargetSelection;
  targetType: DiscountApplicationTargetType;
  value: PricingValue;
};

export type CalculatedOrder = Node & {
  addedDiscountApplications: CalculatedDiscountApplicationConnection;
  addedLineItems: CalculatedLineItemConnection;
  cartDiscountAmountSet?: Maybe<MoneyBag>;
  /** @deprecated CalculatedOrder for committed order edits is being deprecated, and this field will also be removed in a future version.  See [changelog](https://shopify.dev/changelog/deprecation-notice-calculatedorder-for-committed-order-edits) for more details. */
  committed: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  lineItems: CalculatedLineItemConnection;
  notificationPreviewHtml?: Maybe<Scalars['HTML']['output']>;
  notificationPreviewTitle: Scalars['String']['output'];
  originalOrder: Order;
  shippingLines: Array<CalculatedShippingLine>;
  stagedChanges: OrderStagedChangeConnection;
  subtotalLineItemsQuantity: Scalars['Int']['output'];
  subtotalPriceSet?: Maybe<MoneyBag>;
  taxLines: Array<TaxLine>;
  totalOutstandingSet: MoneyBag;
  totalPriceSet: MoneyBag;
};


export type CalculatedOrderAddedDiscountApplicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CalculatedOrderAddedLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CalculatedOrderLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CalculatedOrderStagedChangesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CalculatedRestockingFee = CalculatedReturnFee & {
  amountSet: MoneyBag;
  id: Scalars['ID']['output'];
  percentage: Scalars['Float']['output'];
};

export type CalculatedReturn = {
  exchangeLineItems: Array<CalculatedExchangeLineItem>;
  id: Scalars['ID']['output'];
  returnLineItems: Array<CalculatedReturnLineItem>;
  returnShippingFee?: Maybe<CalculatedReturnShippingFee>;
};

export type CalculatedReturnFee = {
  amountSet: MoneyBag;
  id: Scalars['ID']['output'];
};

export type CalculatedReturnLineItem = {
  fulfillmentLineItem: FulfillmentLineItem;
  id?: Maybe<Scalars['ID']['output']>;
  quantity: Scalars['Int']['output'];
  restockingFee?: Maybe<CalculatedRestockingFee>;
  subtotalBeforeOrderDiscountsSet: MoneyBag;
  subtotalSet: MoneyBag;
  totalTaxSet: MoneyBag;
};

export type CalculatedReturnShippingFee = CalculatedReturnFee & {
  amountSet: MoneyBag;
  id: Scalars['ID']['output'];
};

export type CalculatedScriptDiscountApplication = CalculatedDiscountApplication & {
  allocationMethod: DiscountApplicationAllocationMethod;
  appliedTo: DiscountApplicationLevel;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  targetSelection: DiscountApplicationTargetSelection;
  targetType: DiscountApplicationTargetType;
  value: PricingValue;
};

export type CalculatedShippingLine = {
  id?: Maybe<Scalars['ID']['output']>;
  price: MoneyBag;
  stagedStatus: CalculatedShippingLineStagedStatus;
  title: Scalars['String']['output'];
};

export const CalculatedShippingLineStagedStatus = {
  Added: 'ADDED',
  None: 'NONE',
  Removed: 'REMOVED'
} as const;

export type CalculatedShippingLineStagedStatus = typeof CalculatedShippingLineStagedStatus[keyof typeof CalculatedShippingLineStagedStatus];
export type CardPaymentDetails = BasePaymentDetails & {
  avsResultCode?: Maybe<Scalars['String']['output']>;
  bin?: Maybe<Scalars['String']['output']>;
  company?: Maybe<Scalars['String']['output']>;
  cvvResultCode?: Maybe<Scalars['String']['output']>;
  expirationMonth?: Maybe<Scalars['Int']['output']>;
  expirationYear?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['String']['output']>;
  paymentMethodName?: Maybe<Scalars['String']['output']>;
  wallet?: Maybe<DigitalWallet>;
};

export type CarrierServiceCreatePayload = {
  carrierService?: Maybe<DeliveryCarrierService>;
  userErrors: Array<CarrierServiceCreateUserError>;
};

export type CarrierServiceCreateUserError = DisplayableError & {
  code?: Maybe<CarrierServiceCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CarrierServiceCreateUserErrorCode = {
  CarrierServiceCreateFailed: 'CARRIER_SERVICE_CREATE_FAILED'
} as const;

export type CarrierServiceCreateUserErrorCode = typeof CarrierServiceCreateUserErrorCode[keyof typeof CarrierServiceCreateUserErrorCode];
export type CarrierServiceDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<CarrierServiceDeleteUserError>;
};

export type CarrierServiceDeleteUserError = DisplayableError & {
  code?: Maybe<CarrierServiceDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CarrierServiceDeleteUserErrorCode = {
  CarrierServiceDeleteFailed: 'CARRIER_SERVICE_DELETE_FAILED'
} as const;

export type CarrierServiceDeleteUserErrorCode = typeof CarrierServiceDeleteUserErrorCode[keyof typeof CarrierServiceDeleteUserErrorCode];
export const CarrierServiceSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type CarrierServiceSortKeys = typeof CarrierServiceSortKeys[keyof typeof CarrierServiceSortKeys];
export type CarrierServiceUpdatePayload = {
  carrierService?: Maybe<DeliveryCarrierService>;
  userErrors: Array<CarrierServiceUpdateUserError>;
};

export type CarrierServiceUpdateUserError = DisplayableError & {
  code?: Maybe<CarrierServiceUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CarrierServiceUpdateUserErrorCode = {
  CarrierServiceUpdateFailed: 'CARRIER_SERVICE_UPDATE_FAILED'
} as const;

export type CarrierServiceUpdateUserErrorCode = typeof CarrierServiceUpdateUserErrorCode[keyof typeof CarrierServiceUpdateUserErrorCode];
export type CartTransform = HasMetafields & Node & {
  blockOnFailure: Scalars['Boolean']['output'];
  functionId: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  metafield?: Maybe<Metafield>;
  metafields: MetafieldConnection;
};


export type CartTransformMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type CartTransformMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CartTransformConnection = {
  edges: Array<CartTransformEdge>;
  nodes: Array<CartTransform>;
  pageInfo: PageInfo;
};

export type CartTransformCreatePayload = {
  cartTransform?: Maybe<CartTransform>;
  userErrors: Array<CartTransformCreateUserError>;
};

export type CartTransformCreateUserError = DisplayableError & {
  code?: Maybe<CartTransformCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CartTransformCreateUserErrorCode = {
  FunctionAlreadyRegistered: 'FUNCTION_ALREADY_REGISTERED',
  FunctionDoesNotImplement: 'FUNCTION_DOES_NOT_IMPLEMENT',
  FunctionNotFound: 'FUNCTION_NOT_FOUND',
  InputInvalid: 'INPUT_INVALID',
  InvalidMetafields: 'INVALID_METAFIELDS'
} as const;

export type CartTransformCreateUserErrorCode = typeof CartTransformCreateUserErrorCode[keyof typeof CartTransformCreateUserErrorCode];
export type CartTransformDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<CartTransformDeleteUserError>;
};

export type CartTransformDeleteUserError = DisplayableError & {
  code?: Maybe<CartTransformDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CartTransformDeleteUserErrorCode = {
  NotFound: 'NOT_FOUND',
  UnauthorizedAppScope: 'UNAUTHORIZED_APP_SCOPE'
} as const;

export type CartTransformDeleteUserErrorCode = typeof CartTransformDeleteUserErrorCode[keyof typeof CartTransformDeleteUserErrorCode];
export type CartTransformEdge = {
  cursor: Scalars['String']['output'];
  node: CartTransform;
};

export type CartTransformEligibleOperations = {
  expandOperation: Scalars['Boolean']['output'];
  mergeOperation: Scalars['Boolean']['output'];
  updateOperation: Scalars['Boolean']['output'];
};

export type CartTransformFeature = {
  eligibleOperations: CartTransformEligibleOperations;
};

export type CashRoundingAdjustment = {
  paymentSet: MoneyBag;
  refundSet: MoneyBag;
};

export type CashTrackingAdjustment = Node & {
  cash: MoneyV2;
  id: Scalars['ID']['output'];
  note?: Maybe<Scalars['String']['output']>;
  staffMember: StaffMember;
  time: Scalars['DateTime']['output'];
};

export type CashTrackingAdjustmentConnection = {
  edges: Array<CashTrackingAdjustmentEdge>;
  nodes: Array<CashTrackingAdjustment>;
  pageInfo: PageInfo;
};

export type CashTrackingAdjustmentEdge = {
  cursor: Scalars['String']['output'];
  node: CashTrackingAdjustment;
};

export type CashTrackingSession = Node & {
  adjustments: CashTrackingAdjustmentConnection;
  cashTrackingEnabled: Scalars['Boolean']['output'];
  cashTransactions: OrderTransactionConnection;
  closingBalance?: Maybe<MoneyV2>;
  closingNote?: Maybe<Scalars['String']['output']>;
  closingStaffMember?: Maybe<StaffMember>;
  closingTime?: Maybe<Scalars['DateTime']['output']>;
  expectedBalance: MoneyV2;
  expectedClosingBalance?: Maybe<MoneyV2>;
  expectedOpeningBalance?: Maybe<MoneyV2>;
  id: Scalars['ID']['output'];
  location?: Maybe<Location>;
  netCashSales: MoneyV2;
  openingBalance: MoneyV2;
  openingNote?: Maybe<Scalars['String']['output']>;
  openingStaffMember?: Maybe<StaffMember>;
  openingTime: Scalars['DateTime']['output'];
  registerName: Scalars['String']['output'];
  totalAdjustments?: Maybe<MoneyV2>;
  totalCashRefunds: MoneyV2;
  totalCashSales: MoneyV2;
  totalDiscrepancy?: Maybe<MoneyV2>;
};


export type CashTrackingSessionAdjustmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<AdjustmentsSortKeys>;
};


export type CashTrackingSessionCashTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CashTrackingSessionTransactionsSortKeys>;
};

export type CashTrackingSessionConnection = {
  edges: Array<CashTrackingSessionEdge>;
  nodes: Array<CashTrackingSession>;
  pageInfo: PageInfo;
};

export type CashTrackingSessionEdge = {
  cursor: Scalars['String']['output'];
  node: CashTrackingSession;
};

export const CashTrackingSessionTransactionsSortKeys = {
  Id: 'ID',
  ProcessedAt: 'PROCESSED_AT',
  Relevance: 'RELEVANCE'
} as const;

export type CashTrackingSessionTransactionsSortKeys = typeof CashTrackingSessionTransactionsSortKeys[keyof typeof CashTrackingSessionTransactionsSortKeys];
export const CashTrackingSessionsSortKeys = {
  ClosingTimeAsc: 'CLOSING_TIME_ASC',
  ClosingTimeDesc: 'CLOSING_TIME_DESC',
  Id: 'ID',
  OpeningTimeAsc: 'OPENING_TIME_ASC',
  OpeningTimeDesc: 'OPENING_TIME_DESC',
  Relevance: 'RELEVANCE',
  TotalDiscrepancyAsc: 'TOTAL_DISCREPANCY_ASC',
  TotalDiscrepancyDesc: 'TOTAL_DISCREPANCY_DESC'
} as const;

export type CashTrackingSessionsSortKeys = typeof CashTrackingSessionsSortKeys[keyof typeof CashTrackingSessionsSortKeys];
export type Catalog = {
  id: Scalars['ID']['output'];
  operations: Array<ResourceOperation>;
  priceList?: Maybe<PriceList>;
  publication?: Maybe<Publication>;
  status: CatalogStatus;
  title: Scalars['String']['output'];
};

export type CatalogConnection = {
  edges: Array<CatalogEdge>;
  nodes: Array<Catalog>;
  pageInfo: PageInfo;
};

export type CatalogContextInput = {
  companyLocationIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type CatalogContextUpdatePayload = {
  catalog?: Maybe<Catalog>;
  userErrors: Array<CatalogUserError>;
};

export type CatalogCreateInput = {
  context: CatalogContextInput;
  priceListId?: InputMaybe<Scalars['ID']['input']>;
  publicationId?: InputMaybe<Scalars['ID']['input']>;
  status: CatalogStatus;
  title: Scalars['String']['input'];
};

export type CatalogCreatePayload = {
  catalog?: Maybe<Catalog>;
  userErrors: Array<CatalogUserError>;
};

export type CatalogCsvOperation = Node & ResourceOperation & {
  id: Scalars['ID']['output'];
  processedRowCount?: Maybe<Scalars['Int']['output']>;
  rowCount?: Maybe<RowCount>;
  status: ResourceOperationStatus;
};

export type CatalogDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<CatalogUserError>;
};

export type CatalogEdge = {
  cursor: Scalars['String']['output'];
  node: Catalog;
};

export const CatalogSortKeys = {
  Id: 'ID',
  Relevance: 'RELEVANCE',
  Title: 'TITLE'
} as const;

export type CatalogSortKeys = typeof CatalogSortKeys[keyof typeof CatalogSortKeys];
export const CatalogStatus = {
  Active: 'ACTIVE',
  Archived: 'ARCHIVED',
  Draft: 'DRAFT'
} as const;

export type CatalogStatus = typeof CatalogStatus[keyof typeof CatalogStatus];
export const CatalogType = {
  App: 'APP',
  CompanyLocation: 'COMPANY_LOCATION',
  Market: 'MARKET',
  None: 'NONE'
} as const;

export type CatalogType = typeof CatalogType[keyof typeof CatalogType];
export type CatalogUpdateInput = {
  context?: InputMaybe<CatalogContextInput>;
  priceListId?: InputMaybe<Scalars['ID']['input']>;
  publicationId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<CatalogStatus>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type CatalogUpdatePayload = {
  catalog?: Maybe<Catalog>;
  userErrors: Array<CatalogUserError>;
};

export type CatalogUserError = DisplayableError & {
  code?: Maybe<CatalogUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CatalogUserErrorCode = {
  AppCatalogPriceListAssignment: 'APP_CATALOG_PRICE_LIST_ASSIGNMENT',
  Blank: 'BLANK',
  CannotAddMoreThanOneMarket: 'CANNOT_ADD_MORE_THAN_ONE_MARKET',
  CannotCreateAppCatalog: 'CANNOT_CREATE_APP_CATALOG',
  CannotCreateMarketCatalog: 'CANNOT_CREATE_MARKET_CATALOG',
  CannotDeleteAppCatalog: 'CANNOT_DELETE_APP_CATALOG',
  CannotDeleteMarketCatalog: 'CANNOT_DELETE_MARKET_CATALOG',
  CannotModifyAppCatalog: 'CANNOT_MODIFY_APP_CATALOG',
  CannotModifyMarketCatalog: 'CANNOT_MODIFY_MARKET_CATALOG',
  CatalogContextDoesNotSupportQuantityPriceBreaks: 'CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_PRICE_BREAKS',
  CatalogContextDoesNotSupportQuantityRules: 'CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_RULES',
  CatalogFailedToSave: 'CATALOG_FAILED_TO_SAVE',
  CatalogNotFound: 'CATALOG_NOT_FOUND',
  CompanyLocationCatalogStatusPlan: 'COMPANY_LOCATION_CATALOG_STATUS_PLAN',
  CompanyLocationNotFound: 'COMPANY_LOCATION_NOT_FOUND',
  ContextAlreadyAssignedToCatalog: 'CONTEXT_ALREADY_ASSIGNED_TO_CATALOG',
  ContextCatalogLimitReached: 'CONTEXT_CATALOG_LIMIT_REACHED',
  ContextDriverMismatch: 'CONTEXT_DRIVER_MISMATCH',
  CountryPriceListAssignment: 'COUNTRY_PRICE_LIST_ASSIGNMENT',
  Invalid: 'INVALID',
  InvalidCatalogContextType: 'INVALID_CATALOG_CONTEXT_TYPE',
  MarketAndPriceListCurrencyMismatch: 'MARKET_AND_PRICE_LIST_CURRENCY_MISMATCH',
  MarketCatalogStatus: 'MARKET_CATALOG_STATUS',
  MarketNotFound: 'MARKET_NOT_FOUND',
  MarketTaken: 'MARKET_TAKEN',
  MustProvideExactlyOneContextType: 'MUST_PROVIDE_EXACTLY_ONE_CONTEXT_TYPE',
  PriceListFailedToSave: 'PRICE_LIST_FAILED_TO_SAVE',
  PriceListLocked: 'PRICE_LIST_LOCKED',
  PriceListNotAllowedForPrimaryMarket: 'PRICE_LIST_NOT_ALLOWED_FOR_PRIMARY_MARKET',
  PriceListNotFound: 'PRICE_LIST_NOT_FOUND',
  PublicationNotFound: 'PUBLICATION_NOT_FOUND',
  RequiresContextsToAddOrRemove: 'REQUIRES_CONTEXTS_TO_ADD_OR_REMOVE',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  TooShort: 'TOO_SHORT',
  UnsupportedCatalogAction: 'UNSUPPORTED_CATALOG_ACTION'
} as const;

export type CatalogUserErrorCode = typeof CatalogUserErrorCode[keyof typeof CatalogUserErrorCode];
export type Channel = Node & {
  app: App;
  collectionPublicationsV3: ResourcePublicationConnection;
  collections: CollectionConnection;
  /** @deprecated Use `id` instead. */
  handle: Scalars['String']['output'];
  hasCollection: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  /**
   * @deprecated Use [AppInstallation.navigationItems](
   *           https://shopify.dev/api/admin-graphql/current/objects/AppInstallation#field-appinstallation-navigationitems) instead.
   */
  navigationItems: Array<NavigationItem>;
  /**
   * @deprecated Use [AppInstallation.launchUrl](
   *           https://shopify.dev/api/admin-graphql/current/objects/AppInstallation#field-appinstallation-launchurl) instead.
   */
  overviewPath?: Maybe<Scalars['URL']['output']>;
  /** @deprecated Use `productPublicationsV3` instead. */
  productPublications: ProductPublicationConnection;
  productPublicationsV3: ResourcePublicationConnection;
  products: ProductConnection;
  productsCount?: Maybe<Count>;
  supportsFuturePublishing: Scalars['Boolean']['output'];
};


export type ChannelCollectionPublicationsV3Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ChannelCollectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ChannelHasCollectionArgs = {
  id: Scalars['ID']['input'];
};


export type ChannelProductPublicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ChannelProductPublicationsV3Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ChannelProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ChannelProductsCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
};

export type ChannelConnection = {
  edges: Array<ChannelEdge>;
  nodes: Array<Channel>;
  pageInfo: PageInfo;
};

export type ChannelDefinition = Node & {
  channelName: Scalars['String']['output'];
  handle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isMarketplace: Scalars['Boolean']['output'];
  subChannelName: Scalars['String']['output'];
  svgIcon?: Maybe<Scalars['String']['output']>;
};

export type ChannelEdge = {
  cursor: Scalars['String']['output'];
  node: Channel;
};

export type ChannelInformation = Node & {
  app: App;
  channelDefinition?: Maybe<ChannelDefinition>;
  channelId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
};

export type CheckoutBranding = {
  customizations?: Maybe<CheckoutBrandingCustomizations>;
  designSystem?: Maybe<CheckoutBrandingDesignSystem>;
};

export const CheckoutBrandingBackground = {
  Base: 'BASE',
  Subdued: 'SUBDUED',
  Transparent: 'TRANSPARENT'
} as const;

export type CheckoutBrandingBackground = typeof CheckoutBrandingBackground[keyof typeof CheckoutBrandingBackground];
export const CheckoutBrandingBackgroundStyle = {
  None: 'NONE',
  Solid: 'SOLID'
} as const;

export type CheckoutBrandingBackgroundStyle = typeof CheckoutBrandingBackgroundStyle[keyof typeof CheckoutBrandingBackgroundStyle];
export const CheckoutBrandingBorder = {
  BlockEnd: 'BLOCK_END',
  Full: 'FULL',
  None: 'NONE'
} as const;

export type CheckoutBrandingBorder = typeof CheckoutBrandingBorder[keyof typeof CheckoutBrandingBorder];
export const CheckoutBrandingBorderStyle = {
  Base: 'BASE',
  Dashed: 'DASHED',
  Dotted: 'DOTTED'
} as const;

export type CheckoutBrandingBorderStyle = typeof CheckoutBrandingBorderStyle[keyof typeof CheckoutBrandingBorderStyle];
export const CheckoutBrandingBorderWidth = {
  Base: 'BASE',
  Large: 'LARGE',
  Large_100: 'LARGE_100',
  Large_200: 'LARGE_200'
} as const;

export type CheckoutBrandingBorderWidth = typeof CheckoutBrandingBorderWidth[keyof typeof CheckoutBrandingBorderWidth];
export type CheckoutBrandingButton = {
  background?: Maybe<CheckoutBrandingBackgroundStyle>;
  blockPadding?: Maybe<CheckoutBrandingSpacing>;
  border?: Maybe<CheckoutBrandingSimpleBorder>;
  cornerRadius?: Maybe<CheckoutBrandingCornerRadius>;
  inlinePadding?: Maybe<CheckoutBrandingSpacing>;
  typography?: Maybe<CheckoutBrandingTypographyStyle>;
};

export type CheckoutBrandingButtonColorRoles = {
  accent?: Maybe<Scalars['String']['output']>;
  background?: Maybe<Scalars['String']['output']>;
  border?: Maybe<Scalars['String']['output']>;
  decorative?: Maybe<Scalars['String']['output']>;
  hover?: Maybe<CheckoutBrandingColorRoles>;
  icon?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

export type CheckoutBrandingButtonColorRolesInput = {
  accent?: InputMaybe<Scalars['String']['input']>;
  background?: InputMaybe<Scalars['String']['input']>;
  border?: InputMaybe<Scalars['String']['input']>;
  decorative?: InputMaybe<Scalars['String']['input']>;
  hover?: InputMaybe<CheckoutBrandingColorRolesInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

export type CheckoutBrandingButtonInput = {
  background?: InputMaybe<CheckoutBrandingBackgroundStyle>;
  blockPadding?: InputMaybe<CheckoutBrandingSpacing>;
  border?: InputMaybe<CheckoutBrandingSimpleBorder>;
  cornerRadius?: InputMaybe<CheckoutBrandingCornerRadius>;
  inlinePadding?: InputMaybe<CheckoutBrandingSpacing>;
  typography?: InputMaybe<CheckoutBrandingTypographyStyleInput>;
};

export type CheckoutBrandingBuyerJourney = {
  visibility?: Maybe<CheckoutBrandingVisibility>;
};

export type CheckoutBrandingBuyerJourneyInput = {
  visibility?: InputMaybe<CheckoutBrandingVisibility>;
};

export type CheckoutBrandingCartLink = {
  visibility?: Maybe<CheckoutBrandingVisibility>;
};

export const CheckoutBrandingCartLinkContentType = {
  Icon: 'ICON',
  Image: 'IMAGE',
  Text: 'TEXT'
} as const;

export type CheckoutBrandingCartLinkContentType = typeof CheckoutBrandingCartLinkContentType[keyof typeof CheckoutBrandingCartLinkContentType];
export type CheckoutBrandingCartLinkInput = {
  visibility?: InputMaybe<CheckoutBrandingVisibility>;
};

export type CheckoutBrandingCheckbox = {
  cornerRadius?: Maybe<CheckoutBrandingCornerRadius>;
};

export type CheckoutBrandingCheckboxInput = {
  cornerRadius?: InputMaybe<CheckoutBrandingCornerRadius>;
};

export type CheckoutBrandingChoiceList = {
  group?: Maybe<CheckoutBrandingChoiceListGroup>;
};

export type CheckoutBrandingChoiceListGroup = {
  spacing?: Maybe<CheckoutBrandingSpacingKeyword>;
};

export type CheckoutBrandingChoiceListGroupInput = {
  spacing?: InputMaybe<CheckoutBrandingSpacingKeyword>;
};

export type CheckoutBrandingChoiceListInput = {
  group?: InputMaybe<CheckoutBrandingChoiceListGroupInput>;
};

export type CheckoutBrandingColorGlobal = {
  accent?: Maybe<Scalars['String']['output']>;
  brand?: Maybe<Scalars['String']['output']>;
  critical?: Maybe<Scalars['String']['output']>;
  decorative?: Maybe<Scalars['String']['output']>;
  info?: Maybe<Scalars['String']['output']>;
  success?: Maybe<Scalars['String']['output']>;
  warning?: Maybe<Scalars['String']['output']>;
};

export type CheckoutBrandingColorGlobalInput = {
  accent?: InputMaybe<Scalars['String']['input']>;
  brand?: InputMaybe<Scalars['String']['input']>;
  critical?: InputMaybe<Scalars['String']['input']>;
  decorative?: InputMaybe<Scalars['String']['input']>;
  info?: InputMaybe<Scalars['String']['input']>;
  success?: InputMaybe<Scalars['String']['input']>;
  warning?: InputMaybe<Scalars['String']['input']>;
};

export type CheckoutBrandingColorRoles = {
  accent?: Maybe<Scalars['String']['output']>;
  background?: Maybe<Scalars['String']['output']>;
  border?: Maybe<Scalars['String']['output']>;
  decorative?: Maybe<Scalars['String']['output']>;
  icon?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

export type CheckoutBrandingColorRolesInput = {
  accent?: InputMaybe<Scalars['String']['input']>;
  background?: InputMaybe<Scalars['String']['input']>;
  border?: InputMaybe<Scalars['String']['input']>;
  decorative?: InputMaybe<Scalars['String']['input']>;
  icon?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

export type CheckoutBrandingColorScheme = {
  base?: Maybe<CheckoutBrandingColorRoles>;
  control?: Maybe<CheckoutBrandingControlColorRoles>;
  primaryButton?: Maybe<CheckoutBrandingButtonColorRoles>;
  secondaryButton?: Maybe<CheckoutBrandingButtonColorRoles>;
};

export type CheckoutBrandingColorSchemeInput = {
  base?: InputMaybe<CheckoutBrandingColorRolesInput>;
  control?: InputMaybe<CheckoutBrandingControlColorRolesInput>;
  primaryButton?: InputMaybe<CheckoutBrandingButtonColorRolesInput>;
  secondaryButton?: InputMaybe<CheckoutBrandingButtonColorRolesInput>;
};

export const CheckoutBrandingColorSchemeSelection = {
  ColorScheme1: 'COLOR_SCHEME1',
  ColorScheme2: 'COLOR_SCHEME2',
  ColorScheme3: 'COLOR_SCHEME3',
  ColorScheme4: 'COLOR_SCHEME4',
  Transparent: 'TRANSPARENT'
} as const;

export type CheckoutBrandingColorSchemeSelection = typeof CheckoutBrandingColorSchemeSelection[keyof typeof CheckoutBrandingColorSchemeSelection];
export type CheckoutBrandingColorSchemes = {
  scheme1?: Maybe<CheckoutBrandingColorScheme>;
  scheme2?: Maybe<CheckoutBrandingColorScheme>;
  scheme3?: Maybe<CheckoutBrandingColorScheme>;
  scheme4?: Maybe<CheckoutBrandingColorScheme>;
};

export type CheckoutBrandingColorSchemesInput = {
  scheme1?: InputMaybe<CheckoutBrandingColorSchemeInput>;
  scheme2?: InputMaybe<CheckoutBrandingColorSchemeInput>;
  scheme3?: InputMaybe<CheckoutBrandingColorSchemeInput>;
  scheme4?: InputMaybe<CheckoutBrandingColorSchemeInput>;
};

export const CheckoutBrandingColorSelection = {
  Transparent: 'TRANSPARENT'
} as const;

export type CheckoutBrandingColorSelection = typeof CheckoutBrandingColorSelection[keyof typeof CheckoutBrandingColorSelection];
export type CheckoutBrandingColors = {
  global?: Maybe<CheckoutBrandingColorGlobal>;
  schemes?: Maybe<CheckoutBrandingColorSchemes>;
};

export type CheckoutBrandingColorsInput = {
  global?: InputMaybe<CheckoutBrandingColorGlobalInput>;
  schemes?: InputMaybe<CheckoutBrandingColorSchemesInput>;
};

export type CheckoutBrandingContainerDivider = {
  borderStyle?: Maybe<CheckoutBrandingBorderStyle>;
  borderWidth?: Maybe<CheckoutBrandingBorderWidth>;
  visibility?: Maybe<CheckoutBrandingVisibility>;
};

export type CheckoutBrandingContainerDividerInput = {
  borderStyle?: InputMaybe<CheckoutBrandingBorderStyle>;
  borderWidth?: InputMaybe<CheckoutBrandingBorderWidth>;
  visibility?: InputMaybe<CheckoutBrandingVisibility>;
};

export type CheckoutBrandingContent = {
  divider?: Maybe<CheckoutBrandingContainerDivider>;
};

export type CheckoutBrandingContentInput = {
  divider?: InputMaybe<CheckoutBrandingContainerDividerInput>;
};

export type CheckoutBrandingControl = {
  border?: Maybe<CheckoutBrandingSimpleBorder>;
  color?: Maybe<CheckoutBrandingColorSelection>;
  cornerRadius?: Maybe<CheckoutBrandingCornerRadius>;
  labelPosition?: Maybe<CheckoutBrandingLabelPosition>;
};

export type CheckoutBrandingControlColorRoles = {
  accent?: Maybe<Scalars['String']['output']>;
  background?: Maybe<Scalars['String']['output']>;
  border?: Maybe<Scalars['String']['output']>;
  decorative?: Maybe<Scalars['String']['output']>;
  icon?: Maybe<Scalars['String']['output']>;
  selected?: Maybe<CheckoutBrandingColorRoles>;
  text?: Maybe<Scalars['String']['output']>;
};

export type CheckoutBrandingControlColorRolesInput = {
  accent?: InputMaybe<Scalars['String']['input']>;
  background?: InputMaybe<Scalars['String']['input']>;
  border?: InputMaybe<Scalars['String']['input']>;
  decorative?: InputMaybe<Scalars['String']['input']>;
  icon?: InputMaybe<Scalars['String']['input']>;
  selected?: InputMaybe<CheckoutBrandingColorRolesInput>;
  text?: InputMaybe<Scalars['String']['input']>;
};

export type CheckoutBrandingControlInput = {
  border?: InputMaybe<CheckoutBrandingSimpleBorder>;
  color?: InputMaybe<CheckoutBrandingColorSelection>;
  cornerRadius?: InputMaybe<CheckoutBrandingCornerRadius>;
  labelPosition?: InputMaybe<CheckoutBrandingLabelPosition>;
};

export const CheckoutBrandingCornerRadius = {
  Base: 'BASE',
  Large: 'LARGE',
  None: 'NONE',
  Small: 'SMALL'
} as const;

export type CheckoutBrandingCornerRadius = typeof CheckoutBrandingCornerRadius[keyof typeof CheckoutBrandingCornerRadius];
export type CheckoutBrandingCornerRadiusVariables = {
  base?: Maybe<Scalars['Int']['output']>;
  large?: Maybe<Scalars['Int']['output']>;
  small?: Maybe<Scalars['Int']['output']>;
};

export type CheckoutBrandingCornerRadiusVariablesInput = {
  base?: InputMaybe<Scalars['Int']['input']>;
  large?: InputMaybe<Scalars['Int']['input']>;
  small?: InputMaybe<Scalars['Int']['input']>;
};

export type CheckoutBrandingCustomFont = CheckoutBrandingFont & {
  genericFileId?: Maybe<Scalars['ID']['output']>;
  sources?: Maybe<Scalars['String']['output']>;
  weight?: Maybe<Scalars['Int']['output']>;
};

export type CheckoutBrandingCustomFontGroupInput = {
  base: CheckoutBrandingCustomFontInput;
  bold: CheckoutBrandingCustomFontInput;
  loadingStrategy?: InputMaybe<CheckoutBrandingFontLoadingStrategy>;
};

export type CheckoutBrandingCustomFontInput = {
  genericFileId: Scalars['ID']['input'];
  weight: Scalars['Int']['input'];
};

export type CheckoutBrandingCustomizations = {
  buyerJourney?: Maybe<CheckoutBrandingBuyerJourney>;
  cartLink?: Maybe<CheckoutBrandingCartLink>;
  checkbox?: Maybe<CheckoutBrandingCheckbox>;
  choiceList?: Maybe<CheckoutBrandingChoiceList>;
  content?: Maybe<CheckoutBrandingContent>;
  control?: Maybe<CheckoutBrandingControl>;
  divider?: Maybe<CheckoutBrandingDividerStyle>;
  expressCheckout?: Maybe<CheckoutBrandingExpressCheckout>;
  favicon?: Maybe<CheckoutBrandingImage>;
  footer?: Maybe<CheckoutBrandingFooter>;
  global?: Maybe<CheckoutBrandingGlobal>;
  header?: Maybe<CheckoutBrandingHeader>;
  headingLevel1?: Maybe<CheckoutBrandingHeadingLevel>;
  headingLevel2?: Maybe<CheckoutBrandingHeadingLevel>;
  headingLevel3?: Maybe<CheckoutBrandingHeadingLevel>;
  main?: Maybe<CheckoutBrandingMain>;
  merchandiseThumbnail?: Maybe<CheckoutBrandingMerchandiseThumbnail>;
  orderSummary?: Maybe<CheckoutBrandingOrderSummary>;
  primaryButton?: Maybe<CheckoutBrandingButton>;
  secondaryButton?: Maybe<CheckoutBrandingButton>;
  select?: Maybe<CheckoutBrandingSelect>;
  textField?: Maybe<CheckoutBrandingTextField>;
};

export type CheckoutBrandingCustomizationsInput = {
  buyerJourney?: InputMaybe<CheckoutBrandingBuyerJourneyInput>;
  cartLink?: InputMaybe<CheckoutBrandingCartLinkInput>;
  checkbox?: InputMaybe<CheckoutBrandingCheckboxInput>;
  choiceList?: InputMaybe<CheckoutBrandingChoiceListInput>;
  content?: InputMaybe<CheckoutBrandingContentInput>;
  control?: InputMaybe<CheckoutBrandingControlInput>;
  divider?: InputMaybe<CheckoutBrandingDividerStyleInput>;
  expressCheckout?: InputMaybe<CheckoutBrandingExpressCheckoutInput>;
  favicon?: InputMaybe<CheckoutBrandingImageInput>;
  footer?: InputMaybe<CheckoutBrandingFooterInput>;
  global?: InputMaybe<CheckoutBrandingGlobalInput>;
  header?: InputMaybe<CheckoutBrandingHeaderInput>;
  headingLevel1?: InputMaybe<CheckoutBrandingHeadingLevelInput>;
  headingLevel2?: InputMaybe<CheckoutBrandingHeadingLevelInput>;
  headingLevel3?: InputMaybe<CheckoutBrandingHeadingLevelInput>;
  main?: InputMaybe<CheckoutBrandingMainInput>;
  merchandiseThumbnail?: InputMaybe<CheckoutBrandingMerchandiseThumbnailInput>;
  orderSummary?: InputMaybe<CheckoutBrandingOrderSummaryInput>;
  primaryButton?: InputMaybe<CheckoutBrandingButtonInput>;
  secondaryButton?: InputMaybe<CheckoutBrandingButtonInput>;
  select?: InputMaybe<CheckoutBrandingSelectInput>;
  textField?: InputMaybe<CheckoutBrandingTextFieldInput>;
};

export type CheckoutBrandingDesignSystem = {
  colors?: Maybe<CheckoutBrandingColors>;
  cornerRadius?: Maybe<CheckoutBrandingCornerRadiusVariables>;
  typography?: Maybe<CheckoutBrandingTypography>;
};

export type CheckoutBrandingDesignSystemInput = {
  colors?: InputMaybe<CheckoutBrandingColorsInput>;
  cornerRadius?: InputMaybe<CheckoutBrandingCornerRadiusVariablesInput>;
  typography?: InputMaybe<CheckoutBrandingTypographyInput>;
};

export type CheckoutBrandingDividerStyle = {
  borderStyle?: Maybe<CheckoutBrandingBorderStyle>;
  borderWidth?: Maybe<CheckoutBrandingBorderWidth>;
};

export type CheckoutBrandingDividerStyleInput = {
  borderStyle?: InputMaybe<CheckoutBrandingBorderStyle>;
  borderWidth?: InputMaybe<CheckoutBrandingBorderWidth>;
};

export type CheckoutBrandingExpressCheckout = {
  button?: Maybe<CheckoutBrandingExpressCheckoutButton>;
};

export type CheckoutBrandingExpressCheckoutButton = {
  cornerRadius?: Maybe<CheckoutBrandingCornerRadius>;
};

export type CheckoutBrandingExpressCheckoutButtonInput = {
  cornerRadius?: InputMaybe<CheckoutBrandingCornerRadius>;
};

export type CheckoutBrandingExpressCheckoutInput = {
  button?: InputMaybe<CheckoutBrandingExpressCheckoutButtonInput>;
};

export type CheckoutBrandingFont = {
  sources?: Maybe<Scalars['String']['output']>;
  weight?: Maybe<Scalars['Int']['output']>;
};

export type CheckoutBrandingFontGroup = {
  base?: Maybe<CheckoutBrandingFont>;
  bold?: Maybe<CheckoutBrandingFont>;
  loadingStrategy?: Maybe<CheckoutBrandingFontLoadingStrategy>;
  name?: Maybe<Scalars['String']['output']>;
};

export type CheckoutBrandingFontGroupInput = {
  customFontGroup?: InputMaybe<CheckoutBrandingCustomFontGroupInput>;
  shopifyFontGroup?: InputMaybe<CheckoutBrandingShopifyFontGroupInput>;
};

export const CheckoutBrandingFontLoadingStrategy = {
  Auto: 'AUTO',
  Block: 'BLOCK',
  Fallback: 'FALLBACK',
  Optional: 'OPTIONAL',
  Swap: 'SWAP'
} as const;

export type CheckoutBrandingFontLoadingStrategy = typeof CheckoutBrandingFontLoadingStrategy[keyof typeof CheckoutBrandingFontLoadingStrategy];
export type CheckoutBrandingFontSize = {
  base?: Maybe<Scalars['Float']['output']>;
  ratio?: Maybe<Scalars['Float']['output']>;
};

export type CheckoutBrandingFontSizeInput = {
  base?: InputMaybe<Scalars['Float']['input']>;
  ratio?: InputMaybe<Scalars['Float']['input']>;
};

export type CheckoutBrandingFooter = {
  alignment?: Maybe<CheckoutBrandingFooterAlignment>;
  colorScheme?: Maybe<CheckoutBrandingColorSchemeSelection>;
  content?: Maybe<CheckoutBrandingFooterContent>;
  divided?: Maybe<Scalars['Boolean']['output']>;
  padding?: Maybe<CheckoutBrandingSpacingKeyword>;
  position?: Maybe<CheckoutBrandingFooterPosition>;
};

export const CheckoutBrandingFooterAlignment = {
  Center: 'CENTER',
  End: 'END',
  Start: 'START'
} as const;

export type CheckoutBrandingFooterAlignment = typeof CheckoutBrandingFooterAlignment[keyof typeof CheckoutBrandingFooterAlignment];
export type CheckoutBrandingFooterContent = {
  visibility?: Maybe<CheckoutBrandingVisibility>;
};

export type CheckoutBrandingFooterContentInput = {
  visibility?: InputMaybe<CheckoutBrandingVisibility>;
};

export type CheckoutBrandingFooterInput = {
  alignment?: InputMaybe<CheckoutBrandingFooterAlignment>;
  colorScheme?: InputMaybe<CheckoutBrandingColorSchemeSelection>;
  content?: InputMaybe<CheckoutBrandingFooterContentInput>;
  divided?: InputMaybe<Scalars['Boolean']['input']>;
  padding?: InputMaybe<CheckoutBrandingSpacingKeyword>;
  position?: InputMaybe<CheckoutBrandingFooterPosition>;
};

export const CheckoutBrandingFooterPosition = {
  End: 'END',
  Inline: 'INLINE'
} as const;

export type CheckoutBrandingFooterPosition = typeof CheckoutBrandingFooterPosition[keyof typeof CheckoutBrandingFooterPosition];
export type CheckoutBrandingGlobal = {
  cornerRadius?: Maybe<CheckoutBrandingGlobalCornerRadius>;
  typography?: Maybe<CheckoutBrandingTypographyStyleGlobal>;
};

export const CheckoutBrandingGlobalCornerRadius = {
  None: 'NONE'
} as const;

export type CheckoutBrandingGlobalCornerRadius = typeof CheckoutBrandingGlobalCornerRadius[keyof typeof CheckoutBrandingGlobalCornerRadius];
export type CheckoutBrandingGlobalInput = {
  cornerRadius?: InputMaybe<CheckoutBrandingGlobalCornerRadius>;
  typography?: InputMaybe<CheckoutBrandingTypographyStyleGlobalInput>;
};

export type CheckoutBrandingHeader = {
  alignment?: Maybe<CheckoutBrandingHeaderAlignment>;
  banner?: Maybe<CheckoutBrandingImage>;
  cartLink?: Maybe<CheckoutBrandingHeaderCartLink>;
  colorScheme?: Maybe<CheckoutBrandingColorSchemeSelection>;
  divided?: Maybe<Scalars['Boolean']['output']>;
  logo?: Maybe<CheckoutBrandingLogo>;
  padding?: Maybe<CheckoutBrandingSpacingKeyword>;
  position?: Maybe<CheckoutBrandingHeaderPosition>;
};

export const CheckoutBrandingHeaderAlignment = {
  Center: 'CENTER',
  End: 'END',
  Start: 'START'
} as const;

export type CheckoutBrandingHeaderAlignment = typeof CheckoutBrandingHeaderAlignment[keyof typeof CheckoutBrandingHeaderAlignment];
export type CheckoutBrandingHeaderCartLink = {
  contentType?: Maybe<CheckoutBrandingCartLinkContentType>;
  image?: Maybe<Image>;
};

export type CheckoutBrandingHeaderCartLinkInput = {
  contentType?: InputMaybe<CheckoutBrandingCartLinkContentType>;
  image?: InputMaybe<CheckoutBrandingImageInput>;
};

export type CheckoutBrandingHeaderInput = {
  alignment?: InputMaybe<CheckoutBrandingHeaderAlignment>;
  banner?: InputMaybe<CheckoutBrandingImageInput>;
  cartLink?: InputMaybe<CheckoutBrandingHeaderCartLinkInput>;
  colorScheme?: InputMaybe<CheckoutBrandingColorSchemeSelection>;
  divided?: InputMaybe<Scalars['Boolean']['input']>;
  logo?: InputMaybe<CheckoutBrandingLogoInput>;
  padding?: InputMaybe<CheckoutBrandingSpacingKeyword>;
  position?: InputMaybe<CheckoutBrandingHeaderPosition>;
};

export const CheckoutBrandingHeaderPosition = {
  Inline: 'INLINE',
  InlineSecondary: 'INLINE_SECONDARY',
  Start: 'START'
} as const;

export type CheckoutBrandingHeaderPosition = typeof CheckoutBrandingHeaderPosition[keyof typeof CheckoutBrandingHeaderPosition];
export type CheckoutBrandingHeadingLevel = {
  typography?: Maybe<CheckoutBrandingTypographyStyle>;
};

export type CheckoutBrandingHeadingLevelInput = {
  typography?: InputMaybe<CheckoutBrandingTypographyStyleInput>;
};

export type CheckoutBrandingImage = {
  image?: Maybe<Image>;
};

export type CheckoutBrandingImageInput = {
  mediaImageId?: InputMaybe<Scalars['ID']['input']>;
};

export type CheckoutBrandingInput = {
  customizations?: InputMaybe<CheckoutBrandingCustomizationsInput>;
  designSystem?: InputMaybe<CheckoutBrandingDesignSystemInput>;
};

export const CheckoutBrandingLabelPosition = {
  Inside: 'INSIDE',
  Outside: 'OUTSIDE'
} as const;

export type CheckoutBrandingLabelPosition = typeof CheckoutBrandingLabelPosition[keyof typeof CheckoutBrandingLabelPosition];
export type CheckoutBrandingLogo = {
  image?: Maybe<Image>;
  maxWidth?: Maybe<Scalars['Int']['output']>;
  visibility?: Maybe<CheckoutBrandingVisibility>;
};

export type CheckoutBrandingLogoInput = {
  image?: InputMaybe<CheckoutBrandingImageInput>;
  maxWidth?: InputMaybe<Scalars['Int']['input']>;
  visibility?: InputMaybe<CheckoutBrandingVisibility>;
};

export type CheckoutBrandingMain = {
  backgroundImage?: Maybe<CheckoutBrandingImage>;
  colorScheme?: Maybe<CheckoutBrandingColorSchemeSelection>;
  divider?: Maybe<CheckoutBrandingContainerDivider>;
  section?: Maybe<CheckoutBrandingMainSection>;
};

export type CheckoutBrandingMainInput = {
  backgroundImage?: InputMaybe<CheckoutBrandingImageInput>;
  colorScheme?: InputMaybe<CheckoutBrandingColorSchemeSelection>;
  divider?: InputMaybe<CheckoutBrandingContainerDividerInput>;
  section?: InputMaybe<CheckoutBrandingMainSectionInput>;
};

export type CheckoutBrandingMainSection = {
  background?: Maybe<CheckoutBrandingBackground>;
  border?: Maybe<CheckoutBrandingSimpleBorder>;
  borderStyle?: Maybe<CheckoutBrandingBorderStyle>;
  borderWidth?: Maybe<CheckoutBrandingBorderWidth>;
  colorScheme?: Maybe<CheckoutBrandingColorSchemeSelection>;
  cornerRadius?: Maybe<CheckoutBrandingCornerRadius>;
  padding?: Maybe<CheckoutBrandingSpacingKeyword>;
  shadow?: Maybe<CheckoutBrandingShadow>;
};

export type CheckoutBrandingMainSectionInput = {
  background?: InputMaybe<CheckoutBrandingBackground>;
  border?: InputMaybe<CheckoutBrandingSimpleBorder>;
  borderStyle?: InputMaybe<CheckoutBrandingBorderStyle>;
  borderWidth?: InputMaybe<CheckoutBrandingBorderWidth>;
  colorScheme?: InputMaybe<CheckoutBrandingColorSchemeSelection>;
  cornerRadius?: InputMaybe<CheckoutBrandingCornerRadius>;
  padding?: InputMaybe<CheckoutBrandingSpacingKeyword>;
  shadow?: InputMaybe<CheckoutBrandingShadow>;
};

export type CheckoutBrandingMerchandiseThumbnail = {
  badge?: Maybe<CheckoutBrandingMerchandiseThumbnailBadge>;
  border?: Maybe<CheckoutBrandingSimpleBorder>;
  cornerRadius?: Maybe<CheckoutBrandingCornerRadius>;
  fit?: Maybe<CheckoutBrandingObjectFit>;
};

export type CheckoutBrandingMerchandiseThumbnailBadge = {
  background?: Maybe<CheckoutBrandingMerchandiseThumbnailBadgeBackground>;
};

export const CheckoutBrandingMerchandiseThumbnailBadgeBackground = {
  Accent: 'ACCENT',
  Base: 'BASE'
} as const;

export type CheckoutBrandingMerchandiseThumbnailBadgeBackground = typeof CheckoutBrandingMerchandiseThumbnailBadgeBackground[keyof typeof CheckoutBrandingMerchandiseThumbnailBadgeBackground];
export type CheckoutBrandingMerchandiseThumbnailBadgeInput = {
  background?: InputMaybe<CheckoutBrandingMerchandiseThumbnailBadgeBackground>;
};

export type CheckoutBrandingMerchandiseThumbnailInput = {
  badge?: InputMaybe<CheckoutBrandingMerchandiseThumbnailBadgeInput>;
  border?: InputMaybe<CheckoutBrandingSimpleBorder>;
  cornerRadius?: InputMaybe<CheckoutBrandingCornerRadius>;
  fit?: InputMaybe<CheckoutBrandingObjectFit>;
};

export const CheckoutBrandingObjectFit = {
  Contain: 'CONTAIN',
  Cover: 'COVER'
} as const;

export type CheckoutBrandingObjectFit = typeof CheckoutBrandingObjectFit[keyof typeof CheckoutBrandingObjectFit];
export type CheckoutBrandingOrderSummary = {
  backgroundImage?: Maybe<CheckoutBrandingImage>;
  colorScheme?: Maybe<CheckoutBrandingColorSchemeSelection>;
  divider?: Maybe<CheckoutBrandingContainerDivider>;
  section?: Maybe<CheckoutBrandingOrderSummarySection>;
};

export type CheckoutBrandingOrderSummaryInput = {
  backgroundImage?: InputMaybe<CheckoutBrandingImageInput>;
  colorScheme?: InputMaybe<CheckoutBrandingColorSchemeSelection>;
  divider?: InputMaybe<CheckoutBrandingContainerDividerInput>;
  section?: InputMaybe<CheckoutBrandingOrderSummarySectionInput>;
};

export type CheckoutBrandingOrderSummarySection = {
  background?: Maybe<CheckoutBrandingBackground>;
  border?: Maybe<CheckoutBrandingSimpleBorder>;
  borderStyle?: Maybe<CheckoutBrandingBorderStyle>;
  borderWidth?: Maybe<CheckoutBrandingBorderWidth>;
  colorScheme?: Maybe<CheckoutBrandingColorSchemeSelection>;
  cornerRadius?: Maybe<CheckoutBrandingCornerRadius>;
  padding?: Maybe<CheckoutBrandingSpacingKeyword>;
  shadow?: Maybe<CheckoutBrandingShadow>;
};

export type CheckoutBrandingOrderSummarySectionInput = {
  background?: InputMaybe<CheckoutBrandingBackground>;
  border?: InputMaybe<CheckoutBrandingSimpleBorder>;
  borderStyle?: InputMaybe<CheckoutBrandingBorderStyle>;
  borderWidth?: InputMaybe<CheckoutBrandingBorderWidth>;
  colorScheme?: InputMaybe<CheckoutBrandingColorSchemeSelection>;
  cornerRadius?: InputMaybe<CheckoutBrandingCornerRadius>;
  padding?: InputMaybe<CheckoutBrandingSpacingKeyword>;
  shadow?: InputMaybe<CheckoutBrandingShadow>;
};

export type CheckoutBrandingSelect = {
  border?: Maybe<CheckoutBrandingBorder>;
  typography?: Maybe<CheckoutBrandingTypographyStyle>;
};

export type CheckoutBrandingSelectInput = {
  border?: InputMaybe<CheckoutBrandingBorder>;
  typography?: InputMaybe<CheckoutBrandingTypographyStyleInput>;
};

export const CheckoutBrandingShadow = {
  Base: 'BASE',
  Large_100: 'LARGE_100',
  Large_200: 'LARGE_200',
  Small_100: 'SMALL_100',
  Small_200: 'SMALL_200'
} as const;

export type CheckoutBrandingShadow = typeof CheckoutBrandingShadow[keyof typeof CheckoutBrandingShadow];
export type CheckoutBrandingShopifyFont = CheckoutBrandingFont & {
  sources?: Maybe<Scalars['String']['output']>;
  weight?: Maybe<Scalars['Int']['output']>;
};

export type CheckoutBrandingShopifyFontGroupInput = {
  baseWeight?: InputMaybe<Scalars['Int']['input']>;
  boldWeight?: InputMaybe<Scalars['Int']['input']>;
  loadingStrategy?: InputMaybe<CheckoutBrandingFontLoadingStrategy>;
  name: Scalars['String']['input'];
};

export const CheckoutBrandingSimpleBorder = {
  Full: 'FULL',
  None: 'NONE'
} as const;

export type CheckoutBrandingSimpleBorder = typeof CheckoutBrandingSimpleBorder[keyof typeof CheckoutBrandingSimpleBorder];
export const CheckoutBrandingSpacing = {
  Base: 'BASE',
  ExtraLoose: 'EXTRA_LOOSE',
  ExtraTight: 'EXTRA_TIGHT',
  Loose: 'LOOSE',
  None: 'NONE',
  Tight: 'TIGHT'
} as const;

export type CheckoutBrandingSpacing = typeof CheckoutBrandingSpacing[keyof typeof CheckoutBrandingSpacing];
export const CheckoutBrandingSpacingKeyword = {
  Base: 'BASE',
  Large: 'LARGE',
  Large_100: 'LARGE_100',
  Large_200: 'LARGE_200',
  Large_300: 'LARGE_300',
  Large_400: 'LARGE_400',
  Large_500: 'LARGE_500',
  None: 'NONE',
  Small: 'SMALL',
  Small_100: 'SMALL_100',
  Small_200: 'SMALL_200',
  Small_300: 'SMALL_300',
  Small_400: 'SMALL_400',
  Small_500: 'SMALL_500'
} as const;

export type CheckoutBrandingSpacingKeyword = typeof CheckoutBrandingSpacingKeyword[keyof typeof CheckoutBrandingSpacingKeyword];
export type CheckoutBrandingTextField = {
  border?: Maybe<CheckoutBrandingBorder>;
  typography?: Maybe<CheckoutBrandingTypographyStyle>;
};

export type CheckoutBrandingTextFieldInput = {
  border?: InputMaybe<CheckoutBrandingBorder>;
  typography?: InputMaybe<CheckoutBrandingTypographyStyleInput>;
};

export type CheckoutBrandingTypography = {
  primary?: Maybe<CheckoutBrandingFontGroup>;
  secondary?: Maybe<CheckoutBrandingFontGroup>;
  size?: Maybe<CheckoutBrandingFontSize>;
};

export const CheckoutBrandingTypographyFont = {
  Primary: 'PRIMARY',
  Secondary: 'SECONDARY'
} as const;

export type CheckoutBrandingTypographyFont = typeof CheckoutBrandingTypographyFont[keyof typeof CheckoutBrandingTypographyFont];
export type CheckoutBrandingTypographyInput = {
  primary?: InputMaybe<CheckoutBrandingFontGroupInput>;
  secondary?: InputMaybe<CheckoutBrandingFontGroupInput>;
  size?: InputMaybe<CheckoutBrandingFontSizeInput>;
};

export const CheckoutBrandingTypographyKerning = {
  Base: 'BASE',
  ExtraLoose: 'EXTRA_LOOSE',
  Loose: 'LOOSE'
} as const;

export type CheckoutBrandingTypographyKerning = typeof CheckoutBrandingTypographyKerning[keyof typeof CheckoutBrandingTypographyKerning];
export const CheckoutBrandingTypographyLetterCase = {
  Lower: 'LOWER',
  None: 'NONE',
  Title: 'TITLE',
  Upper: 'UPPER'
} as const;

export type CheckoutBrandingTypographyLetterCase = typeof CheckoutBrandingTypographyLetterCase[keyof typeof CheckoutBrandingTypographyLetterCase];
export const CheckoutBrandingTypographySize = {
  Base: 'BASE',
  ExtraExtraLarge: 'EXTRA_EXTRA_LARGE',
  ExtraLarge: 'EXTRA_LARGE',
  ExtraSmall: 'EXTRA_SMALL',
  Large: 'LARGE',
  Medium: 'MEDIUM',
  Small: 'SMALL'
} as const;

export type CheckoutBrandingTypographySize = typeof CheckoutBrandingTypographySize[keyof typeof CheckoutBrandingTypographySize];
export type CheckoutBrandingTypographyStyle = {
  font?: Maybe<CheckoutBrandingTypographyFont>;
  kerning?: Maybe<CheckoutBrandingTypographyKerning>;
  letterCase?: Maybe<CheckoutBrandingTypographyLetterCase>;
  size?: Maybe<CheckoutBrandingTypographySize>;
  weight?: Maybe<CheckoutBrandingTypographyWeight>;
};

export type CheckoutBrandingTypographyStyleGlobal = {
  kerning?: Maybe<CheckoutBrandingTypographyKerning>;
  letterCase?: Maybe<CheckoutBrandingTypographyLetterCase>;
};

export type CheckoutBrandingTypographyStyleGlobalInput = {
  kerning?: InputMaybe<CheckoutBrandingTypographyKerning>;
  letterCase?: InputMaybe<CheckoutBrandingTypographyLetterCase>;
};

export type CheckoutBrandingTypographyStyleInput = {
  font?: InputMaybe<CheckoutBrandingTypographyFont>;
  kerning?: InputMaybe<CheckoutBrandingTypographyKerning>;
  letterCase?: InputMaybe<CheckoutBrandingTypographyLetterCase>;
  size?: InputMaybe<CheckoutBrandingTypographySize>;
  weight?: InputMaybe<CheckoutBrandingTypographyWeight>;
};

export const CheckoutBrandingTypographyWeight = {
  Base: 'BASE',
  Bold: 'BOLD'
} as const;

export type CheckoutBrandingTypographyWeight = typeof CheckoutBrandingTypographyWeight[keyof typeof CheckoutBrandingTypographyWeight];
export type CheckoutBrandingUpsertPayload = {
  checkoutBranding?: Maybe<CheckoutBranding>;
  userErrors: Array<CheckoutBrandingUpsertUserError>;
};

export type CheckoutBrandingUpsertUserError = DisplayableError & {
  code?: Maybe<CheckoutBrandingUpsertUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CheckoutBrandingUpsertUserErrorCode = {
  InternalError: 'INTERNAL_ERROR'
} as const;

export type CheckoutBrandingUpsertUserErrorCode = typeof CheckoutBrandingUpsertUserErrorCode[keyof typeof CheckoutBrandingUpsertUserErrorCode];
export const CheckoutBrandingVisibility = {
  Hidden: 'HIDDEN',
  Visible: 'VISIBLE'
} as const;

export type CheckoutBrandingVisibility = typeof CheckoutBrandingVisibility[keyof typeof CheckoutBrandingVisibility];
export type CheckoutProfile = Node & {
  createdAt: Scalars['DateTime']['output'];
  editedAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  isPublished: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  typOspPagesActive: Scalars['Boolean']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type CheckoutProfileConnection = {
  edges: Array<CheckoutProfileEdge>;
  nodes: Array<CheckoutProfile>;
  pageInfo: PageInfo;
};

export type CheckoutProfileEdge = {
  cursor: Scalars['String']['output'];
  node: CheckoutProfile;
};

export const CheckoutProfileSortKeys = {
  CreatedAt: 'CREATED_AT',
  EditedAt: 'EDITED_AT',
  Id: 'ID',
  IsPublished: 'IS_PUBLISHED',
  Relevance: 'RELEVANCE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type CheckoutProfileSortKeys = typeof CheckoutProfileSortKeys[keyof typeof CheckoutProfileSortKeys];
export type ChildProductRelationInput = {
  childProductId: Scalars['ID']['input'];
  selectedParentOptionValues: Array<SelectedVariantOptionInput>;
};

export const CodeDiscountSortKeys = {
  CreatedAt: 'CREATED_AT',
  EndsAt: 'ENDS_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE',
  StartsAt: 'STARTS_AT',
  Title: 'TITLE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type CodeDiscountSortKeys = typeof CodeDiscountSortKeys[keyof typeof CodeDiscountSortKeys];
export type Collection = HasEvents & HasMetafieldDefinitions & HasMetafields & HasPublishedTranslations & Node & Publishable & {
  availablePublicationsCount?: Maybe<Count>;
  description: Scalars['String']['output'];
  descriptionHtml: Scalars['HTML']['output'];
  events: EventConnection;
  feedback?: Maybe<ResourceFeedback>;
  handle: Scalars['String']['output'];
  hasProduct: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  image?: Maybe<Image>;
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  products: ProductConnection;
  productsCount?: Maybe<Count>;
  /** @deprecated Use `resourcePublicationsCount` instead. */
  publicationCount: Scalars['Int']['output'];
  /** @deprecated Use `resourcePublications` instead. */
  publications: CollectionPublicationConnection;
  /** @deprecated Use `publishedOnPublication` instead. */
  publishedOnChannel: Scalars['Boolean']['output'];
  /** @deprecated Use `publishedOnCurrentPublication` instead. */
  publishedOnCurrentChannel: Scalars['Boolean']['output'];
  publishedOnCurrentPublication: Scalars['Boolean']['output'];
  publishedOnPublication: Scalars['Boolean']['output'];
  resourcePublications: ResourcePublicationConnection;
  resourcePublicationsCount?: Maybe<Count>;
  resourcePublicationsV2: ResourcePublicationV2Connection;
  ruleSet?: Maybe<CollectionRuleSet>;
  seo: Seo;
  sortOrder: CollectionSortOrder;
  /** @deprecated Use `id` instead. */
  storefrontId: Scalars['StorefrontID']['output'];
  templateSuffix?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  translations: Array<Translation>;
  /** @deprecated Use `unpublishedPublications` instead. */
  unpublishedChannels: ChannelConnection;
  unpublishedPublications: PublicationConnection;
  updatedAt: Scalars['DateTime']['output'];
};


export type CollectionDescriptionArgs = {
  truncateAt?: InputMaybe<Scalars['Int']['input']>;
};


export type CollectionEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type CollectionHasProductArgs = {
  id: Scalars['ID']['input'];
};


export type CollectionMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type CollectionMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type CollectionMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CollectionProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<ProductCollectionSortKeys>;
};


export type CollectionPublicationCountArgs = {
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CollectionPublicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CollectionPublishedOnChannelArgs = {
  channelId: Scalars['ID']['input'];
};


export type CollectionPublishedOnPublicationArgs = {
  publicationId: Scalars['ID']['input'];
};


export type CollectionResourcePublicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CollectionResourcePublicationsCountArgs = {
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CollectionResourcePublicationsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  catalogType?: InputMaybe<CatalogType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CollectionTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};


export type CollectionUnpublishedChannelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CollectionUnpublishedPublicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CollectionAddProductsPayload = {
  collection?: Maybe<Collection>;
  userErrors: Array<UserError>;
};

export type CollectionAddProductsV2Payload = {
  job?: Maybe<Job>;
  userErrors: Array<CollectionAddProductsV2UserError>;
};

export type CollectionAddProductsV2UserError = DisplayableError & {
  code?: Maybe<CollectionAddProductsV2UserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CollectionAddProductsV2UserErrorCode = {
  CantAddToSmartCollection: 'CANT_ADD_TO_SMART_COLLECTION',
  CollectionDoesNotExist: 'COLLECTION_DOES_NOT_EXIST'
} as const;

export type CollectionAddProductsV2UserErrorCode = typeof CollectionAddProductsV2UserErrorCode[keyof typeof CollectionAddProductsV2UserErrorCode];
export type CollectionConnection = {
  edges: Array<CollectionEdge>;
  nodes: Array<Collection>;
  pageInfo: PageInfo;
};

export type CollectionCreatePayload = {
  collection?: Maybe<Collection>;
  userErrors: Array<UserError>;
};

export type CollectionDeleteInput = {
  id: Scalars['ID']['input'];
};

export type CollectionDeletePayload = {
  deletedCollectionId?: Maybe<Scalars['ID']['output']>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type CollectionEdge = {
  cursor: Scalars['String']['output'];
  node: Collection;
};

export type CollectionInput = {
  descriptionHtml?: InputMaybe<Scalars['String']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  image?: InputMaybe<ImageInput>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  products?: InputMaybe<Array<Scalars['ID']['input']>>;
  redirectNewHandle?: InputMaybe<Scalars['Boolean']['input']>;
  ruleSet?: InputMaybe<CollectionRuleSetInput>;
  seo?: InputMaybe<SeoInput>;
  sortOrder?: InputMaybe<CollectionSortOrder>;
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type CollectionPublication = {
  /** @deprecated Use `publication` instead. */
  channel: Channel;
  collection: Collection;
  isPublished: Scalars['Boolean']['output'];
  publication: Publication;
  publishDate: Scalars['DateTime']['output'];
};

export type CollectionPublicationConnection = {
  edges: Array<CollectionPublicationEdge>;
  nodes: Array<CollectionPublication>;
  pageInfo: PageInfo;
};

export type CollectionPublicationEdge = {
  cursor: Scalars['String']['output'];
  node: CollectionPublication;
};

export type CollectionPublicationInput = {
  publicationId?: InputMaybe<Scalars['ID']['input']>;
};

export type CollectionPublishInput = {
  collectionPublications: Array<CollectionPublicationInput>;
  id: Scalars['ID']['input'];
};

export type CollectionPublishPayload = {
  collection?: Maybe<Collection>;
  collectionPublications?: Maybe<Array<CollectionPublication>>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type CollectionRemoveProductsPayload = {
  job?: Maybe<Job>;
  userErrors: Array<UserError>;
};

export type CollectionReorderProductsPayload = {
  job?: Maybe<Job>;
  userErrors: Array<UserError>;
};

export type CollectionRule = {
  column: CollectionRuleColumn;
  condition: Scalars['String']['output'];
  conditionObject?: Maybe<CollectionRuleConditionObject>;
  relation: CollectionRuleRelation;
};

export type CollectionRuleCategoryCondition = {
  value: TaxonomyCategory;
};

export const CollectionRuleColumn = {
  IsPriceReduced: 'IS_PRICE_REDUCED',
  ProductCategoryId: 'PRODUCT_CATEGORY_ID',
  ProductMetafieldDefinition: 'PRODUCT_METAFIELD_DEFINITION',
  ProductTaxonomyNodeId: 'PRODUCT_TAXONOMY_NODE_ID',
  Tag: 'TAG',
  Title: 'TITLE',
  Type: 'TYPE',
  VariantCompareAtPrice: 'VARIANT_COMPARE_AT_PRICE',
  VariantInventory: 'VARIANT_INVENTORY',
  VariantMetafieldDefinition: 'VARIANT_METAFIELD_DEFINITION',
  VariantPrice: 'VARIANT_PRICE',
  VariantTitle: 'VARIANT_TITLE',
  VariantWeight: 'VARIANT_WEIGHT',
  Vendor: 'VENDOR'
} as const;

export type CollectionRuleColumn = typeof CollectionRuleColumn[keyof typeof CollectionRuleColumn];
export type CollectionRuleConditionObject = CollectionRuleCategoryCondition | CollectionRuleMetafieldCondition | CollectionRuleProductCategoryCondition | CollectionRuleTextCondition;

export type CollectionRuleConditions = {
  allowedRelations: Array<CollectionRuleRelation>;
  defaultRelation: CollectionRuleRelation;
  ruleObject?: Maybe<CollectionRuleConditionsRuleObject>;
  ruleType: CollectionRuleColumn;
};

export type CollectionRuleConditionsRuleObject = CollectionRuleMetafieldCondition;

export type CollectionRuleInput = {
  column: CollectionRuleColumn;
  condition: Scalars['String']['input'];
  conditionObjectId?: InputMaybe<Scalars['ID']['input']>;
  relation: CollectionRuleRelation;
};

export type CollectionRuleMetafieldCondition = {
  metafieldDefinition: MetafieldDefinition;
};

export type CollectionRuleProductCategoryCondition = {
  value: ProductTaxonomyNode;
};

export const CollectionRuleRelation = {
  Contains: 'CONTAINS',
  EndsWith: 'ENDS_WITH',
  Equals: 'EQUALS',
  GreaterThan: 'GREATER_THAN',
  IsNotSet: 'IS_NOT_SET',
  IsSet: 'IS_SET',
  LessThan: 'LESS_THAN',
  NotContains: 'NOT_CONTAINS',
  NotEquals: 'NOT_EQUALS',
  StartsWith: 'STARTS_WITH'
} as const;

export type CollectionRuleRelation = typeof CollectionRuleRelation[keyof typeof CollectionRuleRelation];
export type CollectionRuleSet = {
  appliedDisjunctively: Scalars['Boolean']['output'];
  rules: Array<CollectionRule>;
};

export type CollectionRuleSetInput = {
  appliedDisjunctively: Scalars['Boolean']['input'];
  rules?: InputMaybe<Array<CollectionRuleInput>>;
};

export type CollectionRuleTextCondition = {
  value: Scalars['String']['output'];
};

export const CollectionSortKeys = {
  Id: 'ID',
  Relevance: 'RELEVANCE',
  Title: 'TITLE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type CollectionSortKeys = typeof CollectionSortKeys[keyof typeof CollectionSortKeys];
export const CollectionSortOrder = {
  AlphaAsc: 'ALPHA_ASC',
  AlphaDesc: 'ALPHA_DESC',
  BestSelling: 'BEST_SELLING',
  Created: 'CREATED',
  CreatedDesc: 'CREATED_DESC',
  Manual: 'MANUAL',
  PriceAsc: 'PRICE_ASC',
  PriceDesc: 'PRICE_DESC'
} as const;

export type CollectionSortOrder = typeof CollectionSortOrder[keyof typeof CollectionSortOrder];
export type CollectionUnpublishInput = {
  collectionPublications: Array<CollectionPublicationInput>;
  id: Scalars['ID']['input'];
};

export type CollectionUnpublishPayload = {
  collection?: Maybe<Collection>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type CollectionUpdatePayload = {
  collection?: Maybe<Collection>;
  job?: Maybe<Job>;
  userErrors: Array<UserError>;
};

export type CombinedListing = {
  combinedListingChildren: CombinedListingChildConnection;
  parentProduct: Product;
};


export type CombinedListingCombinedListingChildrenArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CombinedListingChild = {
  parentVariant: ProductVariant;
  product: Product;
};

export type CombinedListingChildConnection = {
  edges: Array<CombinedListingChildEdge>;
  nodes: Array<CombinedListingChild>;
  pageInfo: PageInfo;
};

export type CombinedListingChildEdge = {
  cursor: Scalars['String']['output'];
  node: CombinedListingChild;
};

export type CombinedListingUpdatePayload = {
  product?: Maybe<Product>;
  userErrors: Array<CombinedListingUpdateUserError>;
};

export type CombinedListingUpdateUserError = DisplayableError & {
  code?: Maybe<CombinedListingUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CombinedListingUpdateUserErrorCode = {
  CannotHaveDuplicatedProducts: 'CANNOT_HAVE_DUPLICATED_PRODUCTS',
  CannotHaveParentAsChild: 'CANNOT_HAVE_PARENT_AS_CHILD',
  CannotHaveRepeatedOptions: 'CANNOT_HAVE_REPEATED_OPTIONS',
  CannotHaveRepeatedOptionValues: 'CANNOT_HAVE_REPEATED_OPTION_VALUES',
  CantAddOptionsValuesIfAlreadyExists: 'CANT_ADD_OPTIONS_VALUES_IF_ALREADY_EXISTS',
  CombinedListingsNotEnabled: 'COMBINED_LISTINGS_NOT_ENABLED',
  EditAndRemoveOnSameProducts: 'EDIT_AND_REMOVE_ON_SAME_PRODUCTS',
  FailedToAddProducts: 'FAILED_TO_ADD_PRODUCTS',
  FailedToRemoveProducts: 'FAILED_TO_REMOVE_PRODUCTS',
  FailedToUpdateProducts: 'FAILED_TO_UPDATE_PRODUCTS',
  LinkedMetafieldsCannotBeRepeated: 'LINKED_METAFIELDS_CANNOT_BE_REPEATED',
  LinkedMetafieldCannotBeChanged: 'LINKED_METAFIELD_CANNOT_BE_CHANGED',
  LinkedMetafieldValueMissing: 'LINKED_METAFIELD_VALUE_MISSING',
  LinkedOptionsNotSupportedForShop: 'LINKED_OPTIONS_NOT_SUPPORTED_FOR_SHOP',
  MissingOptionValues: 'MISSING_OPTION_VALUES',
  MustHaveSelectedOptionValues: 'MUST_HAVE_SELECTED_OPTION_VALUES',
  OptionsMustBeEqualToTheOtherComponents: 'OPTIONS_MUST_BE_EQUAL_TO_THE_OTHER_COMPONENTS',
  OptionNameCannotBeBlank: 'OPTION_NAME_CANNOT_BE_BLANK',
  OptionNotFound: 'OPTION_NOT_FOUND',
  OptionValuesCannotBeBlank: 'OPTION_VALUES_CANNOT_BE_BLANK',
  OptionValuesCannotBeEmpty: 'OPTION_VALUES_CANNOT_BE_EMPTY',
  ParentProductMustBeACombinedListing: 'PARENT_PRODUCT_MUST_BE_A_COMBINED_LISTING',
  ProductIsAlreadyAChild: 'PRODUCT_IS_ALREADY_A_CHILD',
  ProductMembershipNotFound: 'PRODUCT_MEMBERSHIP_NOT_FOUND',
  ProductNotFound: 'PRODUCT_NOT_FOUND',
  TitleTooLong: 'TITLE_TOO_LONG',
  TooManyProducts: 'TOO_MANY_PRODUCTS',
  TooManyVariants: 'TOO_MANY_VARIANTS',
  UnexpectedError: 'UNEXPECTED_ERROR'
} as const;

export type CombinedListingUpdateUserErrorCode = typeof CombinedListingUpdateUserErrorCode[keyof typeof CombinedListingUpdateUserErrorCode];
export const CombinedListingsRole = {
  Child: 'CHILD',
  Parent: 'PARENT'
} as const;

export type CombinedListingsRole = typeof CombinedListingsRole[keyof typeof CombinedListingsRole];
export type Comment = HasEvents & Node & {
  article?: Maybe<Article>;
  author: CommentAuthor;
  body: Scalars['String']['output'];
  bodyHtml: Scalars['HTML']['output'];
  createdAt: Scalars['DateTime']['output'];
  events: EventConnection;
  id: Scalars['ID']['output'];
  ip?: Maybe<Scalars['String']['output']>;
  isPublished: Scalars['Boolean']['output'];
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  status: CommentStatus;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  userAgent?: Maybe<Scalars['String']['output']>;
};


export type CommentEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};

export type CommentApprovePayload = {
  comment?: Maybe<Comment>;
  userErrors: Array<CommentApproveUserError>;
};

export type CommentApproveUserError = DisplayableError & {
  code?: Maybe<CommentApproveUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CommentApproveUserErrorCode = {
  NotFound: 'NOT_FOUND'
} as const;

export type CommentApproveUserErrorCode = typeof CommentApproveUserErrorCode[keyof typeof CommentApproveUserErrorCode];
export type CommentAuthor = {
  email: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export type CommentConnection = {
  edges: Array<CommentEdge>;
  nodes: Array<Comment>;
  pageInfo: PageInfo;
};

export type CommentDeletePayload = {
  deletedCommentId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<CommentDeleteUserError>;
};

export type CommentDeleteUserError = DisplayableError & {
  code?: Maybe<CommentDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CommentDeleteUserErrorCode = {
  NotFound: 'NOT_FOUND'
} as const;

export type CommentDeleteUserErrorCode = typeof CommentDeleteUserErrorCode[keyof typeof CommentDeleteUserErrorCode];
export type CommentEdge = {
  cursor: Scalars['String']['output'];
  node: Comment;
};

export type CommentEvent = Event & Node & {
  action: Scalars['String']['output'];
  appTitle?: Maybe<Scalars['String']['output']>;
  attachments: Array<CommentEventAttachment>;
  attributeToApp: Scalars['Boolean']['output'];
  attributeToUser: Scalars['Boolean']['output'];
  author: StaffMember;
  canDelete: Scalars['Boolean']['output'];
  canEdit: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  criticalAlert: Scalars['Boolean']['output'];
  edited: Scalars['Boolean']['output'];
  embed?: Maybe<CommentEventEmbed>;
  id: Scalars['ID']['output'];
  message: Scalars['FormattedString']['output'];
  rawMessage: Scalars['String']['output'];
  subject?: Maybe<CommentEventSubject>;
};

export type CommentEventAttachment = {
  fileExtension?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  image?: Maybe<Image>;
  name: Scalars['String']['output'];
  size: Scalars['Int']['output'];
  url: Scalars['URL']['output'];
};

export type CommentEventEmbed = Customer | DraftOrder | Order | Product | ProductVariant;

export type CommentEventSubject = {
  hasTimelineComment: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
};

export type CommentNotSpamPayload = {
  comment?: Maybe<Comment>;
  userErrors: Array<CommentNotSpamUserError>;
};

export type CommentNotSpamUserError = DisplayableError & {
  code?: Maybe<CommentNotSpamUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CommentNotSpamUserErrorCode = {
  NotFound: 'NOT_FOUND'
} as const;

export type CommentNotSpamUserErrorCode = typeof CommentNotSpamUserErrorCode[keyof typeof CommentNotSpamUserErrorCode];
export const CommentPolicy = {
  AutoPublished: 'AUTO_PUBLISHED',
  Closed: 'CLOSED',
  Moderated: 'MODERATED'
} as const;

export type CommentPolicy = typeof CommentPolicy[keyof typeof CommentPolicy];
export const CommentSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type CommentSortKeys = typeof CommentSortKeys[keyof typeof CommentSortKeys];
export type CommentSpamPayload = {
  comment?: Maybe<Comment>;
  userErrors: Array<CommentSpamUserError>;
};

export type CommentSpamUserError = DisplayableError & {
  code?: Maybe<CommentSpamUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CommentSpamUserErrorCode = {
  NotFound: 'NOT_FOUND'
} as const;

export type CommentSpamUserErrorCode = typeof CommentSpamUserErrorCode[keyof typeof CommentSpamUserErrorCode];
export const CommentStatus = {
  Pending: 'PENDING',
  Published: 'PUBLISHED',
  Removed: 'REMOVED',
  Spam: 'SPAM',
  Unapproved: 'UNAPPROVED'
} as const;

export type CommentStatus = typeof CommentStatus[keyof typeof CommentStatus];
export type CompaniesDeletePayload = {
  deletedCompanyIds?: Maybe<Array<Scalars['ID']['output']>>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type Company = CommentEventSubject & HasEvents & HasMetafieldDefinitions & HasMetafields & Navigable & Node & {
  /** @deprecated Use `contactsCount` instead. */
  contactCount: Scalars['Int']['output'];
  contactRoles: CompanyContactRoleConnection;
  contacts: CompanyContactConnection;
  contactsCount?: Maybe<Count>;
  createdAt: Scalars['DateTime']['output'];
  customerSince: Scalars['DateTime']['output'];
  defaultCursor: Scalars['String']['output'];
  defaultRole?: Maybe<CompanyContactRole>;
  draftOrders: DraftOrderConnection;
  events: EventConnection;
  externalId?: Maybe<Scalars['String']['output']>;
  hasTimelineComment: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  lifetimeDuration: Scalars['String']['output'];
  locations: CompanyLocationConnection;
  locationsCount?: Maybe<Count>;
  mainContact?: Maybe<CompanyContact>;
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  name: Scalars['String']['output'];
  note?: Maybe<Scalars['String']['output']>;
  orders: OrderConnection;
  ordersCount?: Maybe<Count>;
  totalSpent: MoneyV2;
  updatedAt: Scalars['DateTime']['output'];
};


export type CompanyContactRolesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CompanyContactRoleSortKeys>;
};


export type CompanyContactsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CompanyContactSortKeys>;
};


export type CompanyDraftOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<DraftOrderSortKeys>;
};


export type CompanyEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type CompanyLocationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CompanyLocationSortKeys>;
};


export type CompanyMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type CompanyMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type CompanyMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CompanyOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<OrderSortKeys>;
};

export type CompanyAddress = Node & {
  address1: Scalars['String']['output'];
  address2?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  companyName: Scalars['String']['output'];
  country?: Maybe<Scalars['String']['output']>;
  countryCode: CountryCode;
  createdAt: Scalars['DateTime']['output'];
  firstName?: Maybe<Scalars['String']['output']>;
  formattedAddress: Array<Scalars['String']['output']>;
  formattedArea?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  recipient?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  zip?: Maybe<Scalars['String']['output']>;
  zoneCode?: Maybe<Scalars['String']['output']>;
};


export type CompanyAddressFormattedAddressArgs = {
  withCompanyName?: InputMaybe<Scalars['Boolean']['input']>;
  withName?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CompanyAddressDeletePayload = {
  deletedAddressId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyAddressInput = {
  address1?: InputMaybe<Scalars['String']['input']>;
  address2?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  countryCode?: InputMaybe<CountryCode>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  recipient?: InputMaybe<Scalars['String']['input']>;
  zip?: InputMaybe<Scalars['String']['input']>;
  zoneCode?: InputMaybe<Scalars['String']['input']>;
};

export const CompanyAddressType = {
  Billing: 'BILLING',
  Shipping: 'SHIPPING'
} as const;

export type CompanyAddressType = typeof CompanyAddressType[keyof typeof CompanyAddressType];
export type CompanyAssignCustomerAsContactPayload = {
  companyContact?: Maybe<CompanyContact>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyAssignMainContactPayload = {
  company?: Maybe<Company>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyConnection = {
  edges: Array<CompanyEdge>;
  nodes: Array<Company>;
  pageInfo: PageInfo;
};

export type CompanyContact = Node & {
  company: Company;
  createdAt: Scalars['DateTime']['output'];
  customer: Customer;
  draftOrders: DraftOrderConnection;
  id: Scalars['ID']['output'];
  isMainContact: Scalars['Boolean']['output'];
  lifetimeDuration: Scalars['String']['output'];
  locale?: Maybe<Scalars['String']['output']>;
  orders: OrderConnection;
  roleAssignments: CompanyContactRoleAssignmentConnection;
  title?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};


export type CompanyContactDraftOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<DraftOrderSortKeys>;
};


export type CompanyContactOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<OrderSortKeys>;
};


export type CompanyContactRoleAssignmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CompanyContactRoleAssignmentSortKeys>;
};

export type CompanyContactAssignRolePayload = {
  companyContactRoleAssignment?: Maybe<CompanyContactRoleAssignment>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyContactAssignRolesPayload = {
  roleAssignments?: Maybe<Array<CompanyContactRoleAssignment>>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyContactConnection = {
  edges: Array<CompanyContactEdge>;
  nodes: Array<CompanyContact>;
  pageInfo: PageInfo;
};

export type CompanyContactCreatePayload = {
  companyContact?: Maybe<CompanyContact>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyContactDeletePayload = {
  deletedCompanyContactId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyContactEdge = {
  cursor: Scalars['String']['output'];
  node: CompanyContact;
};

export type CompanyContactInput = {
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type CompanyContactRemoveFromCompanyPayload = {
  removedCompanyContactId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyContactRevokeRolePayload = {
  revokedCompanyContactRoleAssignmentId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyContactRevokeRolesPayload = {
  revokedRoleAssignmentIds?: Maybe<Array<Scalars['ID']['output']>>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyContactRole = Node & {
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  note?: Maybe<Scalars['String']['output']>;
};

export type CompanyContactRoleAssign = {
  companyContactRoleId: Scalars['ID']['input'];
  companyLocationId: Scalars['ID']['input'];
};

export type CompanyContactRoleAssignment = Node & {
  company: Company;
  companyContact: CompanyContact;
  companyLocation: CompanyLocation;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  role: CompanyContactRole;
  updatedAt: Scalars['DateTime']['output'];
};

export type CompanyContactRoleAssignmentConnection = {
  edges: Array<CompanyContactRoleAssignmentEdge>;
  nodes: Array<CompanyContactRoleAssignment>;
  pageInfo: PageInfo;
};

export type CompanyContactRoleAssignmentEdge = {
  cursor: Scalars['String']['output'];
  node: CompanyContactRoleAssignment;
};

export const CompanyContactRoleAssignmentSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  LocationName: 'LOCATION_NAME',
  Relevance: 'RELEVANCE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type CompanyContactRoleAssignmentSortKeys = typeof CompanyContactRoleAssignmentSortKeys[keyof typeof CompanyContactRoleAssignmentSortKeys];
export type CompanyContactRoleConnection = {
  edges: Array<CompanyContactRoleEdge>;
  nodes: Array<CompanyContactRole>;
  pageInfo: PageInfo;
};

export type CompanyContactRoleEdge = {
  cursor: Scalars['String']['output'];
  node: CompanyContactRole;
};

export const CompanyContactRoleSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type CompanyContactRoleSortKeys = typeof CompanyContactRoleSortKeys[keyof typeof CompanyContactRoleSortKeys];
export type CompanyContactSendWelcomeEmailPayload = {
  companyContact?: Maybe<CompanyContact>;
  userErrors: Array<BusinessCustomerUserError>;
};

export const CompanyContactSortKeys = {
  CompanyId: 'COMPANY_ID',
  CreatedAt: 'CREATED_AT',
  Email: 'EMAIL',
  Id: 'ID',
  Name: 'NAME',
  NameEmail: 'NAME_EMAIL',
  Relevance: 'RELEVANCE',
  Title: 'TITLE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type CompanyContactSortKeys = typeof CompanyContactSortKeys[keyof typeof CompanyContactSortKeys];
export type CompanyContactUpdatePayload = {
  companyContact?: Maybe<CompanyContact>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyContactsDeletePayload = {
  deletedCompanyContactIds?: Maybe<Array<Scalars['ID']['output']>>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyCreateInput = {
  company: CompanyInput;
  companyContact?: InputMaybe<CompanyContactInput>;
  companyLocation?: InputMaybe<CompanyLocationInput>;
};

export type CompanyCreatePayload = {
  company?: Maybe<Company>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyDeletePayload = {
  deletedCompanyId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyEdge = {
  cursor: Scalars['String']['output'];
  node: Company;
};

export type CompanyInput = {
  customerSince?: InputMaybe<Scalars['DateTime']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
};

export type CompanyLocation = CommentEventSubject & HasEvents & HasMetafieldDefinitions & HasMetafields & Navigable & Node & {
  billingAddress?: Maybe<CompanyAddress>;
  buyerExperienceConfiguration?: Maybe<BuyerExperienceConfiguration>;
  catalogs: CatalogConnection;
  catalogsCount?: Maybe<Count>;
  company: Company;
  createdAt: Scalars['DateTime']['output'];
  currency: CurrencyCode;
  defaultCursor: Scalars['String']['output'];
  draftOrders: DraftOrderConnection;
  events: EventConnection;
  externalId?: Maybe<Scalars['String']['output']>;
  hasTimelineComment: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  inCatalog: Scalars['Boolean']['output'];
  locale?: Maybe<Scalars['String']['output']>;
  market: Market;
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  name: Scalars['String']['output'];
  note?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use `ordersCount` instead. */
  orderCount: Scalars['Int']['output'];
  orders: OrderConnection;
  ordersCount?: Maybe<Count>;
  phone?: Maybe<Scalars['String']['output']>;
  roleAssignments: CompanyContactRoleAssignmentConnection;
  shippingAddress?: Maybe<CompanyAddress>;
  staffMemberAssignments: CompanyLocationStaffMemberAssignmentConnection;
  /** @deprecated Use `taxSettings` instead. */
  taxExemptions: Array<TaxExemption>;
  /** @deprecated Use `taxSettings` instead. */
  taxRegistrationId?: Maybe<Scalars['String']['output']>;
  taxSettings: CompanyLocationTaxSettings;
  totalSpent: MoneyV2;
  updatedAt: Scalars['DateTime']['output'];
};


export type CompanyLocationCatalogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CompanyLocationDraftOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<DraftOrderSortKeys>;
};


export type CompanyLocationEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type CompanyLocationInCatalogArgs = {
  catalogId: Scalars['ID']['input'];
};


export type CompanyLocationMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type CompanyLocationMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type CompanyLocationMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CompanyLocationOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<OrderSortKeys>;
};


export type CompanyLocationRoleAssignmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CompanyContactRoleAssignmentSortKeys>;
};


export type CompanyLocationStaffMemberAssignmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CompanyLocationStaffMemberAssignmentSortKeys>;
};

export type CompanyLocationAssignAddressPayload = {
  addresses?: Maybe<Array<CompanyAddress>>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyLocationAssignRolesPayload = {
  roleAssignments?: Maybe<Array<CompanyContactRoleAssignment>>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyLocationAssignStaffMembersPayload = {
  companyLocationStaffMemberAssignments?: Maybe<Array<CompanyLocationStaffMemberAssignment>>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyLocationAssignTaxExemptionsPayload = {
  companyLocation?: Maybe<CompanyLocation>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyLocationCatalog = Catalog & Node & {
  companyLocations: CompanyLocationConnection;
  companyLocationsCount?: Maybe<Count>;
  id: Scalars['ID']['output'];
  operations: Array<ResourceOperation>;
  priceList?: Maybe<PriceList>;
  publication?: Maybe<Publication>;
  status: CatalogStatus;
  title: Scalars['String']['output'];
};


export type CompanyLocationCatalogCompanyLocationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CompanyLocationSortKeys>;
};

export type CompanyLocationConnection = {
  edges: Array<CompanyLocationEdge>;
  nodes: Array<CompanyLocation>;
  pageInfo: PageInfo;
};

export type CompanyLocationCreatePayload = {
  companyLocation?: Maybe<CompanyLocation>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyLocationCreateTaxRegistrationPayload = {
  companyLocation?: Maybe<CompanyLocation>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyLocationDeletePayload = {
  deletedCompanyLocationId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyLocationEdge = {
  cursor: Scalars['String']['output'];
  node: CompanyLocation;
};

export type CompanyLocationInput = {
  billingAddress?: InputMaybe<CompanyAddressInput>;
  billingSameAsShipping?: InputMaybe<Scalars['Boolean']['input']>;
  buyerExperienceConfiguration?: InputMaybe<BuyerExperienceConfigurationInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  shippingAddress?: InputMaybe<CompanyAddressInput>;
  taxExempt?: InputMaybe<Scalars['Boolean']['input']>;
  taxExemptions?: InputMaybe<Array<TaxExemption>>;
  taxRegistrationId?: InputMaybe<Scalars['String']['input']>;
};

export type CompanyLocationRemoveStaffMembersPayload = {
  deletedCompanyLocationStaffMemberAssignmentIds?: Maybe<Array<Scalars['ID']['output']>>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyLocationRevokeRolesPayload = {
  revokedRoleAssignmentIds?: Maybe<Array<Scalars['ID']['output']>>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyLocationRevokeTaxExemptionsPayload = {
  companyLocation?: Maybe<CompanyLocation>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyLocationRevokeTaxRegistrationPayload = {
  companyLocation?: Maybe<CompanyLocation>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyLocationRoleAssign = {
  companyContactId: Scalars['ID']['input'];
  companyContactRoleId: Scalars['ID']['input'];
};

export const CompanyLocationSortKeys = {
  CompanyAndLocationName: 'COMPANY_AND_LOCATION_NAME',
  CompanyId: 'COMPANY_ID',
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Name: 'NAME',
  Relevance: 'RELEVANCE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type CompanyLocationSortKeys = typeof CompanyLocationSortKeys[keyof typeof CompanyLocationSortKeys];
export type CompanyLocationStaffMemberAssignment = Node & {
  companyLocation: CompanyLocation;
  id: Scalars['ID']['output'];
  staffMember: StaffMember;
};

export type CompanyLocationStaffMemberAssignmentConnection = {
  edges: Array<CompanyLocationStaffMemberAssignmentEdge>;
  nodes: Array<CompanyLocationStaffMemberAssignment>;
  pageInfo: PageInfo;
};

export type CompanyLocationStaffMemberAssignmentEdge = {
  cursor: Scalars['String']['output'];
  node: CompanyLocationStaffMemberAssignment;
};

export const CompanyLocationStaffMemberAssignmentSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type CompanyLocationStaffMemberAssignmentSortKeys = typeof CompanyLocationStaffMemberAssignmentSortKeys[keyof typeof CompanyLocationStaffMemberAssignmentSortKeys];
export type CompanyLocationTaxSettings = {
  taxExempt: Scalars['Boolean']['output'];
  taxExemptions: Array<TaxExemption>;
  taxRegistrationId?: Maybe<Scalars['String']['output']>;
};

export type CompanyLocationTaxSettingsUpdatePayload = {
  companyLocation?: Maybe<CompanyLocation>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyLocationUpdateInput = {
  buyerExperienceConfiguration?: InputMaybe<BuyerExperienceConfigurationInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
};

export type CompanyLocationUpdatePayload = {
  companyLocation?: Maybe<CompanyLocation>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyLocationsDeletePayload = {
  deletedCompanyLocationIds?: Maybe<Array<Scalars['ID']['output']>>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type CompanyRevokeMainContactPayload = {
  company?: Maybe<Company>;
  userErrors: Array<BusinessCustomerUserError>;
};

export const CompanySortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Name: 'NAME',
  OrderCount: 'ORDER_COUNT',
  Relevance: 'RELEVANCE',
  SinceDate: 'SINCE_DATE',
  TotalSpent: 'TOTAL_SPENT',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type CompanySortKeys = typeof CompanySortKeys[keyof typeof CompanySortKeys];
export type CompanyUpdatePayload = {
  company?: Maybe<Company>;
  userErrors: Array<BusinessCustomerUserError>;
};

export type ContextualPricingContext = {
  companyLocationId?: InputMaybe<Scalars['ID']['input']>;
  country?: InputMaybe<CountryCode>;
};

export type ContextualPublicationContext = {
  companyLocationId?: InputMaybe<Scalars['ID']['input']>;
  country?: InputMaybe<CountryCode>;
};

export type Count = {
  count: Scalars['Int']['output'];
  precision: CountPrecision;
};

export const CountPrecision = {
  AtLeast: 'AT_LEAST',
  Exact: 'EXACT'
} as const;

export type CountPrecision = typeof CountPrecision[keyof typeof CountPrecision];
export type CountriesInShippingZones = {
  countryCodes: Array<CountryCode>;
  includeRestOfWorld: Scalars['Boolean']['output'];
};

export const CountryCode = {
  Ac: 'AC',
  Ad: 'AD',
  Ae: 'AE',
  Af: 'AF',
  Ag: 'AG',
  Ai: 'AI',
  Al: 'AL',
  Am: 'AM',
  An: 'AN',
  Ao: 'AO',
  Ar: 'AR',
  At: 'AT',
  Au: 'AU',
  Aw: 'AW',
  Ax: 'AX',
  Az: 'AZ',
  Ba: 'BA',
  Bb: 'BB',
  Bd: 'BD',
  Be: 'BE',
  Bf: 'BF',
  Bg: 'BG',
  Bh: 'BH',
  Bi: 'BI',
  Bj: 'BJ',
  Bl: 'BL',
  Bm: 'BM',
  Bn: 'BN',
  Bo: 'BO',
  Bq: 'BQ',
  Br: 'BR',
  Bs: 'BS',
  Bt: 'BT',
  Bv: 'BV',
  Bw: 'BW',
  By: 'BY',
  Bz: 'BZ',
  Ca: 'CA',
  Cc: 'CC',
  Cd: 'CD',
  Cf: 'CF',
  Cg: 'CG',
  Ch: 'CH',
  Ci: 'CI',
  Ck: 'CK',
  Cl: 'CL',
  Cm: 'CM',
  Cn: 'CN',
  Co: 'CO',
  Cr: 'CR',
  Cu: 'CU',
  Cv: 'CV',
  Cw: 'CW',
  Cx: 'CX',
  Cy: 'CY',
  Cz: 'CZ',
  De: 'DE',
  Dj: 'DJ',
  Dk: 'DK',
  Dm: 'DM',
  Do: 'DO',
  Dz: 'DZ',
  Ec: 'EC',
  Ee: 'EE',
  Eg: 'EG',
  Eh: 'EH',
  Er: 'ER',
  Es: 'ES',
  Et: 'ET',
  Fi: 'FI',
  Fj: 'FJ',
  Fk: 'FK',
  Fo: 'FO',
  Fr: 'FR',
  Ga: 'GA',
  Gb: 'GB',
  Gd: 'GD',
  Ge: 'GE',
  Gf: 'GF',
  Gg: 'GG',
  Gh: 'GH',
  Gi: 'GI',
  Gl: 'GL',
  Gm: 'GM',
  Gn: 'GN',
  Gp: 'GP',
  Gq: 'GQ',
  Gr: 'GR',
  Gs: 'GS',
  Gt: 'GT',
  Gw: 'GW',
  Gy: 'GY',
  Hk: 'HK',
  Hm: 'HM',
  Hn: 'HN',
  Hr: 'HR',
  Ht: 'HT',
  Hu: 'HU',
  Id: 'ID',
  Ie: 'IE',
  Il: 'IL',
  Im: 'IM',
  In: 'IN',
  Io: 'IO',
  Iq: 'IQ',
  Ir: 'IR',
  Is: 'IS',
  It: 'IT',
  Je: 'JE',
  Jm: 'JM',
  Jo: 'JO',
  Jp: 'JP',
  Ke: 'KE',
  Kg: 'KG',
  Kh: 'KH',
  Ki: 'KI',
  Km: 'KM',
  Kn: 'KN',
  Kp: 'KP',
  Kr: 'KR',
  Kw: 'KW',
  Ky: 'KY',
  Kz: 'KZ',
  La: 'LA',
  Lb: 'LB',
  Lc: 'LC',
  Li: 'LI',
  Lk: 'LK',
  Lr: 'LR',
  Ls: 'LS',
  Lt: 'LT',
  Lu: 'LU',
  Lv: 'LV',
  Ly: 'LY',
  Ma: 'MA',
  Mc: 'MC',
  Md: 'MD',
  Me: 'ME',
  Mf: 'MF',
  Mg: 'MG',
  Mk: 'MK',
  Ml: 'ML',
  Mm: 'MM',
  Mn: 'MN',
  Mo: 'MO',
  Mq: 'MQ',
  Mr: 'MR',
  Ms: 'MS',
  Mt: 'MT',
  Mu: 'MU',
  Mv: 'MV',
  Mw: 'MW',
  Mx: 'MX',
  My: 'MY',
  Mz: 'MZ',
  Na: 'NA',
  Nc: 'NC',
  Ne: 'NE',
  Nf: 'NF',
  Ng: 'NG',
  Ni: 'NI',
  Nl: 'NL',
  No: 'NO',
  Np: 'NP',
  Nr: 'NR',
  Nu: 'NU',
  Nz: 'NZ',
  Om: 'OM',
  Pa: 'PA',
  Pe: 'PE',
  Pf: 'PF',
  Pg: 'PG',
  Ph: 'PH',
  Pk: 'PK',
  Pl: 'PL',
  Pm: 'PM',
  Pn: 'PN',
  Ps: 'PS',
  Pt: 'PT',
  Py: 'PY',
  Qa: 'QA',
  Re: 'RE',
  Ro: 'RO',
  Rs: 'RS',
  Ru: 'RU',
  Rw: 'RW',
  Sa: 'SA',
  Sb: 'SB',
  Sc: 'SC',
  Sd: 'SD',
  Se: 'SE',
  Sg: 'SG',
  Sh: 'SH',
  Si: 'SI',
  Sj: 'SJ',
  Sk: 'SK',
  Sl: 'SL',
  Sm: 'SM',
  Sn: 'SN',
  So: 'SO',
  Sr: 'SR',
  Ss: 'SS',
  St: 'ST',
  Sv: 'SV',
  Sx: 'SX',
  Sy: 'SY',
  Sz: 'SZ',
  Ta: 'TA',
  Tc: 'TC',
  Td: 'TD',
  Tf: 'TF',
  Tg: 'TG',
  Th: 'TH',
  Tj: 'TJ',
  Tk: 'TK',
  Tl: 'TL',
  Tm: 'TM',
  Tn: 'TN',
  To: 'TO',
  Tr: 'TR',
  Tt: 'TT',
  Tv: 'TV',
  Tw: 'TW',
  Tz: 'TZ',
  Ua: 'UA',
  Ug: 'UG',
  Um: 'UM',
  Us: 'US',
  Uy: 'UY',
  Uz: 'UZ',
  Va: 'VA',
  Vc: 'VC',
  Ve: 'VE',
  Vg: 'VG',
  Vn: 'VN',
  Vu: 'VU',
  Wf: 'WF',
  Ws: 'WS',
  Xk: 'XK',
  Ye: 'YE',
  Yt: 'YT',
  Za: 'ZA',
  Zm: 'ZM',
  Zw: 'ZW',
  Zz: 'ZZ'
} as const;

export type CountryCode = typeof CountryCode[keyof typeof CountryCode];
export type CountryHarmonizedSystemCode = {
  countryCode: CountryCode;
  harmonizedSystemCode: Scalars['String']['output'];
};

export type CountryHarmonizedSystemCodeConnection = {
  edges: Array<CountryHarmonizedSystemCodeEdge>;
  nodes: Array<CountryHarmonizedSystemCode>;
  pageInfo: PageInfo;
};

export type CountryHarmonizedSystemCodeEdge = {
  cursor: Scalars['String']['output'];
  node: CountryHarmonizedSystemCode;
};

export type CountryHarmonizedSystemCodeInput = {
  countryCode: CountryCode;
  harmonizedSystemCode: Scalars['String']['input'];
};

export type CreateMediaInput = {
  alt?: InputMaybe<Scalars['String']['input']>;
  mediaContentType: MediaContentType;
  originalSource: Scalars['String']['input'];
};

export const CropRegion = {
  Bottom: 'BOTTOM',
  Center: 'CENTER',
  Left: 'LEFT',
  Right: 'RIGHT',
  Top: 'TOP'
} as const;

export type CropRegion = typeof CropRegion[keyof typeof CropRegion];
export const CurrencyCode = {
  Aed: 'AED',
  Afn: 'AFN',
  All: 'ALL',
  Amd: 'AMD',
  Ang: 'ANG',
  Aoa: 'AOA',
  Ars: 'ARS',
  Aud: 'AUD',
  Awg: 'AWG',
  Azn: 'AZN',
  Bam: 'BAM',
  Bbd: 'BBD',
  Bdt: 'BDT',
  Bgn: 'BGN',
  Bhd: 'BHD',
  Bif: 'BIF',
  Bmd: 'BMD',
  Bnd: 'BND',
  Bob: 'BOB',
  Brl: 'BRL',
  Bsd: 'BSD',
  Btn: 'BTN',
  Bwp: 'BWP',
  Byn: 'BYN',
  Byr: 'BYR',
  Bzd: 'BZD',
  Cad: 'CAD',
  Cdf: 'CDF',
  Chf: 'CHF',
  Clp: 'CLP',
  Cny: 'CNY',
  Cop: 'COP',
  Crc: 'CRC',
  Cve: 'CVE',
  Czk: 'CZK',
  Djf: 'DJF',
  Dkk: 'DKK',
  Dop: 'DOP',
  Dzd: 'DZD',
  Egp: 'EGP',
  Ern: 'ERN',
  Etb: 'ETB',
  Eur: 'EUR',
  Fjd: 'FJD',
  Fkp: 'FKP',
  Gbp: 'GBP',
  Gel: 'GEL',
  Ghs: 'GHS',
  Gip: 'GIP',
  Gmd: 'GMD',
  Gnf: 'GNF',
  Gtq: 'GTQ',
  Gyd: 'GYD',
  Hkd: 'HKD',
  Hnl: 'HNL',
  Hrk: 'HRK',
  Htg: 'HTG',
  Huf: 'HUF',
  Idr: 'IDR',
  Ils: 'ILS',
  Inr: 'INR',
  Iqd: 'IQD',
  Irr: 'IRR',
  Isk: 'ISK',
  Jep: 'JEP',
  Jmd: 'JMD',
  Jod: 'JOD',
  Jpy: 'JPY',
  Kes: 'KES',
  Kgs: 'KGS',
  Khr: 'KHR',
  Kid: 'KID',
  Kmf: 'KMF',
  Krw: 'KRW',
  Kwd: 'KWD',
  Kyd: 'KYD',
  Kzt: 'KZT',
  Lak: 'LAK',
  Lbp: 'LBP',
  Lkr: 'LKR',
  Lrd: 'LRD',
  Lsl: 'LSL',
  Ltl: 'LTL',
  Lvl: 'LVL',
  Lyd: 'LYD',
  Mad: 'MAD',
  Mdl: 'MDL',
  Mga: 'MGA',
  Mkd: 'MKD',
  Mmk: 'MMK',
  Mnt: 'MNT',
  Mop: 'MOP',
  Mru: 'MRU',
  Mur: 'MUR',
  Mvr: 'MVR',
  Mwk: 'MWK',
  Mxn: 'MXN',
  Myr: 'MYR',
  Mzn: 'MZN',
  Nad: 'NAD',
  Ngn: 'NGN',
  Nio: 'NIO',
  Nok: 'NOK',
  Npr: 'NPR',
  Nzd: 'NZD',
  Omr: 'OMR',
  Pab: 'PAB',
  Pen: 'PEN',
  Pgk: 'PGK',
  Php: 'PHP',
  Pkr: 'PKR',
  Pln: 'PLN',
  Pyg: 'PYG',
  Qar: 'QAR',
  Ron: 'RON',
  Rsd: 'RSD',
  Rub: 'RUB',
  Rwf: 'RWF',
  Sar: 'SAR',
  Sbd: 'SBD',
  Scr: 'SCR',
  Sdg: 'SDG',
  Sek: 'SEK',
  Sgd: 'SGD',
  Shp: 'SHP',
  Sll: 'SLL',
  Sos: 'SOS',
  Srd: 'SRD',
  Ssp: 'SSP',
  Std: 'STD',
  Stn: 'STN',
  Syp: 'SYP',
  Szl: 'SZL',
  Thb: 'THB',
  Tjs: 'TJS',
  Tmt: 'TMT',
  Tnd: 'TND',
  Top: 'TOP',
  Try: 'TRY',
  Ttd: 'TTD',
  Twd: 'TWD',
  Tzs: 'TZS',
  Uah: 'UAH',
  Ugx: 'UGX',
  Usd: 'USD',
  Uyu: 'UYU',
  Uzs: 'UZS',
  Ved: 'VED',
  Vef: 'VEF',
  Ves: 'VES',
  Vnd: 'VND',
  Vuv: 'VUV',
  Wst: 'WST',
  Xaf: 'XAF',
  Xcd: 'XCD',
  Xof: 'XOF',
  Xpf: 'XPF',
  Xxx: 'XXX',
  Yer: 'YER',
  Zar: 'ZAR',
  Zmw: 'ZMW'
} as const;

export type CurrencyCode = typeof CurrencyCode[keyof typeof CurrencyCode];
export type CurrencyFormats = {
  moneyFormat: Scalars['FormattedString']['output'];
  moneyInEmailsFormat: Scalars['String']['output'];
  moneyWithCurrencyFormat: Scalars['FormattedString']['output'];
  moneyWithCurrencyInEmailsFormat: Scalars['String']['output'];
};

export type CurrencySetting = {
  currencyCode: CurrencyCode;
  currencyName: Scalars['String']['output'];
  enabled: Scalars['Boolean']['output'];
  rateUpdatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type CurrencySettingConnection = {
  edges: Array<CurrencySettingEdge>;
  nodes: Array<CurrencySetting>;
  pageInfo: PageInfo;
};

export type CurrencySettingEdge = {
  cursor: Scalars['String']['output'];
  node: CurrencySetting;
};

export type CustomShippingPackageInput = {
  default?: InputMaybe<Scalars['Boolean']['input']>;
  dimensions?: InputMaybe<ObjectDimensionsInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<ShippingPackageType>;
  weight?: InputMaybe<WeightInput>;
};

export type Customer = CommentEventSubject & HasEvents & HasMetafieldDefinitions & HasMetafields & HasStoreCreditAccounts & LegacyInteroperability & Node & {
  addresses: Array<MailingAddress>;
  addressesV2: MailingAddressConnection;
  amountSpent: MoneyV2;
  canDelete: Scalars['Boolean']['output'];
  companyContactProfiles: Array<CompanyContact>;
  createdAt: Scalars['DateTime']['output'];
  dataSaleOptOut: Scalars['Boolean']['output'];
  defaultAddress?: Maybe<MailingAddress>;
  displayName: Scalars['String']['output'];
  email?: Maybe<Scalars['String']['output']>;
  emailMarketingConsent?: Maybe<CustomerEmailMarketingConsentState>;
  events: EventConnection;
  firstName?: Maybe<Scalars['String']['output']>;
  /** @deprecated To query for comments on the timeline, use the events connection and a `query` argument containing `verb:comment`, or look for a `CommentEvent` in the `__typename` of events. */
  hasTimelineComment: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  image: Image;
  lastName?: Maybe<Scalars['String']['output']>;
  lastOrder?: Maybe<Order>;
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  lifetimeDuration: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  market?: Maybe<Market>;
  mergeable: CustomerMergeable;
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  multipassIdentifier?: Maybe<Scalars['String']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  numberOfOrders: Scalars['UnsignedInt64']['output'];
  orders: OrderConnection;
  paymentMethods: CustomerPaymentMethodConnection;
  phone?: Maybe<Scalars['String']['output']>;
  productSubscriberStatus: CustomerProductSubscriberStatus;
  smsMarketingConsent?: Maybe<CustomerSmsMarketingConsentState>;
  state: CustomerState;
  statistics: CustomerStatistics;
  storeCreditAccounts: StoreCreditAccountConnection;
  subscriptionContracts: SubscriptionContractConnection;
  tags: Array<Scalars['String']['output']>;
  taxExempt: Scalars['Boolean']['output'];
  taxExemptions: Array<TaxExemption>;
  unsubscribeUrl: Scalars['URL']['output'];
  updatedAt: Scalars['DateTime']['output'];
  validEmailAddress: Scalars['Boolean']['output'];
  verifiedEmail: Scalars['Boolean']['output'];
};


export type CustomerAddressesArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type CustomerAddressesV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CustomerEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type CustomerMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type CustomerMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type CustomerMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CustomerOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<OrderSortKeys>;
};


export type CustomerPaymentMethodsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  showRevoked?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CustomerStoreCreditAccountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


export type CustomerSubscriptionContractsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CustomerAccountAppExtensionPage = CustomerAccountPage & Navigable & Node & {
  appExtensionUuid?: Maybe<Scalars['String']['output']>;
  defaultCursor: Scalars['String']['output'];
  handle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  title: Scalars['String']['output'];
};

export type CustomerAccountNativePage = CustomerAccountPage & Navigable & Node & {
  defaultCursor: Scalars['String']['output'];
  handle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  pageType: CustomerAccountNativePagePageType;
  title: Scalars['String']['output'];
};

export const CustomerAccountNativePagePageType = {
  NativeOrders: 'NATIVE_ORDERS',
  NativeProfile: 'NATIVE_PROFILE',
  NativeSettings: 'NATIVE_SETTINGS',
  Unknown: 'UNKNOWN'
} as const;

export type CustomerAccountNativePagePageType = typeof CustomerAccountNativePagePageType[keyof typeof CustomerAccountNativePagePageType];
export type CustomerAccountPage = {
  defaultCursor: Scalars['String']['output'];
  handle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  title: Scalars['String']['output'];
};

export type CustomerAccountPageConnection = {
  edges: Array<CustomerAccountPageEdge>;
  nodes: Array<CustomerAccountPage>;
  pageInfo: PageInfo;
};

export type CustomerAccountPageEdge = {
  cursor: Scalars['String']['output'];
  node: CustomerAccountPage;
};

export type CustomerAccountsV2 = {
  customerAccountsVersion: CustomerAccountsVersion;
  loginLinksVisibleOnStorefrontAndCheckout: Scalars['Boolean']['output'];
  loginRequiredAtCheckout: Scalars['Boolean']['output'];
  url?: Maybe<Scalars['URL']['output']>;
};

export const CustomerAccountsVersion = {
  Classic: 'CLASSIC',
  NewCustomerAccounts: 'NEW_CUSTOMER_ACCOUNTS'
} as const;

export type CustomerAccountsVersion = typeof CustomerAccountsVersion[keyof typeof CustomerAccountsVersion];
export type CustomerAddTaxExemptionsPayload = {
  customer?: Maybe<Customer>;
  userErrors: Array<UserError>;
};

export const CustomerCancelDataErasureErrorCode = {
  DoesNotExist: 'DOES_NOT_EXIST',
  FailedToCancel: 'FAILED_TO_CANCEL',
  NotBeingErased: 'NOT_BEING_ERASED'
} as const;

export type CustomerCancelDataErasureErrorCode = typeof CustomerCancelDataErasureErrorCode[keyof typeof CustomerCancelDataErasureErrorCode];
export type CustomerCancelDataErasurePayload = {
  customerId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<CustomerCancelDataErasureUserError>;
};

export type CustomerCancelDataErasureUserError = DisplayableError & {
  code?: Maybe<CustomerCancelDataErasureErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type CustomerConnection = {
  edges: Array<CustomerEdge>;
  nodes: Array<Customer>;
  pageInfo: PageInfo;
};

export const CustomerConsentCollectedFrom = {
  Other: 'OTHER',
  Shopify: 'SHOPIFY'
} as const;

export type CustomerConsentCollectedFrom = typeof CustomerConsentCollectedFrom[keyof typeof CustomerConsentCollectedFrom];
export type CustomerCreatePayload = {
  customer?: Maybe<Customer>;
  userErrors: Array<UserError>;
};

export type CustomerCreditCard = {
  billingAddress?: Maybe<CustomerCreditCardBillingAddress>;
  brand: Scalars['String']['output'];
  expiresSoon: Scalars['Boolean']['output'];
  expiryMonth: Scalars['Int']['output'];
  expiryYear: Scalars['Int']['output'];
  firstDigits?: Maybe<Scalars['String']['output']>;
  isRevocable: Scalars['Boolean']['output'];
  lastDigits: Scalars['String']['output'];
  maskedNumber: Scalars['String']['output'];
  name: Scalars['String']['output'];
  source?: Maybe<Scalars['String']['output']>;
  virtualLastDigits?: Maybe<Scalars['String']['output']>;
};

export type CustomerCreditCardBillingAddress = {
  address1?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  countryCode?: Maybe<CountryCode>;
  firstName?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  provinceCode?: Maybe<Scalars['String']['output']>;
  zip?: Maybe<Scalars['String']['output']>;
};

export type CustomerDeleteInput = {
  id: Scalars['ID']['input'];
};

export type CustomerDeletePayload = {
  deletedCustomerId?: Maybe<Scalars['ID']['output']>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type CustomerEdge = {
  cursor: Scalars['String']['output'];
  node: Customer;
};

export type CustomerEmailAddress = {
  emailAddress: Scalars['String']['output'];
  marketingState: CustomerEmailAddressMarketingState;
  marketingUnsubscribeUrl: Scalars['URL']['output'];
  openTrackingLevel: CustomerEmailAddressOpenTrackingLevel;
  openTrackingUrl: Scalars['URL']['output'];
};

export const CustomerEmailAddressMarketingState = {
  Invalid: 'INVALID',
  NotSubscribed: 'NOT_SUBSCRIBED',
  Pending: 'PENDING',
  Subscribed: 'SUBSCRIBED',
  Unsubscribed: 'UNSUBSCRIBED'
} as const;

export type CustomerEmailAddressMarketingState = typeof CustomerEmailAddressMarketingState[keyof typeof CustomerEmailAddressMarketingState];
export const CustomerEmailAddressOpenTrackingLevel = {
  OptedIn: 'OPTED_IN',
  OptedOut: 'OPTED_OUT',
  Unknown: 'UNKNOWN'
} as const;

export type CustomerEmailAddressOpenTrackingLevel = typeof CustomerEmailAddressOpenTrackingLevel[keyof typeof CustomerEmailAddressOpenTrackingLevel];
export type CustomerEmailMarketingConsentInput = {
  consentUpdatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  marketingOptInLevel?: InputMaybe<CustomerMarketingOptInLevel>;
  marketingState: CustomerEmailMarketingState;
};

export type CustomerEmailMarketingConsentState = {
  consentUpdatedAt?: Maybe<Scalars['DateTime']['output']>;
  marketingOptInLevel?: Maybe<CustomerMarketingOptInLevel>;
  marketingState: CustomerEmailMarketingState;
};

export type CustomerEmailMarketingConsentUpdateInput = {
  customerId: Scalars['ID']['input'];
  emailMarketingConsent: CustomerEmailMarketingConsentInput;
};

export type CustomerEmailMarketingConsentUpdatePayload = {
  customer?: Maybe<Customer>;
  userErrors: Array<CustomerEmailMarketingConsentUpdateUserError>;
};

export type CustomerEmailMarketingConsentUpdateUserError = DisplayableError & {
  code?: Maybe<CustomerEmailMarketingConsentUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CustomerEmailMarketingConsentUpdateUserErrorCode = {
  Inclusion: 'INCLUSION',
  InternalError: 'INTERNAL_ERROR',
  Invalid: 'INVALID',
  MissingArgument: 'MISSING_ARGUMENT'
} as const;

export type CustomerEmailMarketingConsentUpdateUserErrorCode = typeof CustomerEmailMarketingConsentUpdateUserErrorCode[keyof typeof CustomerEmailMarketingConsentUpdateUserErrorCode];
export const CustomerEmailMarketingState = {
  Invalid: 'INVALID',
  NotSubscribed: 'NOT_SUBSCRIBED',
  Pending: 'PENDING',
  Redacted: 'REDACTED',
  Subscribed: 'SUBSCRIBED',
  Unsubscribed: 'UNSUBSCRIBED'
} as const;

export type CustomerEmailMarketingState = typeof CustomerEmailMarketingState[keyof typeof CustomerEmailMarketingState];
export type CustomerGenerateAccountActivationUrlPayload = {
  accountActivationUrl?: Maybe<Scalars['URL']['output']>;
  userErrors: Array<UserError>;
};

export type CustomerIdentifierInput = {
  customId?: InputMaybe<UniqueMetafieldValueInput>;
  emailAddress?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerInput = {
  addresses?: InputMaybe<Array<MailingAddressInput>>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailMarketingConsent?: InputMaybe<CustomerEmailMarketingConsentInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  note?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  smsMarketingConsent?: InputMaybe<CustomerSmsMarketingConsentInput>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  taxExempt?: InputMaybe<Scalars['Boolean']['input']>;
  taxExemptions?: InputMaybe<Array<TaxExemption>>;
};

export type CustomerJourney = {
  customerOrderIndex: Scalars['Int']['output'];
  daysToConversion: Scalars['Int']['output'];
  firstVisit: CustomerVisit;
  lastVisit?: Maybe<CustomerVisit>;
  moments: Array<CustomerMoment>;
};

export type CustomerJourneySummary = {
  customerOrderIndex?: Maybe<Scalars['Int']['output']>;
  daysToConversion?: Maybe<Scalars['Int']['output']>;
  firstVisit?: Maybe<CustomerVisit>;
  lastVisit?: Maybe<CustomerVisit>;
  moments?: Maybe<CustomerMomentConnection>;
  momentsCount?: Maybe<Count>;
  ready: Scalars['Boolean']['output'];
};


export type CustomerJourneySummaryMomentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export const CustomerMarketingOptInLevel = {
  ConfirmedOptIn: 'CONFIRMED_OPT_IN',
  SingleOptIn: 'SINGLE_OPT_IN',
  Unknown: 'UNKNOWN'
} as const;

export type CustomerMarketingOptInLevel = typeof CustomerMarketingOptInLevel[keyof typeof CustomerMarketingOptInLevel];
export type CustomerMergeError = {
  errorFields: Array<CustomerMergeErrorFieldType>;
  message: Scalars['String']['output'];
};

export const CustomerMergeErrorCode = {
  CustomerHasGiftCards: 'CUSTOMER_HAS_GIFT_CARDS',
  InternalError: 'INTERNAL_ERROR',
  InvalidCustomer: 'INVALID_CUSTOMER',
  InvalidCustomerId: 'INVALID_CUSTOMER_ID',
  MissingOverrideAttribute: 'MISSING_OVERRIDE_ATTRIBUTE',
  OverrideAttributeInvalid: 'OVERRIDE_ATTRIBUTE_INVALID'
} as const;

export type CustomerMergeErrorCode = typeof CustomerMergeErrorCode[keyof typeof CustomerMergeErrorCode];
export const CustomerMergeErrorFieldType = {
  CompanyContact: 'COMPANY_CONTACT',
  CustomerPaymentMethods: 'CUSTOMER_PAYMENT_METHODS',
  DeletedAt: 'DELETED_AT',
  GiftCards: 'GIFT_CARDS',
  MergeInProgress: 'MERGE_IN_PROGRESS',
  MultipassIdentifier: 'MULTIPASS_IDENTIFIER',
  PendingDataRequest: 'PENDING_DATA_REQUEST',
  RedactedAt: 'REDACTED_AT',
  StoreCredit: 'STORE_CREDIT',
  Subscriptions: 'SUBSCRIPTIONS'
} as const;

export type CustomerMergeErrorFieldType = typeof CustomerMergeErrorFieldType[keyof typeof CustomerMergeErrorFieldType];
export type CustomerMergeOverrideFields = {
  customerIdOfDefaultAddressToKeep?: InputMaybe<Scalars['ID']['input']>;
  customerIdOfEmailToKeep?: InputMaybe<Scalars['ID']['input']>;
  customerIdOfFirstNameToKeep?: InputMaybe<Scalars['ID']['input']>;
  customerIdOfLastNameToKeep?: InputMaybe<Scalars['ID']['input']>;
  customerIdOfPhoneNumberToKeep?: InputMaybe<Scalars['ID']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type CustomerMergePayload = {
  job?: Maybe<Job>;
  resultingCustomerId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<CustomerMergeUserError>;
};

export type CustomerMergePreview = {
  alternateFields?: Maybe<CustomerMergePreviewAlternateFields>;
  blockingFields?: Maybe<CustomerMergePreviewBlockingFields>;
  customerMergeErrors?: Maybe<Array<CustomerMergeError>>;
  defaultFields?: Maybe<CustomerMergePreviewDefaultFields>;
  resultingCustomerId?: Maybe<Scalars['ID']['output']>;
};

export type CustomerMergePreviewAlternateFields = {
  defaultAddress?: Maybe<MailingAddress>;
  email?: Maybe<CustomerEmailAddress>;
  firstName?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  phoneNumber?: Maybe<CustomerPhoneNumber>;
};

export type CustomerMergePreviewBlockingFields = {
  note?: Maybe<Scalars['String']['output']>;
  tags: Array<Scalars['String']['output']>;
};

export type CustomerMergePreviewDefaultFields = {
  addresses: MailingAddressConnection;
  defaultAddress?: Maybe<MailingAddress>;
  discountNodeCount: Scalars['UnsignedInt64']['output'];
  discountNodes: DiscountNodeConnection;
  displayName: Scalars['String']['output'];
  draftOrderCount: Scalars['UnsignedInt64']['output'];
  draftOrders: DraftOrderConnection;
  email?: Maybe<CustomerEmailAddress>;
  firstName?: Maybe<Scalars['String']['output']>;
  giftCardCount: Scalars['UnsignedInt64']['output'];
  giftCards: GiftCardConnection;
  lastName?: Maybe<Scalars['String']['output']>;
  metafieldCount: Scalars['UnsignedInt64']['output'];
  note?: Maybe<Scalars['String']['output']>;
  orderCount: Scalars['UnsignedInt64']['output'];
  orders: OrderConnection;
  phoneNumber?: Maybe<CustomerPhoneNumber>;
  tags: Array<Scalars['String']['output']>;
};


export type CustomerMergePreviewDefaultFieldsAddressesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type CustomerMergePreviewDefaultFieldsDiscountNodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<DiscountSortKeys>;
};


export type CustomerMergePreviewDefaultFieldsDraftOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<DraftOrderSortKeys>;
};


export type CustomerMergePreviewDefaultFieldsGiftCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<GiftCardSortKeys>;
};


export type CustomerMergePreviewDefaultFieldsOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<OrderSortKeys>;
};

export type CustomerMergeRequest = {
  customerMergeErrors: Array<CustomerMergeError>;
  jobId?: Maybe<Scalars['ID']['output']>;
  resultingCustomerId: Scalars['ID']['output'];
  status: CustomerMergeRequestStatus;
};

export const CustomerMergeRequestStatus = {
  Completed: 'COMPLETED',
  Failed: 'FAILED',
  InProgress: 'IN_PROGRESS',
  Requested: 'REQUESTED'
} as const;

export type CustomerMergeRequestStatus = typeof CustomerMergeRequestStatus[keyof typeof CustomerMergeRequestStatus];
export type CustomerMergeUserError = DisplayableError & {
  code?: Maybe<CustomerMergeErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type CustomerMergeable = {
  errorFields: Array<CustomerMergeErrorFieldType>;
  isMergeable: Scalars['Boolean']['output'];
  mergeInProgress?: Maybe<CustomerMergeRequest>;
  reason?: Maybe<Scalars['String']['output']>;
};

export type CustomerMoment = {
  occurredAt: Scalars['DateTime']['output'];
};

export type CustomerMomentConnection = {
  edges: Array<CustomerMomentEdge>;
  nodes: Array<CustomerMoment>;
  pageInfo: PageInfo;
};

export type CustomerMomentEdge = {
  cursor: Scalars['String']['output'];
  node: CustomerMoment;
};

export type CustomerPaymentInstrument = CustomerCreditCard | CustomerPaypalBillingAgreement | CustomerShopPayAgreement;

export type CustomerPaymentInstrumentBillingAddress = {
  address1?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  countryCode?: Maybe<CountryCode>;
  name?: Maybe<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  provinceCode?: Maybe<Scalars['String']['output']>;
  zip?: Maybe<Scalars['String']['output']>;
};

export type CustomerPaymentMethod = Node & {
  customer?: Maybe<Customer>;
  id: Scalars['ID']['output'];
  instrument?: Maybe<CustomerPaymentInstrument>;
  revokedAt?: Maybe<Scalars['DateTime']['output']>;
  revokedReason?: Maybe<CustomerPaymentMethodRevocationReason>;
  subscriptionContracts: SubscriptionContractConnection;
};


export type CustomerPaymentMethodSubscriptionContractsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CustomerPaymentMethodConnection = {
  edges: Array<CustomerPaymentMethodEdge>;
  nodes: Array<CustomerPaymentMethod>;
  pageInfo: PageInfo;
};

export type CustomerPaymentMethodCreateFromDuplicationDataPayload = {
  customerPaymentMethod?: Maybe<CustomerPaymentMethod>;
  userErrors: Array<CustomerPaymentMethodCreateFromDuplicationDataUserError>;
};

export type CustomerPaymentMethodCreateFromDuplicationDataUserError = DisplayableError & {
  code?: Maybe<CustomerPaymentMethodCreateFromDuplicationDataUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CustomerPaymentMethodCreateFromDuplicationDataUserErrorCode = {
  CustomerDoesNotExist: 'CUSTOMER_DOES_NOT_EXIST',
  InvalidEncryptedDuplicationData: 'INVALID_ENCRYPTED_DUPLICATION_DATA',
  TooManyRequests: 'TOO_MANY_REQUESTS'
} as const;

export type CustomerPaymentMethodCreateFromDuplicationDataUserErrorCode = typeof CustomerPaymentMethodCreateFromDuplicationDataUserErrorCode[keyof typeof CustomerPaymentMethodCreateFromDuplicationDataUserErrorCode];
export type CustomerPaymentMethodCreditCardCreatePayload = {
  customerPaymentMethod?: Maybe<CustomerPaymentMethod>;
  processing?: Maybe<Scalars['Boolean']['output']>;
  userErrors: Array<UserError>;
};

export type CustomerPaymentMethodCreditCardUpdatePayload = {
  customerPaymentMethod?: Maybe<CustomerPaymentMethod>;
  processing?: Maybe<Scalars['Boolean']['output']>;
  userErrors: Array<UserError>;
};

export type CustomerPaymentMethodEdge = {
  cursor: Scalars['String']['output'];
  node: CustomerPaymentMethod;
};

export type CustomerPaymentMethodGetDuplicationDataPayload = {
  encryptedDuplicationData?: Maybe<Scalars['String']['output']>;
  userErrors: Array<CustomerPaymentMethodGetDuplicationDataUserError>;
};

export type CustomerPaymentMethodGetDuplicationDataUserError = DisplayableError & {
  code?: Maybe<CustomerPaymentMethodGetDuplicationDataUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CustomerPaymentMethodGetDuplicationDataUserErrorCode = {
  CustomerDoesNotExist: 'CUSTOMER_DOES_NOT_EXIST',
  InvalidInstrument: 'INVALID_INSTRUMENT',
  InvalidOrganizationShop: 'INVALID_ORGANIZATION_SHOP',
  PaymentMethodDoesNotExist: 'PAYMENT_METHOD_DOES_NOT_EXIST',
  SameShop: 'SAME_SHOP',
  TooManyRequests: 'TOO_MANY_REQUESTS'
} as const;

export type CustomerPaymentMethodGetDuplicationDataUserErrorCode = typeof CustomerPaymentMethodGetDuplicationDataUserErrorCode[keyof typeof CustomerPaymentMethodGetDuplicationDataUserErrorCode];
export type CustomerPaymentMethodGetUpdateUrlPayload = {
  updatePaymentMethodUrl?: Maybe<Scalars['URL']['output']>;
  userErrors: Array<CustomerPaymentMethodGetUpdateUrlUserError>;
};

export type CustomerPaymentMethodGetUpdateUrlUserError = DisplayableError & {
  code?: Maybe<CustomerPaymentMethodGetUpdateUrlUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CustomerPaymentMethodGetUpdateUrlUserErrorCode = {
  CustomerDoesNotExist: 'CUSTOMER_DOES_NOT_EXIST',
  InvalidInstrument: 'INVALID_INSTRUMENT',
  PaymentMethodDoesNotExist: 'PAYMENT_METHOD_DOES_NOT_EXIST',
  TooManyRequests: 'TOO_MANY_REQUESTS'
} as const;

export type CustomerPaymentMethodGetUpdateUrlUserErrorCode = typeof CustomerPaymentMethodGetUpdateUrlUserErrorCode[keyof typeof CustomerPaymentMethodGetUpdateUrlUserErrorCode];
export type CustomerPaymentMethodPaypalBillingAgreementCreatePayload = {
  customerPaymentMethod?: Maybe<CustomerPaymentMethod>;
  userErrors: Array<CustomerPaymentMethodUserError>;
};

export type CustomerPaymentMethodPaypalBillingAgreementUpdatePayload = {
  customerPaymentMethod?: Maybe<CustomerPaymentMethod>;
  userErrors: Array<CustomerPaymentMethodUserError>;
};

export type CustomerPaymentMethodRemoteCreatePayload = {
  customerPaymentMethod?: Maybe<CustomerPaymentMethod>;
  userErrors: Array<CustomerPaymentMethodRemoteUserError>;
};

export type CustomerPaymentMethodRemoteInput = {
  authorizeNetCustomerPaymentProfile?: InputMaybe<RemoteAuthorizeNetCustomerPaymentProfileInput>;
  braintreePaymentMethod?: InputMaybe<RemoteBraintreePaymentMethodInput>;
  stripePaymentMethod?: InputMaybe<RemoteStripePaymentMethodInput>;
};

export type CustomerPaymentMethodRemoteUserError = DisplayableError & {
  code?: Maybe<CustomerPaymentMethodRemoteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CustomerPaymentMethodRemoteUserErrorCode = {
  AuthorizeNetNotEnabledForSubscriptions: 'AUTHORIZE_NET_NOT_ENABLED_FOR_SUBSCRIPTIONS',
  BraintreeNotEnabledForSubscriptions: 'BRAINTREE_NOT_ENABLED_FOR_SUBSCRIPTIONS',
  ExactlyOneRemoteReferenceRequired: 'EXACTLY_ONE_REMOTE_REFERENCE_REQUIRED',
  Invalid: 'INVALID',
  Present: 'PRESENT',
  Taken: 'TAKEN'
} as const;

export type CustomerPaymentMethodRemoteUserErrorCode = typeof CustomerPaymentMethodRemoteUserErrorCode[keyof typeof CustomerPaymentMethodRemoteUserErrorCode];
export const CustomerPaymentMethodRevocationReason = {
  AuthorizeNetGatewayNotEnabled: 'AUTHORIZE_NET_GATEWAY_NOT_ENABLED',
  AuthorizeNetReturnedNoPaymentMethod: 'AUTHORIZE_NET_RETURNED_NO_PAYMENT_METHOD',
  BraintreeApiAuthenticationError: 'BRAINTREE_API_AUTHENTICATION_ERROR',
  BraintreeGatewayNotEnabled: 'BRAINTREE_GATEWAY_NOT_ENABLED',
  BraintreePaymentMethodNotCard: 'BRAINTREE_PAYMENT_METHOD_NOT_CARD',
  BraintreeReturnedNoPaymentMethod: 'BRAINTREE_RETURNED_NO_PAYMENT_METHOD',
  FailedToRetrieveBillingAddress: 'FAILED_TO_RETRIEVE_BILLING_ADDRESS',
  FailedToUpdateCreditCard: 'FAILED_TO_UPDATE_CREDIT_CARD',
  ManuallyRevoked: 'MANUALLY_REVOKED',
  Merged: 'MERGED',
  PaymentMethodVerificationFailed: 'PAYMENT_METHOD_VERIFICATION_FAILED',
  StripeApiAuthenticationError: 'STRIPE_API_AUTHENTICATION_ERROR',
  StripeApiInvalidRequestError: 'STRIPE_API_INVALID_REQUEST_ERROR',
  StripeGatewayNotEnabled: 'STRIPE_GATEWAY_NOT_ENABLED',
  StripePaymentMethodNotCard: 'STRIPE_PAYMENT_METHOD_NOT_CARD',
  StripeReturnedNoPaymentMethod: 'STRIPE_RETURNED_NO_PAYMENT_METHOD',
  ThreeDSecureFlowInVerificationNotImplemented: 'THREE_D_SECURE_FLOW_IN_VERIFICATION_NOT_IMPLEMENTED'
} as const;

export type CustomerPaymentMethodRevocationReason = typeof CustomerPaymentMethodRevocationReason[keyof typeof CustomerPaymentMethodRevocationReason];
export type CustomerPaymentMethodRevokePayload = {
  revokedCustomerPaymentMethodId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<UserError>;
};

export type CustomerPaymentMethodSendUpdateEmailPayload = {
  customer?: Maybe<Customer>;
  userErrors: Array<UserError>;
};

export type CustomerPaymentMethodUserError = DisplayableError & {
  code?: Maybe<CustomerPaymentMethodUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CustomerPaymentMethodUserErrorCode = {
  Invalid: 'INVALID',
  Present: 'PRESENT',
  Taken: 'TAKEN'
} as const;

export type CustomerPaymentMethodUserErrorCode = typeof CustomerPaymentMethodUserErrorCode[keyof typeof CustomerPaymentMethodUserErrorCode];
export type CustomerPaypalBillingAgreement = {
  billingAddress?: Maybe<CustomerPaymentInstrumentBillingAddress>;
  inactive: Scalars['Boolean']['output'];
  isRevocable: Scalars['Boolean']['output'];
  paypalAccountEmail?: Maybe<Scalars['String']['output']>;
};

export type CustomerPhoneNumber = {
  marketingState: CustomerSmsMarketingState;
  phoneNumber: Scalars['String']['output'];
};

export const CustomerPredictedSpendTier = {
  High: 'HIGH',
  Low: 'LOW',
  Medium: 'MEDIUM'
} as const;

export type CustomerPredictedSpendTier = typeof CustomerPredictedSpendTier[keyof typeof CustomerPredictedSpendTier];
export const CustomerProductSubscriberStatus = {
  Active: 'ACTIVE',
  Cancelled: 'CANCELLED',
  Expired: 'EXPIRED',
  Failed: 'FAILED',
  NeverSubscribed: 'NEVER_SUBSCRIBED',
  Paused: 'PAUSED'
} as const;

export type CustomerProductSubscriberStatus = typeof CustomerProductSubscriberStatus[keyof typeof CustomerProductSubscriberStatus];
export type CustomerRemoveTaxExemptionsPayload = {
  customer?: Maybe<Customer>;
  userErrors: Array<UserError>;
};

export type CustomerReplaceTaxExemptionsPayload = {
  customer?: Maybe<Customer>;
  userErrors: Array<UserError>;
};

export const CustomerRequestDataErasureErrorCode = {
  DoesNotExist: 'DOES_NOT_EXIST',
  FailedToRequest: 'FAILED_TO_REQUEST'
} as const;

export type CustomerRequestDataErasureErrorCode = typeof CustomerRequestDataErasureErrorCode[keyof typeof CustomerRequestDataErasureErrorCode];
export type CustomerRequestDataErasurePayload = {
  customerId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<CustomerRequestDataErasureUserError>;
};

export type CustomerRequestDataErasureUserError = DisplayableError & {
  code?: Maybe<CustomerRequestDataErasureErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CustomerSavedSearchSortKeys = {
  Id: 'ID',
  Name: 'NAME',
  Relevance: 'RELEVANCE'
} as const;

export type CustomerSavedSearchSortKeys = typeof CustomerSavedSearchSortKeys[keyof typeof CustomerSavedSearchSortKeys];
export type CustomerSegmentMember = HasMetafields & {
  amountSpent?: Maybe<MoneyV2>;
  defaultAddress?: Maybe<MailingAddress>;
  defaultEmailAddress?: Maybe<CustomerEmailAddress>;
  defaultPhoneNumber?: Maybe<CustomerPhoneNumber>;
  displayName: Scalars['String']['output'];
  firstName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  lastOrderId?: Maybe<Scalars['ID']['output']>;
  mergeable: CustomerMergeable;
  metafield?: Maybe<Metafield>;
  metafields: MetafieldConnection;
  note?: Maybe<Scalars['String']['output']>;
  numberOfOrders?: Maybe<Scalars['UnsignedInt64']['output']>;
};


export type CustomerSegmentMemberMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type CustomerSegmentMemberMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CustomerSegmentMemberConnection = {
  edges: Array<CustomerSegmentMemberEdge>;
  pageInfo: PageInfo;
  statistics: SegmentStatistics;
  totalCount: Scalars['Int']['output'];
};

export type CustomerSegmentMemberEdge = {
  cursor: Scalars['String']['output'];
  node: CustomerSegmentMember;
};

export type CustomerSegmentMembersQuery = JobResult & Node & {
  currentCount: Scalars['Int']['output'];
  done: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
};

export type CustomerSegmentMembersQueryCreatePayload = {
  customerSegmentMembersQuery?: Maybe<CustomerSegmentMembersQuery>;
  userErrors: Array<CustomerSegmentMembersQueryUserError>;
};

export type CustomerSegmentMembersQueryInput = {
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  segmentId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerSegmentMembersQueryUserError = DisplayableError & {
  code?: Maybe<CustomerSegmentMembersQueryUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CustomerSegmentMembersQueryUserErrorCode = {
  Invalid: 'INVALID'
} as const;

export type CustomerSegmentMembersQueryUserErrorCode = typeof CustomerSegmentMembersQueryUserErrorCode[keyof typeof CustomerSegmentMembersQueryUserErrorCode];
export type CustomerSendAccountInviteEmailPayload = {
  customer?: Maybe<Customer>;
  userErrors: Array<CustomerSendAccountInviteEmailUserError>;
};

export type CustomerSendAccountInviteEmailUserError = DisplayableError & {
  code?: Maybe<CustomerSendAccountInviteEmailUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CustomerSendAccountInviteEmailUserErrorCode = {
  Invalid: 'INVALID'
} as const;

export type CustomerSendAccountInviteEmailUserErrorCode = typeof CustomerSendAccountInviteEmailUserErrorCode[keyof typeof CustomerSendAccountInviteEmailUserErrorCode];
export type CustomerShopPayAgreement = {
  billingAddress?: Maybe<CustomerCreditCardBillingAddress>;
  expiresSoon: Scalars['Boolean']['output'];
  expiryMonth: Scalars['Int']['output'];
  expiryYear: Scalars['Int']['output'];
  inactive: Scalars['Boolean']['output'];
  isRevocable: Scalars['Boolean']['output'];
  lastDigits: Scalars['String']['output'];
  maskedNumber: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export type CustomerSmsMarketingConsentError = DisplayableError & {
  code?: Maybe<CustomerSmsMarketingConsentErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const CustomerSmsMarketingConsentErrorCode = {
  Inclusion: 'INCLUSION',
  InternalError: 'INTERNAL_ERROR',
  Invalid: 'INVALID',
  MissingArgument: 'MISSING_ARGUMENT'
} as const;

export type CustomerSmsMarketingConsentErrorCode = typeof CustomerSmsMarketingConsentErrorCode[keyof typeof CustomerSmsMarketingConsentErrorCode];
export type CustomerSmsMarketingConsentInput = {
  consentUpdatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  marketingOptInLevel?: InputMaybe<CustomerMarketingOptInLevel>;
  marketingState: CustomerSmsMarketingState;
};

export type CustomerSmsMarketingConsentState = {
  consentCollectedFrom?: Maybe<CustomerConsentCollectedFrom>;
  consentUpdatedAt?: Maybe<Scalars['DateTime']['output']>;
  marketingOptInLevel: CustomerMarketingOptInLevel;
  marketingState: CustomerSmsMarketingState;
};

export type CustomerSmsMarketingConsentUpdateInput = {
  customerId: Scalars['ID']['input'];
  smsMarketingConsent: CustomerSmsMarketingConsentInput;
};

export type CustomerSmsMarketingConsentUpdatePayload = {
  customer?: Maybe<Customer>;
  userErrors: Array<CustomerSmsMarketingConsentError>;
};

export const CustomerSmsMarketingState = {
  NotSubscribed: 'NOT_SUBSCRIBED',
  Pending: 'PENDING',
  Redacted: 'REDACTED',
  Subscribed: 'SUBSCRIBED',
  Unsubscribed: 'UNSUBSCRIBED'
} as const;

export type CustomerSmsMarketingState = typeof CustomerSmsMarketingState[keyof typeof CustomerSmsMarketingState];
export const CustomerSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Location: 'LOCATION',
  Name: 'NAME',
  Relevance: 'RELEVANCE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type CustomerSortKeys = typeof CustomerSortKeys[keyof typeof CustomerSortKeys];
export const CustomerState = {
  Declined: 'DECLINED',
  Disabled: 'DISABLED',
  Enabled: 'ENABLED',
  Invited: 'INVITED'
} as const;

export type CustomerState = typeof CustomerState[keyof typeof CustomerState];
export type CustomerStatistics = {
  predictedSpendTier?: Maybe<CustomerPredictedSpendTier>;
};

export type CustomerUpdateDefaultAddressPayload = {
  customer?: Maybe<Customer>;
  userErrors: Array<UserError>;
};

export type CustomerUpdatePayload = {
  customer?: Maybe<Customer>;
  userErrors: Array<UserError>;
};

export type CustomerVisit = CustomerMoment & Node & {
  id: Scalars['ID']['output'];
  landingPage?: Maybe<Scalars['URL']['output']>;
  landingPageHtml?: Maybe<Scalars['HTML']['output']>;
  marketingEvent?: Maybe<MarketingEvent>;
  occurredAt: Scalars['DateTime']['output'];
  referralCode?: Maybe<Scalars['String']['output']>;
  referralInfoHtml: Scalars['FormattedString']['output'];
  referrerUrl?: Maybe<Scalars['URL']['output']>;
  source: Scalars['String']['output'];
  sourceDescription?: Maybe<Scalars['String']['output']>;
  sourceType?: Maybe<MarketingTactic>;
  utmParameters?: Maybe<UtmParameters>;
};

export type CustomerVisitProductInfo = {
  product?: Maybe<Product>;
  quantity: Scalars['Int']['output'];
  variant?: Maybe<ProductVariant>;
};

export type CustomerVisitProductInfoConnection = {
  edges: Array<CustomerVisitProductInfoEdge>;
  nodes: Array<CustomerVisitProductInfo>;
  pageInfo: PageInfo;
};

export type CustomerVisitProductInfoEdge = {
  cursor: Scalars['String']['output'];
  node: CustomerVisitProductInfo;
};

export type DataSaleOptOutPayload = {
  customerId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<DataSaleOptOutUserError>;
};

export type DataSaleOptOutUserError = DisplayableError & {
  code?: Maybe<DataSaleOptOutUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const DataSaleOptOutUserErrorCode = {
  Failed: 'FAILED'
} as const;

export type DataSaleOptOutUserErrorCode = typeof DataSaleOptOutUserErrorCode[keyof typeof DataSaleOptOutUserErrorCode];
export const DayOfTheWeek = {
  Friday: 'FRIDAY',
  Monday: 'MONDAY',
  Saturday: 'SATURDAY',
  Sunday: 'SUNDAY',
  Thursday: 'THURSDAY',
  Tuesday: 'TUESDAY',
  Wednesday: 'WEDNESDAY'
} as const;

export type DayOfTheWeek = typeof DayOfTheWeek[keyof typeof DayOfTheWeek];
export type DelegateAccessToken = {
  accessScopes: Array<Scalars['String']['output']>;
  accessToken: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
};

export type DelegateAccessTokenCreatePayload = {
  delegateAccessToken?: Maybe<DelegateAccessToken>;
  shop: Shop;
  userErrors: Array<DelegateAccessTokenCreateUserError>;
};

export type DelegateAccessTokenCreateUserError = DisplayableError & {
  code?: Maybe<DelegateAccessTokenCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const DelegateAccessTokenCreateUserErrorCode = {
  DelegateAccessToken: 'DELEGATE_ACCESS_TOKEN',
  EmptyAccessScope: 'EMPTY_ACCESS_SCOPE',
  ExpiresAfterParent: 'EXPIRES_AFTER_PARENT',
  NegativeExpiresIn: 'NEGATIVE_EXPIRES_IN',
  PersistenceFailed: 'PERSISTENCE_FAILED',
  RefreshToken: 'REFRESH_TOKEN',
  UnknownScopes: 'UNKNOWN_SCOPES'
} as const;

export type DelegateAccessTokenCreateUserErrorCode = typeof DelegateAccessTokenCreateUserErrorCode[keyof typeof DelegateAccessTokenCreateUserErrorCode];
export type DelegateAccessTokenDestroyPayload = {
  shop: Shop;
  status?: Maybe<Scalars['Boolean']['output']>;
  userErrors: Array<DelegateAccessTokenDestroyUserError>;
};

export type DelegateAccessTokenDestroyUserError = DisplayableError & {
  code?: Maybe<DelegateAccessTokenDestroyUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const DelegateAccessTokenDestroyUserErrorCode = {
  AccessDenied: 'ACCESS_DENIED',
  AccessTokenNotFound: 'ACCESS_TOKEN_NOT_FOUND',
  CanOnlyDeleteDelegateTokens: 'CAN_ONLY_DELETE_DELEGATE_TOKENS',
  PersistenceFailed: 'PERSISTENCE_FAILED'
} as const;

export type DelegateAccessTokenDestroyUserErrorCode = typeof DelegateAccessTokenDestroyUserErrorCode[keyof typeof DelegateAccessTokenDestroyUserErrorCode];
export type DelegateAccessTokenInput = {
  delegateAccessScope: Array<Scalars['String']['input']>;
  expiresIn?: InputMaybe<Scalars['Int']['input']>;
};

export type DeletionEvent = {
  occurredAt: Scalars['DateTime']['output'];
  subjectId: Scalars['ID']['output'];
  subjectType: DeletionEventSubjectType;
};

export type DeletionEventConnection = {
  edges: Array<DeletionEventEdge>;
  nodes: Array<DeletionEvent>;
  pageInfo: PageInfo;
};

export type DeletionEventEdge = {
  cursor: Scalars['String']['output'];
  node: DeletionEvent;
};

export const DeletionEventSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type DeletionEventSortKeys = typeof DeletionEventSortKeys[keyof typeof DeletionEventSortKeys];
export const DeletionEventSubjectType = {
  Collection: 'COLLECTION',
  Product: 'PRODUCT'
} as const;

export type DeletionEventSubjectType = typeof DeletionEventSubjectType[keyof typeof DeletionEventSubjectType];
export type DeliveryAvailableService = {
  countries: DeliveryCountryCodesOrRestOfWorld;
  name: Scalars['String']['output'];
};

export type DeliveryBrandedPromise = {
  handle: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export type DeliveryCarrierService = Node & {
  active: Scalars['Boolean']['output'];
  availableServicesForCountries: Array<DeliveryAvailableService>;
  callbackUrl?: Maybe<Scalars['URL']['output']>;
  formattedName?: Maybe<Scalars['String']['output']>;
  icon: Image;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
  supportsServiceDiscovery: Scalars['Boolean']['output'];
};


export type DeliveryCarrierServiceAvailableServicesForCountriesArgs = {
  countryCodes?: InputMaybe<Array<CountryCode>>;
  origins?: InputMaybe<Array<Scalars['ID']['input']>>;
  restOfWorld: Scalars['Boolean']['input'];
};

export type DeliveryCarrierServiceAndLocations = {
  carrierService: DeliveryCarrierService;
  locations: Array<Location>;
};

export type DeliveryCarrierServiceConnection = {
  edges: Array<DeliveryCarrierServiceEdge>;
  nodes: Array<DeliveryCarrierService>;
  pageInfo: PageInfo;
};

export type DeliveryCarrierServiceCreateInput = {
  active: Scalars['Boolean']['input'];
  callbackUrl: Scalars['URL']['input'];
  name: Scalars['String']['input'];
  supportsServiceDiscovery: Scalars['Boolean']['input'];
};

export type DeliveryCarrierServiceEdge = {
  cursor: Scalars['String']['output'];
  node: DeliveryCarrierService;
};

export type DeliveryCarrierServiceUpdateInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  callbackUrl?: InputMaybe<Scalars['URL']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  supportsServiceDiscovery?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DeliveryCondition = Node & {
  conditionCriteria: DeliveryConditionCriteria;
  field: DeliveryConditionField;
  id: Scalars['ID']['output'];
  operator: DeliveryConditionOperator;
};

export type DeliveryConditionCriteria = MoneyV2 | Weight;

export const DeliveryConditionField = {
  TotalPrice: 'TOTAL_PRICE',
  TotalWeight: 'TOTAL_WEIGHT'
} as const;

export type DeliveryConditionField = typeof DeliveryConditionField[keyof typeof DeliveryConditionField];
export const DeliveryConditionOperator = {
  GreaterThanOrEqualTo: 'GREATER_THAN_OR_EQUAL_TO',
  LessThanOrEqualTo: 'LESS_THAN_OR_EQUAL_TO'
} as const;

export type DeliveryConditionOperator = typeof DeliveryConditionOperator[keyof typeof DeliveryConditionOperator];
export type DeliveryCountry = Node & {
  code: DeliveryCountryCodeOrRestOfWorld;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  provinces: Array<DeliveryProvince>;
  translatedName: Scalars['String']['output'];
};

export type DeliveryCountryAndZone = {
  country: DeliveryCountry;
  zone: Scalars['String']['output'];
};

export type DeliveryCountryCodeOrRestOfWorld = {
  countryCode?: Maybe<CountryCode>;
  restOfWorld: Scalars['Boolean']['output'];
};

export type DeliveryCountryCodesOrRestOfWorld = {
  countryCodes: Array<CountryCode>;
  restOfWorld: Scalars['Boolean']['output'];
};

export type DeliveryCountryInput = {
  code?: InputMaybe<CountryCode>;
  includeAllProvinces?: InputMaybe<Scalars['Boolean']['input']>;
  provinces?: InputMaybe<Array<DeliveryProvinceInput>>;
  restOfWorld?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DeliveryCustomization = HasMetafieldDefinitions & HasMetafields & Node & {
  enabled: Scalars['Boolean']['output'];
  errorHistory?: Maybe<FunctionsErrorHistory>;
  functionId: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  shopifyFunction: ShopifyFunction;
  title: Scalars['String']['output'];
};


export type DeliveryCustomizationMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type DeliveryCustomizationMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type DeliveryCustomizationMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DeliveryCustomizationActivationPayload = {
  ids?: Maybe<Array<Scalars['String']['output']>>;
  userErrors: Array<DeliveryCustomizationError>;
};

export type DeliveryCustomizationConnection = {
  edges: Array<DeliveryCustomizationEdge>;
  nodes: Array<DeliveryCustomization>;
  pageInfo: PageInfo;
};

export type DeliveryCustomizationCreatePayload = {
  deliveryCustomization?: Maybe<DeliveryCustomization>;
  userErrors: Array<DeliveryCustomizationError>;
};

export type DeliveryCustomizationDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<DeliveryCustomizationError>;
};

export type DeliveryCustomizationEdge = {
  cursor: Scalars['String']['output'];
  node: DeliveryCustomization;
};

export type DeliveryCustomizationError = DisplayableError & {
  code?: Maybe<DeliveryCustomizationErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const DeliveryCustomizationErrorCode = {
  CustomAppFunctionNotEligible: 'CUSTOM_APP_FUNCTION_NOT_ELIGIBLE',
  DeliveryCustomizationFunctionNotEligible: 'DELIVERY_CUSTOMIZATION_FUNCTION_NOT_ELIGIBLE',
  DeliveryCustomizationNotFound: 'DELIVERY_CUSTOMIZATION_NOT_FOUND',
  FunctionDoesNotImplement: 'FUNCTION_DOES_NOT_IMPLEMENT',
  FunctionIdCannotBeChanged: 'FUNCTION_ID_CANNOT_BE_CHANGED',
  FunctionNotFound: 'FUNCTION_NOT_FOUND',
  FunctionPendingDeletion: 'FUNCTION_PENDING_DELETION',
  Invalid: 'INVALID',
  InvalidMetafields: 'INVALID_METAFIELDS',
  MaximumActiveDeliveryCustomizations: 'MAXIMUM_ACTIVE_DELIVERY_CUSTOMIZATIONS',
  RequiredInputField: 'REQUIRED_INPUT_FIELD',
  UnauthorizedAppScope: 'UNAUTHORIZED_APP_SCOPE'
} as const;

export type DeliveryCustomizationErrorCode = typeof DeliveryCustomizationErrorCode[keyof typeof DeliveryCustomizationErrorCode];
export type DeliveryCustomizationInput = {
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  functionId?: InputMaybe<Scalars['String']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type DeliveryCustomizationUpdatePayload = {
  deliveryCustomization?: Maybe<DeliveryCustomization>;
  userErrors: Array<DeliveryCustomizationError>;
};

export type DeliveryLegacyModeBlocked = {
  blocked: Scalars['Boolean']['output'];
  reasons?: Maybe<Array<DeliveryLegacyModeBlockedReason>>;
};

export const DeliveryLegacyModeBlockedReason = {
  MultiLocationDisabled: 'MULTI_LOCATION_DISABLED',
  NoLocationsFulfillingOnlineOrders: 'NO_LOCATIONS_FULFILLING_ONLINE_ORDERS'
} as const;

export type DeliveryLegacyModeBlockedReason = typeof DeliveryLegacyModeBlockedReason[keyof typeof DeliveryLegacyModeBlockedReason];
export type DeliveryLocalPickupSettings = {
  instructions: Scalars['String']['output'];
  pickupTime: DeliveryLocalPickupTime;
};

export const DeliveryLocalPickupTime = {
  FiveOrMoreDays: 'FIVE_OR_MORE_DAYS',
  FourHours: 'FOUR_HOURS',
  OneHour: 'ONE_HOUR',
  TwentyFourHours: 'TWENTY_FOUR_HOURS',
  TwoHours: 'TWO_HOURS',
  TwoToFourDays: 'TWO_TO_FOUR_DAYS'
} as const;

export type DeliveryLocalPickupTime = typeof DeliveryLocalPickupTime[keyof typeof DeliveryLocalPickupTime];
export type DeliveryLocationGroup = Node & {
  id: Scalars['ID']['output'];
  locations: LocationConnection;
  locationsCount?: Maybe<Count>;
};


export type DeliveryLocationGroupLocationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeInactive?: InputMaybe<Scalars['Boolean']['input']>;
  includeLegacy?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<LocationSortKeys>;
};

export type DeliveryLocationGroupZone = {
  methodDefinitionCounts: DeliveryMethodDefinitionCounts;
  methodDefinitions: DeliveryMethodDefinitionConnection;
  zone: DeliveryZone;
};


export type DeliveryLocationGroupZoneMethodDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  eligible?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MethodDefinitionSortKeys>;
  type?: InputMaybe<DeliveryMethodDefinitionType>;
};

export type DeliveryLocationGroupZoneConnection = {
  edges: Array<DeliveryLocationGroupZoneEdge>;
  nodes: Array<DeliveryLocationGroupZone>;
  pageInfo: PageInfo;
};

export type DeliveryLocationGroupZoneEdge = {
  cursor: Scalars['String']['output'];
  node: DeliveryLocationGroupZone;
};

export type DeliveryLocationGroupZoneInput = {
  countries?: InputMaybe<Array<DeliveryCountryInput>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  methodDefinitionsToCreate?: InputMaybe<Array<DeliveryMethodDefinitionInput>>;
  methodDefinitionsToUpdate?: InputMaybe<Array<DeliveryMethodDefinitionInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type DeliveryLocationLocalPickupEnableInput = {
  instructions?: InputMaybe<Scalars['String']['input']>;
  locationId: Scalars['ID']['input'];
  pickupTime: DeliveryLocalPickupTime;
};

export type DeliveryLocationLocalPickupSettingsError = DisplayableError & {
  code?: Maybe<DeliveryLocationLocalPickupSettingsErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const DeliveryLocationLocalPickupSettingsErrorCode = {
  ActiveLocationNotFound: 'ACTIVE_LOCATION_NOT_FOUND',
  GenericError: 'GENERIC_ERROR'
} as const;

export type DeliveryLocationLocalPickupSettingsErrorCode = typeof DeliveryLocationLocalPickupSettingsErrorCode[keyof typeof DeliveryLocationLocalPickupSettingsErrorCode];
export type DeliveryMethod = Node & {
  additionalInformation?: Maybe<DeliveryMethodAdditionalInformation>;
  brandedPromise?: Maybe<DeliveryBrandedPromise>;
  id: Scalars['ID']['output'];
  maxDeliveryDateTime?: Maybe<Scalars['DateTime']['output']>;
  methodType: DeliveryMethodType;
  minDeliveryDateTime?: Maybe<Scalars['DateTime']['output']>;
  presentedName?: Maybe<Scalars['String']['output']>;
  serviceCode?: Maybe<Scalars['String']['output']>;
  sourceReference?: Maybe<Scalars['String']['output']>;
};

export type DeliveryMethodAdditionalInformation = {
  instructions?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
};

export type DeliveryMethodDefinition = Node & {
  active: Scalars['Boolean']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  methodConditions: Array<DeliveryCondition>;
  name: Scalars['String']['output'];
  rateProvider: DeliveryRateProvider;
};

export type DeliveryMethodDefinitionConnection = {
  edges: Array<DeliveryMethodDefinitionEdge>;
  nodes: Array<DeliveryMethodDefinition>;
  pageInfo: PageInfo;
};

export type DeliveryMethodDefinitionCounts = {
  participantDefinitionsCount: Scalars['Int']['output'];
  rateDefinitionsCount: Scalars['Int']['output'];
};

export type DeliveryMethodDefinitionEdge = {
  cursor: Scalars['String']['output'];
  node: DeliveryMethodDefinition;
};

export type DeliveryMethodDefinitionInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  conditionsToUpdate?: InputMaybe<Array<DeliveryUpdateConditionInput>>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  participant?: InputMaybe<DeliveryParticipantInput>;
  priceConditionsToCreate?: InputMaybe<Array<DeliveryPriceConditionInput>>;
  rateDefinition?: InputMaybe<DeliveryRateDefinitionInput>;
  weightConditionsToCreate?: InputMaybe<Array<DeliveryWeightConditionInput>>;
};

export const DeliveryMethodDefinitionType = {
  Merchant: 'MERCHANT',
  Participant: 'PARTICIPANT'
} as const;

export type DeliveryMethodDefinitionType = typeof DeliveryMethodDefinitionType[keyof typeof DeliveryMethodDefinitionType];
export const DeliveryMethodType = {
  Local: 'LOCAL',
  None: 'NONE',
  PickupPoint: 'PICKUP_POINT',
  PickUp: 'PICK_UP',
  Retail: 'RETAIL',
  Shipping: 'SHIPPING'
} as const;

export type DeliveryMethodType = typeof DeliveryMethodType[keyof typeof DeliveryMethodType];
export type DeliveryParticipant = Node & {
  adaptToNewServicesFlag: Scalars['Boolean']['output'];
  carrierService: DeliveryCarrierService;
  fixedFee?: Maybe<MoneyV2>;
  id: Scalars['ID']['output'];
  participantServices: Array<DeliveryParticipantService>;
  percentageOfRateFee: Scalars['Float']['output'];
};

export type DeliveryParticipantInput = {
  adaptToNewServices?: InputMaybe<Scalars['Boolean']['input']>;
  carrierServiceId?: InputMaybe<Scalars['ID']['input']>;
  fixedFee?: InputMaybe<MoneyInput>;
  id?: InputMaybe<Scalars['ID']['input']>;
  participantServices?: InputMaybe<Array<DeliveryParticipantServiceInput>>;
  percentageOfRateFee?: InputMaybe<Scalars['Float']['input']>;
};

export type DeliveryParticipantService = {
  active: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
};

export type DeliveryParticipantServiceInput = {
  active: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
};

export type DeliveryPriceConditionInput = {
  criteria?: InputMaybe<MoneyInput>;
  operator?: InputMaybe<DeliveryConditionOperator>;
};

export type DeliveryProductVariantsCount = {
  capped: Scalars['Boolean']['output'];
  count: Scalars['Int']['output'];
};

export type DeliveryProfile = Node & {
  activeMethodDefinitionsCount: Scalars['Int']['output'];
  default: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  legacyMode: Scalars['Boolean']['output'];
  locationsWithoutRatesCount: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  originLocationCount: Scalars['Int']['output'];
  productVariantsCount?: Maybe<Count>;
  /** @deprecated Use `productVariantsCount` instead. */
  productVariantsCountV2: DeliveryProductVariantsCount;
  profileItems: DeliveryProfileItemConnection;
  profileLocationGroups: Array<DeliveryProfileLocationGroup>;
  sellingPlanGroups: SellingPlanGroupConnection;
  unassignedLocations: Array<Location>;
  unassignedLocationsPaginated: LocationConnection;
  zoneCountryCount: Scalars['Int']['output'];
};


export type DeliveryProfileProfileItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type DeliveryProfileProfileLocationGroupsArgs = {
  locationGroupId?: InputMaybe<Scalars['ID']['input']>;
};


export type DeliveryProfileSellingPlanGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type DeliveryProfileUnassignedLocationsPaginatedArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DeliveryProfileConnection = {
  edges: Array<DeliveryProfileEdge>;
  nodes: Array<DeliveryProfile>;
  pageInfo: PageInfo;
};

export type DeliveryProfileCreatePayload = {
  profile?: Maybe<DeliveryProfile>;
  userErrors: Array<UserError>;
};

export type DeliveryProfileEdge = {
  cursor: Scalars['String']['output'];
  node: DeliveryProfile;
};

export type DeliveryProfileInput = {
  conditionsToDelete?: InputMaybe<Array<Scalars['ID']['input']>>;
  locationGroupsToCreate?: InputMaybe<Array<DeliveryProfileLocationGroupInput>>;
  locationGroupsToDelete?: InputMaybe<Array<Scalars['ID']['input']>>;
  locationGroupsToUpdate?: InputMaybe<Array<DeliveryProfileLocationGroupInput>>;
  methodDefinitionsToDelete?: InputMaybe<Array<Scalars['ID']['input']>>;
  name?: InputMaybe<Scalars['String']['input']>;
  profileLocationGroups?: InputMaybe<Array<DeliveryProfileLocationGroupInput>>;
  sellingPlanGroupsToAssociate?: InputMaybe<Array<Scalars['ID']['input']>>;
  sellingPlanGroupsToDissociate?: InputMaybe<Array<Scalars['ID']['input']>>;
  variantsToAssociate?: InputMaybe<Array<Scalars['ID']['input']>>;
  variantsToDissociate?: InputMaybe<Array<Scalars['ID']['input']>>;
  zonesToDelete?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type DeliveryProfileItem = Node & {
  id: Scalars['ID']['output'];
  product: Product;
  variants: ProductVariantConnection;
};


export type DeliveryProfileItemVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DeliveryProfileItemConnection = {
  edges: Array<DeliveryProfileItemEdge>;
  nodes: Array<DeliveryProfileItem>;
  pageInfo: PageInfo;
};

export type DeliveryProfileItemEdge = {
  cursor: Scalars['String']['output'];
  node: DeliveryProfileItem;
};

export type DeliveryProfileLocationGroup = {
  countriesInAnyZone: Array<DeliveryCountryAndZone>;
  locationGroup: DeliveryLocationGroup;
  locationGroupZones: DeliveryLocationGroupZoneConnection;
};


export type DeliveryProfileLocationGroupLocationGroupZonesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DeliveryProfileLocationGroupInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  locations?: InputMaybe<Array<Scalars['ID']['input']>>;
  locationsToAdd?: InputMaybe<Array<Scalars['ID']['input']>>;
  locationsToRemove?: InputMaybe<Array<Scalars['ID']['input']>>;
  zonesToCreate?: InputMaybe<Array<DeliveryLocationGroupZoneInput>>;
  zonesToUpdate?: InputMaybe<Array<DeliveryLocationGroupZoneInput>>;
};

export type DeliveryProfileRemovePayload = {
  job?: Maybe<Job>;
  userErrors: Array<UserError>;
};

export type DeliveryProfileUpdatePayload = {
  profile?: Maybe<DeliveryProfile>;
  userErrors: Array<UserError>;
};

export type DeliveryPromiseParticipant = Node & {
  id: Scalars['ID']['output'];
  owner?: Maybe<DeliveryPromiseParticipantOwner>;
  ownerType: DeliveryPromiseParticipantOwnerType;
};

export type DeliveryPromiseParticipantConnection = {
  edges: Array<DeliveryPromiseParticipantEdge>;
  nodes: Array<DeliveryPromiseParticipant>;
  pageInfo: PageInfo;
};

export type DeliveryPromiseParticipantEdge = {
  cursor: Scalars['String']['output'];
  node: DeliveryPromiseParticipant;
};

export type DeliveryPromiseParticipantOwner = ProductVariant;

export const DeliveryPromiseParticipantOwnerType = {
  Productvariant: 'PRODUCTVARIANT'
} as const;

export type DeliveryPromiseParticipantOwnerType = typeof DeliveryPromiseParticipantOwnerType[keyof typeof DeliveryPromiseParticipantOwnerType];
export type DeliveryPromiseParticipantsUpdatePayload = {
  promiseParticipants?: Maybe<Array<DeliveryPromiseParticipant>>;
  userErrors: Array<UserError>;
};

export type DeliveryPromiseProvider = Node & {
  active: Scalars['Boolean']['output'];
  fulfillmentDelay?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  location: Location;
  timeZone: Scalars['String']['output'];
};

export type DeliveryPromiseProviderUpsertPayload = {
  deliveryPromiseProvider?: Maybe<DeliveryPromiseProvider>;
  userErrors: Array<DeliveryPromiseProviderUpsertUserError>;
};

export type DeliveryPromiseProviderUpsertUserError = DisplayableError & {
  code?: Maybe<DeliveryPromiseProviderUpsertUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const DeliveryPromiseProviderUpsertUserErrorCode = {
  InvalidTimeZone: 'INVALID_TIME_ZONE',
  MustBelongToApp: 'MUST_BELONG_TO_APP',
  NotFound: 'NOT_FOUND',
  TooLong: 'TOO_LONG'
} as const;

export type DeliveryPromiseProviderUpsertUserErrorCode = typeof DeliveryPromiseProviderUpsertUserErrorCode[keyof typeof DeliveryPromiseProviderUpsertUserErrorCode];
export type DeliveryPromiseSetting = {
  deliveryDatesEnabled: Scalars['Boolean']['output'];
  processingTime?: Maybe<Scalars['String']['output']>;
};

export type DeliveryProvince = Node & {
  code: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  translatedName: Scalars['String']['output'];
};

export type DeliveryProvinceInput = {
  code: Scalars['String']['input'];
};

export type DeliveryRateDefinition = Node & {
  id: Scalars['ID']['output'];
  price: MoneyV2;
};

export type DeliveryRateDefinitionInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  price: MoneyInput;
};

export type DeliveryRateProvider = DeliveryParticipant | DeliveryRateDefinition;

export type DeliverySetting = {
  legacyModeBlocked: DeliveryLegacyModeBlocked;
  legacyModeProfiles: Scalars['Boolean']['output'];
};

export type DeliverySettingInput = {
  legacyModeProfiles?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DeliverySettingUpdatePayload = {
  setting?: Maybe<DeliverySetting>;
  userErrors: Array<UserError>;
};

export type DeliveryShippingOriginAssignPayload = {
  userErrors: Array<UserError>;
};

export type DeliveryUpdateConditionInput = {
  criteria?: InputMaybe<Scalars['Float']['input']>;
  criteriaUnit?: InputMaybe<Scalars['String']['input']>;
  field?: InputMaybe<DeliveryConditionField>;
  id: Scalars['ID']['input'];
  operator?: InputMaybe<DeliveryConditionOperator>;
};

export type DeliveryWeightConditionInput = {
  criteria?: InputMaybe<WeightInput>;
  operator?: InputMaybe<DeliveryConditionOperator>;
};

export type DeliveryZone = Node & {
  countries: Array<DeliveryCountry>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type DepositConfiguration = DepositPercentage;

export type DepositInput = {
  percentage: Scalars['Float']['input'];
};

export type DepositPercentage = {
  percentage: Scalars['Float']['output'];
};

export const DigitalWallet = {
  AndroidPay: 'ANDROID_PAY',
  ApplePay: 'APPLE_PAY',
  GooglePay: 'GOOGLE_PAY',
  ShopifyPay: 'SHOPIFY_PAY'
} as const;

export type DigitalWallet = typeof DigitalWallet[keyof typeof DigitalWallet];
export type Discount = DiscountAutomaticApp | DiscountAutomaticBasic | DiscountAutomaticBxgy | DiscountAutomaticFreeShipping | DiscountCodeApp | DiscountCodeBasic | DiscountCodeBxgy | DiscountCodeFreeShipping;

export type DiscountAllocation = {
  /** @deprecated Use `allocatedAmountSet` instead. */
  allocatedAmount: MoneyV2;
  allocatedAmountSet: MoneyBag;
  discountApplication: DiscountApplication;
};

export type DiscountAllocationConnection = {
  edges: Array<DiscountAllocationEdge>;
  nodes: Array<DiscountAllocation>;
  pageInfo: PageInfo;
};

export type DiscountAllocationEdge = {
  cursor: Scalars['String']['output'];
  node: DiscountAllocation;
};

export type DiscountAmount = {
  amount: MoneyV2;
  appliesOnEachItem: Scalars['Boolean']['output'];
};

export type DiscountAmountInput = {
  amount?: InputMaybe<Scalars['Decimal']['input']>;
  appliesOnEachItem?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DiscountApplication = {
  allocationMethod: DiscountApplicationAllocationMethod;
  index: Scalars['Int']['output'];
  targetSelection: DiscountApplicationTargetSelection;
  targetType: DiscountApplicationTargetType;
  value: PricingValue;
};

export const DiscountApplicationAllocationMethod = {
  Across: 'ACROSS',
  Each: 'EACH',
  One: 'ONE'
} as const;

export type DiscountApplicationAllocationMethod = typeof DiscountApplicationAllocationMethod[keyof typeof DiscountApplicationAllocationMethod];
export type DiscountApplicationConnection = {
  edges: Array<DiscountApplicationEdge>;
  nodes: Array<DiscountApplication>;
  pageInfo: PageInfo;
};

export type DiscountApplicationEdge = {
  cursor: Scalars['String']['output'];
  node: DiscountApplication;
};

export const DiscountApplicationLevel = {
  Line: 'LINE',
  Order: 'ORDER'
} as const;

export type DiscountApplicationLevel = typeof DiscountApplicationLevel[keyof typeof DiscountApplicationLevel];
export const DiscountApplicationTargetSelection = {
  All: 'ALL',
  Entitled: 'ENTITLED',
  Explicit: 'EXPLICIT'
} as const;

export type DiscountApplicationTargetSelection = typeof DiscountApplicationTargetSelection[keyof typeof DiscountApplicationTargetSelection];
export const DiscountApplicationTargetType = {
  LineItem: 'LINE_ITEM',
  ShippingLine: 'SHIPPING_LINE'
} as const;

export type DiscountApplicationTargetType = typeof DiscountApplicationTargetType[keyof typeof DiscountApplicationTargetType];
export type DiscountAutomatic = DiscountAutomaticApp | DiscountAutomaticBasic | DiscountAutomaticBxgy | DiscountAutomaticFreeShipping;

export type DiscountAutomaticActivatePayload = {
  automaticDiscountNode?: Maybe<DiscountAutomaticNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountAutomaticApp = {
  appDiscountType: AppDiscountType;
  appliesOnOneTimePurchase: Scalars['Boolean']['output'];
  appliesOnSubscription: Scalars['Boolean']['output'];
  asyncUsageCount: Scalars['Int']['output'];
  combinesWith: DiscountCombinesWith;
  createdAt: Scalars['DateTime']['output'];
  discountClass: DiscountClass;
  discountId: Scalars['ID']['output'];
  endsAt?: Maybe<Scalars['DateTime']['output']>;
  errorHistory?: Maybe<FunctionsErrorHistory>;
  recurringCycleLimit: Scalars['Int']['output'];
  startsAt: Scalars['DateTime']['output'];
  status: DiscountStatus;
  title: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type DiscountAutomaticAppCreatePayload = {
  automaticAppDiscount?: Maybe<DiscountAutomaticApp>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountAutomaticAppInput = {
  appliesOnOneTimePurchase?: InputMaybe<Scalars['Boolean']['input']>;
  appliesOnSubscription?: InputMaybe<Scalars['Boolean']['input']>;
  combinesWith?: InputMaybe<DiscountCombinesWithInput>;
  endsAt?: InputMaybe<Scalars['DateTime']['input']>;
  functionId?: InputMaybe<Scalars['String']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  recurringCycleLimit?: InputMaybe<Scalars['Int']['input']>;
  startsAt?: InputMaybe<Scalars['DateTime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type DiscountAutomaticAppUpdatePayload = {
  automaticAppDiscount?: Maybe<DiscountAutomaticApp>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountAutomaticBasic = {
  asyncUsageCount: Scalars['Int']['output'];
  combinesWith: DiscountCombinesWith;
  createdAt: Scalars['DateTime']['output'];
  customerGets: DiscountCustomerGets;
  discountClass: MerchandiseDiscountClass;
  endsAt?: Maybe<Scalars['DateTime']['output']>;
  minimumRequirement?: Maybe<DiscountMinimumRequirement>;
  recurringCycleLimit: Scalars['Int']['output'];
  shortSummary: Scalars['String']['output'];
  startsAt: Scalars['DateTime']['output'];
  status: DiscountStatus;
  summary: Scalars['String']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  /** @deprecated Use `asyncUsageCount` instead. */
  usageCount: Scalars['Int']['output'];
};

export type DiscountAutomaticBasicCreatePayload = {
  automaticDiscountNode?: Maybe<DiscountAutomaticNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountAutomaticBasicInput = {
  combinesWith?: InputMaybe<DiscountCombinesWithInput>;
  customerGets?: InputMaybe<DiscountCustomerGetsInput>;
  endsAt?: InputMaybe<Scalars['DateTime']['input']>;
  minimumRequirement?: InputMaybe<DiscountMinimumRequirementInput>;
  recurringCycleLimit?: InputMaybe<Scalars['Int']['input']>;
  startsAt?: InputMaybe<Scalars['DateTime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type DiscountAutomaticBasicUpdatePayload = {
  automaticDiscountNode?: Maybe<DiscountAutomaticNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountAutomaticBulkDeletePayload = {
  job?: Maybe<Job>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountAutomaticBxgy = HasEvents & Node & {
  asyncUsageCount: Scalars['Int']['output'];
  combinesWith: DiscountCombinesWith;
  createdAt: Scalars['DateTime']['output'];
  customerBuys: DiscountCustomerBuys;
  customerGets: DiscountCustomerGets;
  discountClass: MerchandiseDiscountClass;
  endsAt?: Maybe<Scalars['DateTime']['output']>;
  events: EventConnection;
  /** @deprecated Use DiscountAutomaticNode.id instead. */
  id: Scalars['ID']['output'];
  startsAt: Scalars['DateTime']['output'];
  status: DiscountStatus;
  summary: Scalars['String']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  /** @deprecated Use `asyncUsageCount` instead. */
  usageCount: Scalars['Int']['output'];
  usesPerOrderLimit?: Maybe<Scalars['Int']['output']>;
};


export type DiscountAutomaticBxgyEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};

export type DiscountAutomaticBxgyCreatePayload = {
  automaticDiscountNode?: Maybe<DiscountAutomaticNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountAutomaticBxgyInput = {
  combinesWith?: InputMaybe<DiscountCombinesWithInput>;
  customerBuys?: InputMaybe<DiscountCustomerBuysInput>;
  customerGets?: InputMaybe<DiscountCustomerGetsInput>;
  endsAt?: InputMaybe<Scalars['DateTime']['input']>;
  startsAt?: InputMaybe<Scalars['DateTime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  usesPerOrderLimit?: InputMaybe<Scalars['UnsignedInt64']['input']>;
};

export type DiscountAutomaticBxgyUpdatePayload = {
  automaticDiscountNode?: Maybe<DiscountAutomaticNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountAutomaticConnection = {
  edges: Array<DiscountAutomaticEdge>;
  nodes: Array<DiscountAutomatic>;
  pageInfo: PageInfo;
};

export type DiscountAutomaticDeactivatePayload = {
  automaticDiscountNode?: Maybe<DiscountAutomaticNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountAutomaticDeletePayload = {
  deletedAutomaticDiscountId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountAutomaticEdge = {
  cursor: Scalars['String']['output'];
  node: DiscountAutomatic;
};

export type DiscountAutomaticFreeShipping = {
  appliesOnOneTimePurchase: Scalars['Boolean']['output'];
  appliesOnSubscription: Scalars['Boolean']['output'];
  asyncUsageCount: Scalars['Int']['output'];
  combinesWith: DiscountCombinesWith;
  createdAt: Scalars['DateTime']['output'];
  destinationSelection: DiscountShippingDestinationSelection;
  discountClass: ShippingDiscountClass;
  endsAt?: Maybe<Scalars['DateTime']['output']>;
  hasTimelineComment: Scalars['Boolean']['output'];
  maximumShippingPrice?: Maybe<MoneyV2>;
  minimumRequirement?: Maybe<DiscountMinimumRequirement>;
  recurringCycleLimit: Scalars['Int']['output'];
  shortSummary: Scalars['String']['output'];
  startsAt: Scalars['DateTime']['output'];
  status: DiscountStatus;
  summary: Scalars['String']['output'];
  title: Scalars['String']['output'];
  totalSales?: Maybe<MoneyV2>;
  updatedAt: Scalars['DateTime']['output'];
};

export type DiscountAutomaticFreeShippingCreatePayload = {
  automaticDiscountNode?: Maybe<DiscountAutomaticNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountAutomaticFreeShippingInput = {
  appliesOnOneTimePurchase?: InputMaybe<Scalars['Boolean']['input']>;
  appliesOnSubscription?: InputMaybe<Scalars['Boolean']['input']>;
  combinesWith?: InputMaybe<DiscountCombinesWithInput>;
  destination?: InputMaybe<DiscountShippingDestinationSelectionInput>;
  endsAt?: InputMaybe<Scalars['DateTime']['input']>;
  maximumShippingPrice?: InputMaybe<Scalars['Decimal']['input']>;
  minimumRequirement?: InputMaybe<DiscountMinimumRequirementInput>;
  recurringCycleLimit?: InputMaybe<Scalars['Int']['input']>;
  startsAt?: InputMaybe<Scalars['DateTime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type DiscountAutomaticFreeShippingUpdatePayload = {
  automaticDiscountNode?: Maybe<DiscountAutomaticNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountAutomaticNode = HasEvents & HasMetafieldDefinitions & HasMetafields & Node & {
  automaticDiscount: DiscountAutomatic;
  events: EventConnection;
  id: Scalars['ID']['output'];
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
};


export type DiscountAutomaticNodeEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type DiscountAutomaticNodeMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type DiscountAutomaticNodeMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type DiscountAutomaticNodeMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DiscountAutomaticNodeConnection = {
  edges: Array<DiscountAutomaticNodeEdge>;
  nodes: Array<DiscountAutomaticNode>;
  pageInfo: PageInfo;
};

export type DiscountAutomaticNodeEdge = {
  cursor: Scalars['String']['output'];
  node: DiscountAutomaticNode;
};

export const DiscountClass = {
  Order: 'ORDER',
  Product: 'PRODUCT',
  Shipping: 'SHIPPING'
} as const;

export type DiscountClass = typeof DiscountClass[keyof typeof DiscountClass];
export type DiscountCode = DiscountCodeApp | DiscountCodeBasic | DiscountCodeBxgy | DiscountCodeFreeShipping;

export type DiscountCodeActivatePayload = {
  codeDiscountNode?: Maybe<DiscountCodeNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeApp = {
  appDiscountType: AppDiscountType;
  appliesOnOneTimePurchase: Scalars['Boolean']['output'];
  appliesOnSubscription: Scalars['Boolean']['output'];
  appliesOncePerCustomer: Scalars['Boolean']['output'];
  asyncUsageCount: Scalars['Int']['output'];
  codes: DiscountRedeemCodeConnection;
  codesCount?: Maybe<Count>;
  combinesWith: DiscountCombinesWith;
  createdAt: Scalars['DateTime']['output'];
  customerSelection: DiscountCustomerSelection;
  discountClass: DiscountClass;
  discountId: Scalars['ID']['output'];
  endsAt?: Maybe<Scalars['DateTime']['output']>;
  errorHistory?: Maybe<FunctionsErrorHistory>;
  hasTimelineComment: Scalars['Boolean']['output'];
  recurringCycleLimit?: Maybe<Scalars['Int']['output']>;
  shareableUrls: Array<DiscountShareableUrl>;
  startsAt: Scalars['DateTime']['output'];
  status: DiscountStatus;
  title: Scalars['String']['output'];
  totalSales?: Maybe<MoneyV2>;
  updatedAt: Scalars['DateTime']['output'];
  usageLimit?: Maybe<Scalars['Int']['output']>;
};


export type DiscountCodeAppCodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<DiscountCodeSortKeys>;
};

export type DiscountCodeAppCreatePayload = {
  codeAppDiscount?: Maybe<DiscountCodeApp>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeAppInput = {
  appliesOnOneTimePurchase?: InputMaybe<Scalars['Boolean']['input']>;
  appliesOnSubscription?: InputMaybe<Scalars['Boolean']['input']>;
  appliesOncePerCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  combinesWith?: InputMaybe<DiscountCombinesWithInput>;
  customerSelection?: InputMaybe<DiscountCustomerSelectionInput>;
  endsAt?: InputMaybe<Scalars['DateTime']['input']>;
  functionId?: InputMaybe<Scalars['String']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  recurringCycleLimit?: InputMaybe<Scalars['Int']['input']>;
  startsAt?: InputMaybe<Scalars['DateTime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  usageLimit?: InputMaybe<Scalars['Int']['input']>;
};

export type DiscountCodeAppUpdatePayload = {
  codeAppDiscount?: Maybe<DiscountCodeApp>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeApplication = DiscountApplication & {
  allocationMethod: DiscountApplicationAllocationMethod;
  code: Scalars['String']['output'];
  index: Scalars['Int']['output'];
  targetSelection: DiscountApplicationTargetSelection;
  targetType: DiscountApplicationTargetType;
  value: PricingValue;
};

export type DiscountCodeBasic = {
  appliesOncePerCustomer: Scalars['Boolean']['output'];
  asyncUsageCount: Scalars['Int']['output'];
  codes: DiscountRedeemCodeConnection;
  codesCount?: Maybe<Count>;
  combinesWith: DiscountCombinesWith;
  createdAt: Scalars['DateTime']['output'];
  customerGets: DiscountCustomerGets;
  customerSelection: DiscountCustomerSelection;
  discountClass: MerchandiseDiscountClass;
  endsAt?: Maybe<Scalars['DateTime']['output']>;
  hasTimelineComment: Scalars['Boolean']['output'];
  minimumRequirement?: Maybe<DiscountMinimumRequirement>;
  recurringCycleLimit?: Maybe<Scalars['Int']['output']>;
  shareableUrls: Array<DiscountShareableUrl>;
  shortSummary: Scalars['String']['output'];
  startsAt: Scalars['DateTime']['output'];
  status: DiscountStatus;
  summary: Scalars['String']['output'];
  title: Scalars['String']['output'];
  totalSales?: Maybe<MoneyV2>;
  updatedAt: Scalars['DateTime']['output'];
  usageLimit?: Maybe<Scalars['Int']['output']>;
};


export type DiscountCodeBasicCodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<DiscountCodeSortKeys>;
};

export type DiscountCodeBasicCreatePayload = {
  codeDiscountNode?: Maybe<DiscountCodeNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeBasicInput = {
  appliesOncePerCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  combinesWith?: InputMaybe<DiscountCombinesWithInput>;
  customerGets?: InputMaybe<DiscountCustomerGetsInput>;
  customerSelection?: InputMaybe<DiscountCustomerSelectionInput>;
  endsAt?: InputMaybe<Scalars['DateTime']['input']>;
  minimumRequirement?: InputMaybe<DiscountMinimumRequirementInput>;
  recurringCycleLimit?: InputMaybe<Scalars['Int']['input']>;
  startsAt?: InputMaybe<Scalars['DateTime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  usageLimit?: InputMaybe<Scalars['Int']['input']>;
};

export type DiscountCodeBasicUpdatePayload = {
  codeDiscountNode?: Maybe<DiscountCodeNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeBulkActivatePayload = {
  job?: Maybe<Job>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeBulkDeactivatePayload = {
  job?: Maybe<Job>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeBulkDeletePayload = {
  job?: Maybe<Job>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeBxgy = {
  appliesOncePerCustomer: Scalars['Boolean']['output'];
  asyncUsageCount: Scalars['Int']['output'];
  codes: DiscountRedeemCodeConnection;
  codesCount?: Maybe<Count>;
  combinesWith: DiscountCombinesWith;
  createdAt: Scalars['DateTime']['output'];
  customerBuys: DiscountCustomerBuys;
  customerGets: DiscountCustomerGets;
  customerSelection: DiscountCustomerSelection;
  discountClass: MerchandiseDiscountClass;
  endsAt?: Maybe<Scalars['DateTime']['output']>;
  hasTimelineComment: Scalars['Boolean']['output'];
  shareableUrls: Array<DiscountShareableUrl>;
  startsAt: Scalars['DateTime']['output'];
  status: DiscountStatus;
  summary: Scalars['String']['output'];
  title: Scalars['String']['output'];
  totalSales?: Maybe<MoneyV2>;
  updatedAt: Scalars['DateTime']['output'];
  usageLimit?: Maybe<Scalars['Int']['output']>;
  usesPerOrderLimit?: Maybe<Scalars['Int']['output']>;
};


export type DiscountCodeBxgyCodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<DiscountCodeSortKeys>;
};

export type DiscountCodeBxgyCreatePayload = {
  codeDiscountNode?: Maybe<DiscountCodeNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeBxgyInput = {
  appliesOncePerCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  combinesWith?: InputMaybe<DiscountCombinesWithInput>;
  customerBuys?: InputMaybe<DiscountCustomerBuysInput>;
  customerGets?: InputMaybe<DiscountCustomerGetsInput>;
  customerSelection?: InputMaybe<DiscountCustomerSelectionInput>;
  endsAt?: InputMaybe<Scalars['DateTime']['input']>;
  startsAt?: InputMaybe<Scalars['DateTime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  usageLimit?: InputMaybe<Scalars['Int']['input']>;
  usesPerOrderLimit?: InputMaybe<Scalars['Int']['input']>;
};

export type DiscountCodeBxgyUpdatePayload = {
  codeDiscountNode?: Maybe<DiscountCodeNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeDeactivatePayload = {
  codeDiscountNode?: Maybe<DiscountCodeNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeDeletePayload = {
  deletedCodeDiscountId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeFreeShipping = {
  appliesOnOneTimePurchase: Scalars['Boolean']['output'];
  appliesOnSubscription: Scalars['Boolean']['output'];
  appliesOncePerCustomer: Scalars['Boolean']['output'];
  asyncUsageCount: Scalars['Int']['output'];
  codes: DiscountRedeemCodeConnection;
  codesCount?: Maybe<Count>;
  combinesWith: DiscountCombinesWith;
  createdAt: Scalars['DateTime']['output'];
  customerSelection: DiscountCustomerSelection;
  destinationSelection: DiscountShippingDestinationSelection;
  discountClass: ShippingDiscountClass;
  endsAt?: Maybe<Scalars['DateTime']['output']>;
  hasTimelineComment: Scalars['Boolean']['output'];
  maximumShippingPrice?: Maybe<MoneyV2>;
  minimumRequirement?: Maybe<DiscountMinimumRequirement>;
  recurringCycleLimit?: Maybe<Scalars['Int']['output']>;
  shareableUrls: Array<DiscountShareableUrl>;
  shortSummary: Scalars['String']['output'];
  startsAt: Scalars['DateTime']['output'];
  status: DiscountStatus;
  summary: Scalars['String']['output'];
  title: Scalars['String']['output'];
  totalSales?: Maybe<MoneyV2>;
  updatedAt: Scalars['DateTime']['output'];
  usageLimit?: Maybe<Scalars['Int']['output']>;
};


export type DiscountCodeFreeShippingCodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<DiscountCodeSortKeys>;
};

export type DiscountCodeFreeShippingCreatePayload = {
  codeDiscountNode?: Maybe<DiscountCodeNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeFreeShippingInput = {
  appliesOnOneTimePurchase?: InputMaybe<Scalars['Boolean']['input']>;
  appliesOnSubscription?: InputMaybe<Scalars['Boolean']['input']>;
  appliesOncePerCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  combinesWith?: InputMaybe<DiscountCombinesWithInput>;
  customerSelection?: InputMaybe<DiscountCustomerSelectionInput>;
  destination?: InputMaybe<DiscountShippingDestinationSelectionInput>;
  endsAt?: InputMaybe<Scalars['DateTime']['input']>;
  maximumShippingPrice?: InputMaybe<Scalars['Decimal']['input']>;
  minimumRequirement?: InputMaybe<DiscountMinimumRequirementInput>;
  recurringCycleLimit?: InputMaybe<Scalars['Int']['input']>;
  startsAt?: InputMaybe<Scalars['DateTime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  usageLimit?: InputMaybe<Scalars['Int']['input']>;
};

export type DiscountCodeFreeShippingUpdatePayload = {
  codeDiscountNode?: Maybe<DiscountCodeNode>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountCodeNode = HasEvents & HasMetafieldDefinitions & HasMetafields & Node & {
  codeDiscount: DiscountCode;
  events: EventConnection;
  id: Scalars['ID']['output'];
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
};


export type DiscountCodeNodeEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type DiscountCodeNodeMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type DiscountCodeNodeMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type DiscountCodeNodeMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DiscountCodeNodeConnection = {
  edges: Array<DiscountCodeNodeEdge>;
  nodes: Array<DiscountCodeNode>;
  pageInfo: PageInfo;
};

export type DiscountCodeNodeEdge = {
  cursor: Scalars['String']['output'];
  node: DiscountCodeNode;
};

export type DiscountCodeRedeemCodeBulkDeletePayload = {
  job?: Maybe<Job>;
  userErrors: Array<DiscountUserError>;
};

export const DiscountCodeSortKeys = {
  Code: 'CODE',
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type DiscountCodeSortKeys = typeof DiscountCodeSortKeys[keyof typeof DiscountCodeSortKeys];
export type DiscountCollections = {
  collections: CollectionConnection;
};


export type DiscountCollectionsCollectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DiscountCollectionsInput = {
  add?: InputMaybe<Array<Scalars['ID']['input']>>;
  remove?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type DiscountCombinesWith = {
  orderDiscounts: Scalars['Boolean']['output'];
  productDiscounts: Scalars['Boolean']['output'];
  shippingDiscounts: Scalars['Boolean']['output'];
};

export type DiscountCombinesWithInput = {
  orderDiscounts?: InputMaybe<Scalars['Boolean']['input']>;
  productDiscounts?: InputMaybe<Scalars['Boolean']['input']>;
  shippingDiscounts?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DiscountCountries = {
  countries: Array<CountryCode>;
  includeRestOfWorld: Scalars['Boolean']['output'];
};

export type DiscountCountriesInput = {
  add?: InputMaybe<Array<CountryCode>>;
  includeRestOfWorld?: InputMaybe<Scalars['Boolean']['input']>;
  remove?: InputMaybe<Array<CountryCode>>;
};

export type DiscountCountryAll = {
  allCountries: Scalars['Boolean']['output'];
};

export type DiscountCustomerAll = {
  allCustomers: Scalars['Boolean']['output'];
};

export type DiscountCustomerBuys = {
  isOneTimePurchase: Scalars['Boolean']['output'];
  isSubscription: Scalars['Boolean']['output'];
  items: DiscountItems;
  value: DiscountCustomerBuysValue;
};

export type DiscountCustomerBuysInput = {
  isOneTimePurchase?: InputMaybe<Scalars['Boolean']['input']>;
  isSubscription?: InputMaybe<Scalars['Boolean']['input']>;
  items?: InputMaybe<DiscountItemsInput>;
  value?: InputMaybe<DiscountCustomerBuysValueInput>;
};

export type DiscountCustomerBuysValue = DiscountPurchaseAmount | DiscountQuantity;

export type DiscountCustomerBuysValueInput = {
  amount?: InputMaybe<Scalars['Decimal']['input']>;
  quantity?: InputMaybe<Scalars['UnsignedInt64']['input']>;
};

export type DiscountCustomerGets = {
  appliesOnOneTimePurchase: Scalars['Boolean']['output'];
  appliesOnSubscription: Scalars['Boolean']['output'];
  items: DiscountItems;
  value: DiscountCustomerGetsValue;
};

export type DiscountCustomerGetsInput = {
  appliesOnOneTimePurchase?: InputMaybe<Scalars['Boolean']['input']>;
  appliesOnSubscription?: InputMaybe<Scalars['Boolean']['input']>;
  items?: InputMaybe<DiscountItemsInput>;
  value?: InputMaybe<DiscountCustomerGetsValueInput>;
};

export type DiscountCustomerGetsValue = DiscountAmount | DiscountOnQuantity | DiscountPercentage;

export type DiscountCustomerGetsValueInput = {
  discountAmount?: InputMaybe<DiscountAmountInput>;
  discountOnQuantity?: InputMaybe<DiscountOnQuantityInput>;
  percentage?: InputMaybe<Scalars['Float']['input']>;
};

export type DiscountCustomerSegments = {
  segments: Array<Segment>;
};

export type DiscountCustomerSegmentsInput = {
  add?: InputMaybe<Array<Scalars['ID']['input']>>;
  remove?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type DiscountCustomerSelection = DiscountCustomerAll | DiscountCustomerSegments | DiscountCustomers;

export type DiscountCustomerSelectionInput = {
  all?: InputMaybe<Scalars['Boolean']['input']>;
  customerSegments?: InputMaybe<DiscountCustomerSegmentsInput>;
  customers?: InputMaybe<DiscountCustomersInput>;
};

export type DiscountCustomers = {
  customers: Array<Customer>;
};

export type DiscountCustomersInput = {
  add?: InputMaybe<Array<Scalars['ID']['input']>>;
  remove?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type DiscountEffect = DiscountAmount | DiscountPercentage;

export type DiscountEffectInput = {
  amount?: InputMaybe<Scalars['Decimal']['input']>;
  percentage?: InputMaybe<Scalars['Float']['input']>;
};

export const DiscountErrorCode = {
  ActivePeriodOverlap: 'ACTIVE_PERIOD_OVERLAP',
  AppliesOnNothing: 'APPLIES_ON_NOTHING',
  Blank: 'BLANK',
  Conflict: 'CONFLICT',
  Duplicate: 'DUPLICATE',
  EqualTo: 'EQUAL_TO',
  ExceededMax: 'EXCEEDED_MAX',
  GreaterThan: 'GREATER_THAN',
  GreaterThanOrEqualTo: 'GREATER_THAN_OR_EQUAL_TO',
  ImplicitDuplicate: 'IMPLICIT_DUPLICATE',
  Inclusion: 'INCLUSION',
  InternalError: 'INTERNAL_ERROR',
  Invalid: 'INVALID',
  InvalidCombinesWithForDiscountClass: 'INVALID_COMBINES_WITH_FOR_DISCOUNT_CLASS',
  InvalidDiscountClassForPriceRule: 'INVALID_DISCOUNT_CLASS_FOR_PRICE_RULE',
  LessThan: 'LESS_THAN',
  LessThanOrEqualTo: 'LESS_THAN_OR_EQUAL_TO',
  MaxAppDiscounts: 'MAX_APP_DISCOUNTS',
  MinimumSubtotalAndQuantityRangeBothPresent: 'MINIMUM_SUBTOTAL_AND_QUANTITY_RANGE_BOTH_PRESENT',
  MissingArgument: 'MISSING_ARGUMENT',
  MultipleRecurringCycleLimitForNonSubscriptionItems: 'MULTIPLE_RECURRING_CYCLE_LIMIT_FOR_NON_SUBSCRIPTION_ITEMS',
  Present: 'PRESENT',
  RecurringCycleLimitNotAValidInteger: 'RECURRING_CYCLE_LIMIT_NOT_A_VALID_INTEGER',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  TooManyArguments: 'TOO_MANY_ARGUMENTS',
  TooShort: 'TOO_SHORT',
  ValueOutsideRange: 'VALUE_OUTSIDE_RANGE'
} as const;

export type DiscountErrorCode = typeof DiscountErrorCode[keyof typeof DiscountErrorCode];
export type DiscountItems = AllDiscountItems | DiscountCollections | DiscountProducts;

export type DiscountItemsInput = {
  all?: InputMaybe<Scalars['Boolean']['input']>;
  collections?: InputMaybe<DiscountCollectionsInput>;
  products?: InputMaybe<DiscountProductsInput>;
};

export type DiscountMinimumQuantity = {
  greaterThanOrEqualToQuantity: Scalars['UnsignedInt64']['output'];
};

export type DiscountMinimumQuantityInput = {
  greaterThanOrEqualToQuantity?: InputMaybe<Scalars['UnsignedInt64']['input']>;
};

export type DiscountMinimumRequirement = DiscountMinimumQuantity | DiscountMinimumSubtotal;

export type DiscountMinimumRequirementInput = {
  quantity?: InputMaybe<DiscountMinimumQuantityInput>;
  subtotal?: InputMaybe<DiscountMinimumSubtotalInput>;
};

export type DiscountMinimumSubtotal = {
  greaterThanOrEqualToSubtotal: MoneyV2;
};

export type DiscountMinimumSubtotalInput = {
  greaterThanOrEqualToSubtotal?: InputMaybe<Scalars['Decimal']['input']>;
};

export type DiscountNode = HasEvents & HasMetafieldDefinitions & HasMetafields & Node & {
  discount: Discount;
  events: EventConnection;
  id: Scalars['ID']['output'];
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
};


export type DiscountNodeEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type DiscountNodeMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type DiscountNodeMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type DiscountNodeMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DiscountNodeConnection = {
  edges: Array<DiscountNodeEdge>;
  nodes: Array<DiscountNode>;
  pageInfo: PageInfo;
};

export type DiscountNodeEdge = {
  cursor: Scalars['String']['output'];
  node: DiscountNode;
};

export type DiscountOnQuantity = {
  effect: DiscountEffect;
  quantity: DiscountQuantity;
};

export type DiscountOnQuantityInput = {
  effect?: InputMaybe<DiscountEffectInput>;
  quantity?: InputMaybe<Scalars['UnsignedInt64']['input']>;
};

export type DiscountPercentage = {
  percentage: Scalars['Float']['output'];
};

export type DiscountProducts = {
  productVariants: ProductVariantConnection;
  products: ProductConnection;
};


export type DiscountProductsProductVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type DiscountProductsProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DiscountProductsInput = {
  productVariantsToAdd?: InputMaybe<Array<Scalars['ID']['input']>>;
  productVariantsToRemove?: InputMaybe<Array<Scalars['ID']['input']>>;
  productsToAdd?: InputMaybe<Array<Scalars['ID']['input']>>;
  productsToRemove?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type DiscountPurchaseAmount = {
  amount: Scalars['Decimal']['output'];
};

export type DiscountQuantity = {
  quantity: Scalars['UnsignedInt64']['output'];
};

export type DiscountRedeemCode = {
  asyncUsageCount: Scalars['Int']['output'];
  code: Scalars['String']['output'];
  createdBy?: Maybe<App>;
  id: Scalars['ID']['output'];
};

export type DiscountRedeemCodeBulkAddPayload = {
  bulkCreation?: Maybe<DiscountRedeemCodeBulkCreation>;
  userErrors: Array<DiscountUserError>;
};

export type DiscountRedeemCodeBulkCreation = Node & {
  codes: DiscountRedeemCodeBulkCreationCodeConnection;
  codesCount: Scalars['Int']['output'];
  createdAt: Scalars['DateTime']['output'];
  discountCode?: Maybe<DiscountCodeNode>;
  done: Scalars['Boolean']['output'];
  failedCount: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  importedCount: Scalars['Int']['output'];
};


export type DiscountRedeemCodeBulkCreationCodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DiscountRedeemCodeBulkCreationCode = {
  code: Scalars['String']['output'];
  discountRedeemCode?: Maybe<DiscountRedeemCode>;
  errors: Array<DiscountUserError>;
};

export type DiscountRedeemCodeBulkCreationCodeConnection = {
  edges: Array<DiscountRedeemCodeBulkCreationCodeEdge>;
  nodes: Array<DiscountRedeemCodeBulkCreationCode>;
  pageInfo: PageInfo;
};

export type DiscountRedeemCodeBulkCreationCodeEdge = {
  cursor: Scalars['String']['output'];
  node: DiscountRedeemCodeBulkCreationCode;
};

export type DiscountRedeemCodeConnection = {
  edges: Array<DiscountRedeemCodeEdge>;
  nodes: Array<DiscountRedeemCode>;
  pageInfo: PageInfo;
};

export type DiscountRedeemCodeEdge = {
  cursor: Scalars['String']['output'];
  node: DiscountRedeemCode;
};

export type DiscountRedeemCodeInput = {
  code: Scalars['String']['input'];
};

export type DiscountShareableUrl = {
  targetItemImage?: Maybe<Image>;
  targetType: DiscountShareableUrlTargetType;
  title: Scalars['String']['output'];
  url: Scalars['URL']['output'];
};

export const DiscountShareableUrlTargetType = {
  Collection: 'COLLECTION',
  Home: 'HOME',
  Product: 'PRODUCT'
} as const;

export type DiscountShareableUrlTargetType = typeof DiscountShareableUrlTargetType[keyof typeof DiscountShareableUrlTargetType];
export type DiscountShippingDestinationSelection = DiscountCountries | DiscountCountryAll;

export type DiscountShippingDestinationSelectionInput = {
  all?: InputMaybe<Scalars['Boolean']['input']>;
  countries?: InputMaybe<DiscountCountriesInput>;
};

export const DiscountSortKeys = {
  CreatedAt: 'CREATED_AT',
  EndsAt: 'ENDS_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE',
  StartsAt: 'STARTS_AT',
  Title: 'TITLE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type DiscountSortKeys = typeof DiscountSortKeys[keyof typeof DiscountSortKeys];
export const DiscountStatus = {
  Active: 'ACTIVE',
  Expired: 'EXPIRED',
  Scheduled: 'SCHEDULED'
} as const;

export type DiscountStatus = typeof DiscountStatus[keyof typeof DiscountStatus];
export const DiscountTargetType = {
  LineItem: 'LINE_ITEM',
  ShippingLine: 'SHIPPING_LINE'
} as const;

export type DiscountTargetType = typeof DiscountTargetType[keyof typeof DiscountTargetType];
export const DiscountType = {
  AutomaticDiscount: 'AUTOMATIC_DISCOUNT',
  CodeDiscount: 'CODE_DISCOUNT',
  Manual: 'MANUAL'
} as const;

export type DiscountType = typeof DiscountType[keyof typeof DiscountType];
export type DiscountUserError = DisplayableError & {
  code?: Maybe<DiscountErrorCode>;
  extraInfo?: Maybe<Scalars['String']['output']>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type DisplayableError = {
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type DisputeEvidenceUpdatePayload = {
  disputeEvidence?: Maybe<ShopifyPaymentsDisputeEvidence>;
  userErrors: Array<DisputeEvidenceUpdateUserError>;
};

export type DisputeEvidenceUpdateUserError = DisplayableError & {
  code?: Maybe<DisputeEvidenceUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const DisputeEvidenceUpdateUserErrorCode = {
  DisputeEvidenceNotFound: 'DISPUTE_EVIDENCE_NOT_FOUND',
  EvidenceAlreadyAccepted: 'EVIDENCE_ALREADY_ACCEPTED',
  EvidencePastDueDate: 'EVIDENCE_PAST_DUE_DATE',
  FilesSizeExceededLimit: 'FILES_SIZE_EXCEEDED_LIMIT',
  Invalid: 'INVALID',
  TooLarge: 'TOO_LARGE'
} as const;

export type DisputeEvidenceUpdateUserErrorCode = typeof DisputeEvidenceUpdateUserErrorCode[keyof typeof DisputeEvidenceUpdateUserErrorCode];
export const DisputeStatus = {
  Accepted: 'ACCEPTED',
  ChargeRefunded: 'CHARGE_REFUNDED',
  Lost: 'LOST',
  NeedsResponse: 'NEEDS_RESPONSE',
  UnderReview: 'UNDER_REVIEW',
  Won: 'WON'
} as const;

export type DisputeStatus = typeof DisputeStatus[keyof typeof DisputeStatus];
export const DisputeType = {
  Chargeback: 'CHARGEBACK',
  Inquiry: 'INQUIRY'
} as const;

export type DisputeType = typeof DisputeType[keyof typeof DisputeType];
export type Domain = Node & {
  host: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  localization?: Maybe<DomainLocalization>;
  marketWebPresence?: Maybe<MarketWebPresence>;
  sslEnabled: Scalars['Boolean']['output'];
  url: Scalars['URL']['output'];
};

export type DomainLocalization = {
  alternateLocales: Array<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  defaultLocale: Scalars['String']['output'];
};

export type DraftOrder = CommentEventSubject & HasEvents & HasLocalizationExtensions & HasLocalizedFields & HasMetafields & LegacyInteroperability & Navigable & Node & {
  acceptAutomaticDiscounts?: Maybe<Scalars['Boolean']['output']>;
  allVariantPricesOverridden: Scalars['Boolean']['output'];
  allowDiscountCodesInCheckout: Scalars['Boolean']['output'];
  anyVariantPricesOverridden: Scalars['Boolean']['output'];
  appliedDiscount?: Maybe<DraftOrderAppliedDiscount>;
  billingAddress?: Maybe<MailingAddress>;
  billingAddressMatchesShippingAddress: Scalars['Boolean']['output'];
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  currencyCode: CurrencyCode;
  customAttributes: Array<Attribute>;
  customer?: Maybe<Customer>;
  defaultCursor: Scalars['String']['output'];
  discountCodes: Array<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  events: EventConnection;
  hasTimelineComment: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  invoiceEmailTemplateSubject: Scalars['String']['output'];
  invoiceSentAt?: Maybe<Scalars['DateTime']['output']>;
  invoiceUrl?: Maybe<Scalars['URL']['output']>;
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  lineItems: DraftOrderLineItemConnection;
  lineItemsSubtotalPrice: MoneyBag;
  /** @deprecated This connection will be removed in a future version. Use `localizedFields` instead. */
  localizationExtensions: LocalizationExtensionConnection;
  localizedFields: LocalizedFieldConnection;
  /** @deprecated This field is now incompatible with Markets. */
  marketName: Scalars['String']['output'];
  /** @deprecated This field is now incompatible with Markets. */
  marketRegionCountryCode: CountryCode;
  metafield?: Maybe<Metafield>;
  metafields: MetafieldConnection;
  name: Scalars['String']['output'];
  note2?: Maybe<Scalars['String']['output']>;
  order?: Maybe<Order>;
  paymentTerms?: Maybe<PaymentTerms>;
  phone?: Maybe<Scalars['String']['output']>;
  platformDiscounts: Array<DraftOrderPlatformDiscount>;
  poNumber?: Maybe<Scalars['String']['output']>;
  presentmentCurrencyCode: CurrencyCode;
  purchasingEntity?: Maybe<PurchasingEntity>;
  ready: Scalars['Boolean']['output'];
  reserveInventoryUntil?: Maybe<Scalars['DateTime']['output']>;
  shippingAddress?: Maybe<MailingAddress>;
  shippingLine?: Maybe<ShippingLine>;
  status: DraftOrderStatus;
  /** @deprecated Use `subtotalPriceSet` instead. */
  subtotalPrice: Scalars['Money']['output'];
  subtotalPriceSet: MoneyBag;
  tags: Array<Scalars['String']['output']>;
  taxExempt: Scalars['Boolean']['output'];
  taxLines: Array<TaxLine>;
  taxesIncluded: Scalars['Boolean']['output'];
  totalDiscountsSet: MoneyBag;
  totalLineItemsPriceSet: MoneyBag;
  /** @deprecated Use `totalPriceSet` instead. */
  totalPrice: Scalars['Money']['output'];
  totalPriceSet: MoneyBag;
  totalQuantityOfLineItems: Scalars['Int']['output'];
  /** @deprecated Use `totalShippingPriceSet` instead. */
  totalShippingPrice: Scalars['Money']['output'];
  totalShippingPriceSet: MoneyBag;
  /** @deprecated Use `totalTaxSet` instead. */
  totalTax: Scalars['Money']['output'];
  totalTaxSet: MoneyBag;
  totalWeight: Scalars['UnsignedInt64']['output'];
  transformerFingerprint?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  visibleToCustomer: Scalars['Boolean']['output'];
  warnings: Array<DraftOrderWarning>;
};


export type DraftOrderEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type DraftOrderLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type DraftOrderLocalizationExtensionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  countryCodes?: InputMaybe<Array<CountryCode>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  purposes?: InputMaybe<Array<LocalizationExtensionPurpose>>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type DraftOrderLocalizedFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  countryCodes?: InputMaybe<Array<CountryCode>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  purposes?: InputMaybe<Array<LocalizedFieldPurpose>>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type DraftOrderMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type DraftOrderMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DraftOrderAppliedDiscount = {
  /** @deprecated Use `amountSet` instead. */
  amount: Scalars['Money']['output'];
  amountSet: MoneyBag;
  /** @deprecated Use `amountSet` instead. */
  amountV2: MoneyV2;
  description: Scalars['String']['output'];
  title?: Maybe<Scalars['String']['output']>;
  value: Scalars['Float']['output'];
  valueType: DraftOrderAppliedDiscountType;
};

export type DraftOrderAppliedDiscountInput = {
  amountWithCurrency?: InputMaybe<MoneyInput>;
  description?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['Float']['input'];
  valueType: DraftOrderAppliedDiscountType;
};

export const DraftOrderAppliedDiscountType = {
  FixedAmount: 'FIXED_AMOUNT',
  Percentage: 'PERCENTAGE'
} as const;

export type DraftOrderAppliedDiscountType = typeof DraftOrderAppliedDiscountType[keyof typeof DraftOrderAppliedDiscountType];
export type DraftOrderBulkAddTagsPayload = {
  job?: Maybe<Job>;
  userErrors: Array<UserError>;
};

export type DraftOrderBulkDeletePayload = {
  job?: Maybe<Job>;
  userErrors: Array<UserError>;
};

export type DraftOrderBulkRemoveTagsPayload = {
  job?: Maybe<Job>;
  userErrors: Array<UserError>;
};

export type DraftOrderBundleAddedWarning = DraftOrderWarning & {
  errorCode: Scalars['String']['output'];
  field: Scalars['String']['output'];
  message: Scalars['String']['output'];
};

export type DraftOrderCalculatePayload = {
  calculatedDraftOrder?: Maybe<CalculatedDraftOrder>;
  userErrors: Array<UserError>;
};

export type DraftOrderCompletePayload = {
  draftOrder?: Maybe<DraftOrder>;
  userErrors: Array<UserError>;
};

export type DraftOrderConnection = {
  edges: Array<DraftOrderEdge>;
  nodes: Array<DraftOrder>;
  pageInfo: PageInfo;
};

export type DraftOrderCreateFromOrderPayload = {
  draftOrder?: Maybe<DraftOrder>;
  userErrors: Array<UserError>;
};

export type DraftOrderCreateMerchantCheckoutPayload = {
  userErrors: Array<UserError>;
};

export type DraftOrderCreatePayload = {
  draftOrder?: Maybe<DraftOrder>;
  userErrors: Array<UserError>;
};

export type DraftOrderDeleteInput = {
  id: Scalars['ID']['input'];
};

export type DraftOrderDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<UserError>;
};

export type DraftOrderDiscountNotAppliedWarning = DraftOrderWarning & {
  discountCode?: Maybe<Scalars['String']['output']>;
  discountTitle?: Maybe<Scalars['String']['output']>;
  errorCode: Scalars['String']['output'];
  field: Scalars['String']['output'];
  message: Scalars['String']['output'];
  priceRule?: Maybe<PriceRule>;
};

export type DraftOrderDuplicatePayload = {
  draftOrder?: Maybe<DraftOrder>;
  userErrors: Array<UserError>;
};

export type DraftOrderEdge = {
  cursor: Scalars['String']['output'];
  node: DraftOrder;
};

export type DraftOrderInput = {
  acceptAutomaticDiscounts?: InputMaybe<Scalars['Boolean']['input']>;
  allowDiscountCodesInCheckout?: InputMaybe<Scalars['Boolean']['input']>;
  appliedDiscount?: InputMaybe<DraftOrderAppliedDiscountInput>;
  billingAddress?: InputMaybe<MailingAddressInput>;
  customAttributes?: InputMaybe<Array<AttributeInput>>;
  discountCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  email?: InputMaybe<Scalars['String']['input']>;
  lineItems?: InputMaybe<Array<DraftOrderLineItemInput>>;
  localizedFields?: InputMaybe<Array<LocalizedFieldInput>>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  note?: InputMaybe<Scalars['String']['input']>;
  paymentTerms?: InputMaybe<PaymentTermsInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  poNumber?: InputMaybe<Scalars['String']['input']>;
  presentmentCurrencyCode?: InputMaybe<CurrencyCode>;
  purchasingEntity?: InputMaybe<PurchasingEntityInput>;
  reserveInventoryUntil?: InputMaybe<Scalars['DateTime']['input']>;
  sessionToken?: InputMaybe<Scalars['String']['input']>;
  shippingAddress?: InputMaybe<MailingAddressInput>;
  shippingLine?: InputMaybe<ShippingLineInput>;
  sourceName?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  taxExempt?: InputMaybe<Scalars['Boolean']['input']>;
  transformerFingerprint?: InputMaybe<Scalars['String']['input']>;
  useCustomerDefaultAddress?: InputMaybe<Scalars['Boolean']['input']>;
  visibleToCustomer?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DraftOrderInvoicePreviewPayload = {
  previewHtml?: Maybe<Scalars['HTML']['output']>;
  previewSubject?: Maybe<Scalars['HTML']['output']>;
  userErrors: Array<UserError>;
};

export type DraftOrderInvoiceSendPayload = {
  draftOrder?: Maybe<DraftOrder>;
  userErrors: Array<UserError>;
};

export type DraftOrderLineItem = Node & {
  appliedDiscount?: Maybe<DraftOrderAppliedDiscount>;
  approximateDiscountedUnitPriceSet: MoneyBag;
  bundleComponents: Array<DraftOrderLineItem>;
  custom: Scalars['Boolean']['output'];
  customAttributes: Array<Attribute>;
  customAttributesV2: Array<TypedAttribute>;
  /** @deprecated Use `discountedTotalSet` instead. */
  discountedTotal: Scalars['Money']['output'];
  discountedTotalSet: MoneyBag;
  /** @deprecated Use `approximateDiscountedUnitPriceSet` instead. */
  discountedUnitPrice: Scalars['Money']['output'];
  /** @deprecated Use `approximateDiscountedUnitPriceSet` instead. */
  discountedUnitPriceSet: MoneyBag;
  fulfillmentService?: Maybe<FulfillmentService>;
  /** @deprecated Use `weight` instead. */
  grams?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  image?: Maybe<Image>;
  isGiftCard: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  /** @deprecated Use `originalTotalSet` instead. */
  originalTotal: Scalars['Money']['output'];
  originalTotalSet: MoneyBag;
  /** @deprecated Use `originalUnitPriceWithCurrency` instead. */
  originalUnitPrice: Scalars['Money']['output'];
  originalUnitPriceSet: MoneyBag;
  originalUnitPriceWithCurrency?: Maybe<MoneyV2>;
  priceOverride?: Maybe<MoneyV2>;
  product?: Maybe<Product>;
  quantity: Scalars['Int']['output'];
  requiresShipping: Scalars['Boolean']['output'];
  sku?: Maybe<Scalars['String']['output']>;
  taxLines: Array<TaxLine>;
  taxable: Scalars['Boolean']['output'];
  title: Scalars['String']['output'];
  /** @deprecated Use `totalDiscountSet` instead. */
  totalDiscount: Scalars['Money']['output'];
  totalDiscountSet: MoneyBag;
  uuid: Scalars['String']['output'];
  variant?: Maybe<ProductVariant>;
  variantTitle?: Maybe<Scalars['String']['output']>;
  vendor?: Maybe<Scalars['String']['output']>;
  weight?: Maybe<Weight>;
};

export type DraftOrderLineItemConnection = {
  edges: Array<DraftOrderLineItemEdge>;
  nodes: Array<DraftOrderLineItem>;
  pageInfo: PageInfo;
};

export type DraftOrderLineItemEdge = {
  cursor: Scalars['String']['output'];
  node: DraftOrderLineItem;
};

export type DraftOrderLineItemInput = {
  appliedDiscount?: InputMaybe<DraftOrderAppliedDiscountInput>;
  bundleComponents?: InputMaybe<Array<BundlesDraftOrderBundleLineItemComponentInput>>;
  customAttributes?: InputMaybe<Array<AttributeInput>>;
  generatePriceOverride?: InputMaybe<Scalars['Boolean']['input']>;
  originalUnitPriceWithCurrency?: InputMaybe<MoneyInput>;
  priceOverride?: InputMaybe<MoneyInput>;
  quantity: Scalars['Int']['input'];
  requiresShipping?: InputMaybe<Scalars['Boolean']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  taxable?: InputMaybe<Scalars['Boolean']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
  variantId?: InputMaybe<Scalars['ID']['input']>;
  weight?: InputMaybe<WeightInput>;
};

export type DraftOrderPlatformDiscount = {
  allocations: Array<DraftOrderPlatformDiscountAllocation>;
  automaticDiscount: Scalars['Boolean']['output'];
  bxgyDiscount: Scalars['Boolean']['output'];
  code?: Maybe<Scalars['String']['output']>;
  discountClass: DiscountClass;
  discountNode?: Maybe<DiscountNode>;
  id?: Maybe<Scalars['ID']['output']>;
  presentationLevel: Scalars['String']['output'];
  shortSummary: Scalars['String']['output'];
  summary: Scalars['String']['output'];
  title: Scalars['String']['output'];
  totalAmount: MoneyV2;
  totalAmountPriceSet: MoneyBag;
};

export type DraftOrderPlatformDiscountAllocation = {
  id?: Maybe<Scalars['ID']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  reductionAmount: MoneyV2;
  reductionAmountSet: MoneyBag;
  target?: Maybe<DraftOrderPlatformDiscountAllocationTarget>;
};

export type DraftOrderPlatformDiscountAllocationTarget = CalculatedDraftOrderLineItem | DraftOrderLineItem | ShippingLine;

export const DraftOrderSortKeys = {
  CustomerName: 'CUSTOMER_NAME',
  Id: 'ID',
  Number: 'NUMBER',
  Relevance: 'RELEVANCE',
  Status: 'STATUS',
  TotalPrice: 'TOTAL_PRICE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type DraftOrderSortKeys = typeof DraftOrderSortKeys[keyof typeof DraftOrderSortKeys];
export const DraftOrderStatus = {
  Completed: 'COMPLETED',
  InvoiceSent: 'INVOICE_SENT',
  Open: 'OPEN'
} as const;

export type DraftOrderStatus = typeof DraftOrderStatus[keyof typeof DraftOrderStatus];
export type DraftOrderTag = Node & {
  handle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  title: Scalars['String']['output'];
};

export type DraftOrderUpdatePayload = {
  draftOrder?: Maybe<DraftOrder>;
  userErrors: Array<UserError>;
};

export type DraftOrderWarning = {
  errorCode: Scalars['String']['output'];
  field: Scalars['String']['output'];
  message: Scalars['String']['output'];
};

export type Duty = Node & {
  countryCodeOfOrigin?: Maybe<CountryCode>;
  harmonizedSystemCode?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  price: MoneyBag;
  taxLines: Array<TaxLine>;
};

export type DutySale = Sale & {
  actionType: SaleActionType;
  duty: Duty;
  id: Scalars['ID']['output'];
  lineType: SaleLineType;
  quantity?: Maybe<Scalars['Int']['output']>;
  taxes: Array<SaleTax>;
  totalAmount: MoneyBag;
  totalDiscountAmountAfterTaxes: MoneyBag;
  totalDiscountAmountBeforeTaxes: MoneyBag;
  totalTaxAmount: MoneyBag;
};

export type EditableProperty = {
  locked: Scalars['Boolean']['output'];
  reason?: Maybe<Scalars['FormattedString']['output']>;
};

export type EmailInput = {
  bcc?: InputMaybe<Array<Scalars['String']['input']>>;
  body?: InputMaybe<Scalars['String']['input']>;
  customMessage?: InputMaybe<Scalars['String']['input']>;
  from?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  to?: InputMaybe<Scalars['String']['input']>;
};

export type ErrorsServerPixelUserError = DisplayableError & {
  code?: Maybe<ErrorsServerPixelUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ErrorsServerPixelUserErrorCode = {
  AlreadyExists: 'ALREADY_EXISTS',
  NeedsConfigurationToConnect: 'NEEDS_CONFIGURATION_TO_CONNECT',
  NotFound: 'NOT_FOUND',
  PubSubError: 'PUB_SUB_ERROR'
} as const;

export type ErrorsServerPixelUserErrorCode = typeof ErrorsServerPixelUserErrorCode[keyof typeof ErrorsServerPixelUserErrorCode];
export type ErrorsWebPixelUserError = DisplayableError & {
  code?: Maybe<ErrorsWebPixelUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ErrorsWebPixelUserErrorCode = {
  Blank: 'BLANK',
  InvalidSettings: 'INVALID_SETTINGS',
  NotFound: 'NOT_FOUND',
  Taken: 'TAKEN',
  UnableToDelete: 'UNABLE_TO_DELETE'
} as const;

export type ErrorsWebPixelUserErrorCode = typeof ErrorsWebPixelUserErrorCode[keyof typeof ErrorsWebPixelUserErrorCode];
export type Event = {
  action: Scalars['String']['output'];
  appTitle?: Maybe<Scalars['String']['output']>;
  attributeToApp: Scalars['Boolean']['output'];
  attributeToUser: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  criticalAlert: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  message: Scalars['FormattedString']['output'];
};

export type EventBridgeServerPixelUpdatePayload = {
  serverPixel?: Maybe<ServerPixel>;
  userErrors: Array<ErrorsServerPixelUserError>;
};

export type EventBridgeWebhookSubscriptionCreatePayload = {
  userErrors: Array<UserError>;
  webhookSubscription?: Maybe<WebhookSubscription>;
};

export type EventBridgeWebhookSubscriptionInput = {
  arn?: InputMaybe<Scalars['ARN']['input']>;
  filter?: InputMaybe<Scalars['String']['input']>;
  format?: InputMaybe<WebhookSubscriptionFormat>;
  includeFields?: InputMaybe<Array<Scalars['String']['input']>>;
  metafieldNamespaces?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type EventBridgeWebhookSubscriptionUpdatePayload = {
  userErrors: Array<UserError>;
  webhookSubscription?: Maybe<WebhookSubscription>;
};

export type EventConnection = {
  edges: Array<EventEdge>;
  nodes: Array<Event>;
  pageInfo: PageInfo;
};

export type EventEdge = {
  cursor: Scalars['String']['output'];
  node: Event;
};

export const EventSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type EventSortKeys = typeof EventSortKeys[keyof typeof EventSortKeys];
export const EventSubjectType = {
  Article: 'ARTICLE',
  Blog: 'BLOG',
  Collection: 'COLLECTION',
  Comment: 'COMMENT',
  Company: 'COMPANY',
  CompanyLocation: 'COMPANY_LOCATION',
  Customer: 'CUSTOMER',
  DiscountAutomaticBxgy: 'DISCOUNT_AUTOMATIC_BXGY',
  DiscountAutomaticNode: 'DISCOUNT_AUTOMATIC_NODE',
  DiscountCodeNode: 'DISCOUNT_CODE_NODE',
  DiscountNode: 'DISCOUNT_NODE',
  DraftOrder: 'DRAFT_ORDER',
  Order: 'ORDER',
  Page: 'PAGE',
  PriceRule: 'PRICE_RULE',
  Product: 'PRODUCT',
  ProductVariant: 'PRODUCT_VARIANT',
  Unknown: 'UNKNOWN'
} as const;

export type EventSubjectType = typeof EventSubjectType[keyof typeof EventSubjectType];
export type ExchangeLineItem = Node & {
  id: Scalars['ID']['output'];
  lineItem?: Maybe<LineItem>;
};

export type ExchangeLineItemAppliedDiscountInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  value: ExchangeLineItemAppliedDiscountValueInput;
};

export type ExchangeLineItemAppliedDiscountValueInput = {
  amount?: InputMaybe<MoneyInput>;
  percentage?: InputMaybe<Scalars['Float']['input']>;
};

export type ExchangeLineItemConnection = {
  edges: Array<ExchangeLineItemEdge>;
  nodes: Array<ExchangeLineItem>;
  pageInfo: PageInfo;
};

export type ExchangeLineItemEdge = {
  cursor: Scalars['String']['output'];
  node: ExchangeLineItem;
};

export type ExchangeLineItemInput = {
  appliedDiscount?: InputMaybe<ExchangeLineItemAppliedDiscountInput>;
  giftCardCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  quantity: Scalars['Int']['input'];
  variantId?: InputMaybe<Scalars['ID']['input']>;
};

export type ExchangeV2 = Node & {
  additions: ExchangeV2Additions;
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  location?: Maybe<Location>;
  note?: Maybe<Scalars['String']['output']>;
  refunds: Array<Refund>;
  returns: ExchangeV2Returns;
  staffMember?: Maybe<StaffMember>;
  totalAmountProcessedSet: MoneyBag;
  totalPriceSet: MoneyBag;
  transactions: Array<OrderTransaction>;
};

export type ExchangeV2Additions = {
  lineItems: Array<ExchangeV2LineItem>;
  subtotalPriceSet: MoneyBag;
  taxLines: Array<TaxLine>;
  totalPriceSet: MoneyBag;
};

export type ExchangeV2Connection = {
  edges: Array<ExchangeV2Edge>;
  nodes: Array<ExchangeV2>;
  pageInfo: PageInfo;
};

export type ExchangeV2Edge = {
  cursor: Scalars['String']['output'];
  node: ExchangeV2;
};

export type ExchangeV2LineItem = {
  customAttributes: Array<Attribute>;
  discountedTotalSet: MoneyBag;
  discountedUnitPriceSet: MoneyBag;
  fulfillmentService?: Maybe<FulfillmentService>;
  giftCard: Scalars['Boolean']['output'];
  giftCards: Array<GiftCard>;
  isGiftCard: Scalars['Boolean']['output'];
  lineItem?: Maybe<LineItem>;
  name: Scalars['String']['output'];
  originalTotalSet: MoneyBag;
  originalUnitPriceSet: MoneyBag;
  quantity: Scalars['Int']['output'];
  requiresShipping: Scalars['Boolean']['output'];
  sku?: Maybe<Scalars['String']['output']>;
  taxLines: Array<TaxLine>;
  taxable: Scalars['Boolean']['output'];
  title: Scalars['String']['output'];
  variant?: Maybe<ProductVariant>;
  variantTitle?: Maybe<Scalars['String']['output']>;
  vendor?: Maybe<Scalars['String']['output']>;
};

export type ExchangeV2Returns = {
  lineItems: Array<ExchangeV2LineItem>;
  orderDiscountAmountSet: MoneyBag;
  shippingRefundAmountSet: MoneyBag;
  subtotalPriceSet: MoneyBag;
  taxLines: Array<TaxLine>;
  tipRefundAmountSet: MoneyBag;
  totalPriceSet: MoneyBag;
};

export type ExternalVideo = File & Media & Node & {
  alt?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  embedUrl: Scalars['URL']['output'];
  /** @deprecated Use `originUrl` instead. */
  embeddedUrl: Scalars['URL']['output'];
  fileErrors: Array<FileError>;
  fileStatus: FileStatus;
  host: MediaHost;
  id: Scalars['ID']['output'];
  mediaContentType: MediaContentType;
  mediaErrors: Array<MediaError>;
  mediaWarnings: Array<MediaWarning>;
  originUrl: Scalars['URL']['output'];
  preview?: Maybe<MediaPreviewImage>;
  status: MediaStatus;
  updatedAt: Scalars['DateTime']['output'];
};

export type FailedRequirement = {
  action?: Maybe<NavigationItem>;
  message: Scalars['String']['output'];
};

export type Fee = {
  id: Scalars['ID']['output'];
};

export type FeeSale = Sale & {
  actionType: SaleActionType;
  fee: Fee;
  id: Scalars['ID']['output'];
  lineType: SaleLineType;
  quantity?: Maybe<Scalars['Int']['output']>;
  taxes: Array<SaleTax>;
  totalAmount: MoneyBag;
  totalDiscountAmountAfterTaxes: MoneyBag;
  totalDiscountAmountBeforeTaxes: MoneyBag;
  totalTaxAmount: MoneyBag;
};

export type File = {
  alt?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  fileErrors: Array<FileError>;
  fileStatus: FileStatus;
  id: Scalars['ID']['output'];
  preview?: Maybe<MediaPreviewImage>;
  updatedAt: Scalars['DateTime']['output'];
};

export type FileAcknowledgeUpdateFailedPayload = {
  files?: Maybe<Array<File>>;
  userErrors: Array<FilesUserError>;
};

export type FileConnection = {
  edges: Array<FileEdge>;
  nodes: Array<File>;
  pageInfo: PageInfo;
};

export const FileContentType = {
  ExternalVideo: 'EXTERNAL_VIDEO',
  File: 'FILE',
  Image: 'IMAGE',
  Model_3D: 'MODEL_3D',
  Video: 'VIDEO'
} as const;

export type FileContentType = typeof FileContentType[keyof typeof FileContentType];
export type FileCreateInput = {
  alt?: InputMaybe<Scalars['String']['input']>;
  contentType?: InputMaybe<FileContentType>;
  duplicateResolutionMode?: InputMaybe<FileCreateInputDuplicateResolutionMode>;
  filename?: InputMaybe<Scalars['String']['input']>;
  originalSource: Scalars['String']['input'];
};

export const FileCreateInputDuplicateResolutionMode = {
  AppendUuid: 'APPEND_UUID',
  RaiseError: 'RAISE_ERROR',
  Replace: 'REPLACE'
} as const;

export type FileCreateInputDuplicateResolutionMode = typeof FileCreateInputDuplicateResolutionMode[keyof typeof FileCreateInputDuplicateResolutionMode];
export type FileCreatePayload = {
  files?: Maybe<Array<File>>;
  userErrors: Array<FilesUserError>;
};

export type FileDeletePayload = {
  deletedFileIds?: Maybe<Array<Scalars['ID']['output']>>;
  userErrors: Array<FilesUserError>;
};

export type FileEdge = {
  cursor: Scalars['String']['output'];
  node: File;
};

export type FileError = {
  code: FileErrorCode;
  details?: Maybe<Scalars['String']['output']>;
  message: Scalars['String']['output'];
};

export const FileErrorCode = {
  DuplicateFilenameError: 'DUPLICATE_FILENAME_ERROR',
  ExternalVideoEmbedDisabled: 'EXTERNAL_VIDEO_EMBED_DISABLED',
  ExternalVideoEmbedNotFoundOrTranscoding: 'EXTERNAL_VIDEO_EMBED_NOT_FOUND_OR_TRANSCODING',
  ExternalVideoInvalidAspectRatio: 'EXTERNAL_VIDEO_INVALID_ASPECT_RATIO',
  ExternalVideoNotFound: 'EXTERNAL_VIDEO_NOT_FOUND',
  ExternalVideoUnlisted: 'EXTERNAL_VIDEO_UNLISTED',
  FileStorageLimitExceeded: 'FILE_STORAGE_LIMIT_EXCEEDED',
  GenericFileDownloadFailure: 'GENERIC_FILE_DOWNLOAD_FAILURE',
  GenericFileInvalidSize: 'GENERIC_FILE_INVALID_SIZE',
  ImageDownloadFailure: 'IMAGE_DOWNLOAD_FAILURE',
  ImageProcessingFailure: 'IMAGE_PROCESSING_FAILURE',
  InvalidImageAspectRatio: 'INVALID_IMAGE_ASPECT_RATIO',
  InvalidImageFileSize: 'INVALID_IMAGE_FILE_SIZE',
  InvalidImageResolution: 'INVALID_IMAGE_RESOLUTION',
  InvalidSignedUrl: 'INVALID_SIGNED_URL',
  MediaTimeoutError: 'MEDIA_TIMEOUT_ERROR',
  Model3DGlbOutputCreationError: 'MODEL3D_GLB_OUTPUT_CREATION_ERROR',
  Model3DGlbToUsdzConversionError: 'MODEL3D_GLB_TO_USDZ_CONVERSION_ERROR',
  Model3DProcessingFailure: 'MODEL3D_PROCESSING_FAILURE',
  Model3DThumbnailGenerationError: 'MODEL3D_THUMBNAIL_GENERATION_ERROR',
  Model3DThumbnailRegenerationError: 'MODEL3D_THUMBNAIL_REGENERATION_ERROR',
  Model3DValidationError: 'MODEL3D_VALIDATION_ERROR',
  Unknown: 'UNKNOWN',
  UnsupportedImageFileType: 'UNSUPPORTED_IMAGE_FILE_TYPE',
  VideoInvalidFiletypeError: 'VIDEO_INVALID_FILETYPE_ERROR',
  VideoMaxDurationError: 'VIDEO_MAX_DURATION_ERROR',
  VideoMaxHeightError: 'VIDEO_MAX_HEIGHT_ERROR',
  VideoMaxWidthError: 'VIDEO_MAX_WIDTH_ERROR',
  VideoMetadataReadError: 'VIDEO_METADATA_READ_ERROR',
  VideoMinDurationError: 'VIDEO_MIN_DURATION_ERROR',
  VideoMinHeightError: 'VIDEO_MIN_HEIGHT_ERROR',
  VideoMinWidthError: 'VIDEO_MIN_WIDTH_ERROR',
  VideoValidationError: 'VIDEO_VALIDATION_ERROR'
} as const;

export type FileErrorCode = typeof FileErrorCode[keyof typeof FileErrorCode];
export type FileSetInput = {
  alt?: InputMaybe<Scalars['String']['input']>;
  contentType?: InputMaybe<FileContentType>;
  duplicateResolutionMode?: InputMaybe<FileCreateInputDuplicateResolutionMode>;
  filename?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  originalSource?: InputMaybe<Scalars['String']['input']>;
};

export const FileSortKeys = {
  CreatedAt: 'CREATED_AT',
  Filename: 'FILENAME',
  Id: 'ID',
  OriginalUploadSize: 'ORIGINAL_UPLOAD_SIZE',
  Relevance: 'RELEVANCE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type FileSortKeys = typeof FileSortKeys[keyof typeof FileSortKeys];
export const FileStatus = {
  Failed: 'FAILED',
  Processing: 'PROCESSING',
  Ready: 'READY',
  Uploaded: 'UPLOADED'
} as const;

export type FileStatus = typeof FileStatus[keyof typeof FileStatus];
export type FileUpdateInput = {
  alt?: InputMaybe<Scalars['String']['input']>;
  filename?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  originalSource?: InputMaybe<Scalars['String']['input']>;
  previewImageSource?: InputMaybe<Scalars['String']['input']>;
  referencesToAdd?: InputMaybe<Array<Scalars['ID']['input']>>;
  referencesToRemove?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type FileUpdatePayload = {
  files?: Maybe<Array<File>>;
  userErrors: Array<FilesUserError>;
};

export const FilesErrorCode = {
  AltValueLimitExceeded: 'ALT_VALUE_LIMIT_EXCEEDED',
  BlankSearch: 'BLANK_SEARCH',
  FilenameAlreadyExists: 'FILENAME_ALREADY_EXISTS',
  FileDoesNotExist: 'FILE_DOES_NOT_EXIST',
  FileLocked: 'FILE_LOCKED',
  Invalid: 'INVALID',
  InvalidDuplicateModeForType: 'INVALID_DUPLICATE_MODE_FOR_TYPE',
  InvalidFilename: 'INVALID_FILENAME',
  InvalidFilenameExtension: 'INVALID_FILENAME_EXTENSION',
  InvalidImageSourceUrl: 'INVALID_IMAGE_SOURCE_URL',
  InvalidQuery: 'INVALID_QUERY',
  MismatchedFilenameAndOriginalSource: 'MISMATCHED_FILENAME_AND_ORIGINAL_SOURCE',
  MissingArguments: 'MISSING_ARGUMENTS',
  MissingFilenameForDuplicateModeReplace: 'MISSING_FILENAME_FOR_DUPLICATE_MODE_REPLACE',
  NonImageMediaPerShopLimitExceeded: 'NON_IMAGE_MEDIA_PER_SHOP_LIMIT_EXCEEDED',
  NonReadyState: 'NON_READY_STATE',
  ProductMediaLimitExceeded: 'PRODUCT_MEDIA_LIMIT_EXCEEDED',
  ReferenceTargetDoesNotExist: 'REFERENCE_TARGET_DOES_NOT_EXIST',
  TooManyArguments: 'TOO_MANY_ARGUMENTS',
  TooManyFileReference: 'TOO_MANY_FILE_REFERENCE',
  UnacceptableAsset: 'UNACCEPTABLE_ASSET',
  UnacceptableTrialAsset: 'UNACCEPTABLE_TRIAL_ASSET',
  UnacceptableUnverifiedTrialAsset: 'UNACCEPTABLE_UNVERIFIED_TRIAL_ASSET',
  UnsupportedFileReference: 'UNSUPPORTED_FILE_REFERENCE',
  UnsupportedMediaTypeForFilenameUpdate: 'UNSUPPORTED_MEDIA_TYPE_FOR_FILENAME_UPDATE'
} as const;

export type FilesErrorCode = typeof FilesErrorCode[keyof typeof FilesErrorCode];
export type FilesUserError = DisplayableError & {
  code?: Maybe<FilesErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type FilterOption = {
  label: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type FinancialSummaryDiscountAllocation = {
  approximateAllocatedAmountPerItem: MoneyBag;
  discountApplication: FinancialSummaryDiscountApplication;
};

export type FinancialSummaryDiscountApplication = {
  allocationMethod: DiscountApplicationAllocationMethod;
  targetSelection: DiscountApplicationTargetSelection;
  targetType: DiscountApplicationTargetType;
};

export type FlowGenerateSignaturePayload = {
  payload?: Maybe<Scalars['String']['output']>;
  signature?: Maybe<Scalars['String']['output']>;
  userErrors: Array<UserError>;
};

export type FlowTriggerReceivePayload = {
  userErrors: Array<UserError>;
};

export type Fulfillment = LegacyInteroperability & Node & {
  createdAt: Scalars['DateTime']['output'];
  deliveredAt?: Maybe<Scalars['DateTime']['output']>;
  displayStatus?: Maybe<FulfillmentDisplayStatus>;
  estimatedDeliveryAt?: Maybe<Scalars['DateTime']['output']>;
  events: FulfillmentEventConnection;
  fulfillmentLineItems: FulfillmentLineItemConnection;
  fulfillmentOrders: FulfillmentOrderConnection;
  id: Scalars['ID']['output'];
  inTransitAt?: Maybe<Scalars['DateTime']['output']>;
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  location?: Maybe<Location>;
  name: Scalars['String']['output'];
  order: Order;
  originAddress?: Maybe<FulfillmentOriginAddress>;
  requiresShipping: Scalars['Boolean']['output'];
  service?: Maybe<FulfillmentService>;
  status: FulfillmentStatus;
  totalQuantity: Scalars['Int']['output'];
  trackingInfo: Array<FulfillmentTrackingInfo>;
  updatedAt: Scalars['DateTime']['output'];
};


export type FulfillmentEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<FulfillmentEventSortKeys>;
};


export type FulfillmentFulfillmentLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type FulfillmentFulfillmentOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type FulfillmentTrackingInfoArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type FulfillmentCancelPayload = {
  fulfillment?: Maybe<Fulfillment>;
  userErrors: Array<UserError>;
};

export type FulfillmentConnection = {
  edges: Array<FulfillmentEdge>;
  nodes: Array<Fulfillment>;
  pageInfo: PageInfo;
};

export type FulfillmentConstraintRule = HasMetafields & Node & {
  deliveryMethodTypes: Array<DeliveryMethodType>;
  function: ShopifyFunction;
  id: Scalars['ID']['output'];
  metafield?: Maybe<Metafield>;
  metafields: MetafieldConnection;
};


export type FulfillmentConstraintRuleMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type FulfillmentConstraintRuleMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type FulfillmentConstraintRuleCreatePayload = {
  fulfillmentConstraintRule?: Maybe<FulfillmentConstraintRule>;
  userErrors: Array<FulfillmentConstraintRuleCreateUserError>;
};

export type FulfillmentConstraintRuleCreateUserError = DisplayableError & {
  code?: Maybe<FulfillmentConstraintRuleCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const FulfillmentConstraintRuleCreateUserErrorCode = {
  CustomAppFunctionNotEligible: 'CUSTOM_APP_FUNCTION_NOT_ELIGIBLE',
  FunctionAlreadyRegistered: 'FUNCTION_ALREADY_REGISTERED',
  FunctionDoesNotImplement: 'FUNCTION_DOES_NOT_IMPLEMENT',
  FunctionNotFound: 'FUNCTION_NOT_FOUND',
  FunctionPendingDeletion: 'FUNCTION_PENDING_DELETION',
  InputInvalid: 'INPUT_INVALID',
  MaximumFulfillmentConstraintRulesReached: 'MAXIMUM_FULFILLMENT_CONSTRAINT_RULES_REACHED'
} as const;

export type FulfillmentConstraintRuleCreateUserErrorCode = typeof FulfillmentConstraintRuleCreateUserErrorCode[keyof typeof FulfillmentConstraintRuleCreateUserErrorCode];
export type FulfillmentConstraintRuleDeletePayload = {
  success?: Maybe<Scalars['Boolean']['output']>;
  userErrors: Array<FulfillmentConstraintRuleDeleteUserError>;
};

export type FulfillmentConstraintRuleDeleteUserError = DisplayableError & {
  code?: Maybe<FulfillmentConstraintRuleDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const FulfillmentConstraintRuleDeleteUserErrorCode = {
  NotFound: 'NOT_FOUND',
  UnauthorizedAppScope: 'UNAUTHORIZED_APP_SCOPE'
} as const;

export type FulfillmentConstraintRuleDeleteUserErrorCode = typeof FulfillmentConstraintRuleDeleteUserErrorCode[keyof typeof FulfillmentConstraintRuleDeleteUserErrorCode];
export type FulfillmentConstraintRuleUpdatePayload = {
  fulfillmentConstraintRule?: Maybe<FulfillmentConstraintRule>;
  userErrors: Array<FulfillmentConstraintRuleUpdateUserError>;
};

export type FulfillmentConstraintRuleUpdateUserError = DisplayableError & {
  code?: Maybe<FulfillmentConstraintRuleUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const FulfillmentConstraintRuleUpdateUserErrorCode = {
  NotFound: 'NOT_FOUND',
  UnauthorizedAppScope: 'UNAUTHORIZED_APP_SCOPE'
} as const;

export type FulfillmentConstraintRuleUpdateUserErrorCode = typeof FulfillmentConstraintRuleUpdateUserErrorCode[keyof typeof FulfillmentConstraintRuleUpdateUserErrorCode];
export type FulfillmentCreatePayload = {
  fulfillment?: Maybe<Fulfillment>;
  userErrors: Array<UserError>;
};

export type FulfillmentCreateV2Payload = {
  fulfillment?: Maybe<Fulfillment>;
  userErrors: Array<UserError>;
};

export const FulfillmentDisplayStatus = {
  AttemptedDelivery: 'ATTEMPTED_DELIVERY',
  Canceled: 'CANCELED',
  Confirmed: 'CONFIRMED',
  Delayed: 'DELAYED',
  Delivered: 'DELIVERED',
  Failure: 'FAILURE',
  Fulfilled: 'FULFILLED',
  InTransit: 'IN_TRANSIT',
  LabelPrinted: 'LABEL_PRINTED',
  LabelPurchased: 'LABEL_PURCHASED',
  LabelVoided: 'LABEL_VOIDED',
  MarkedAsFulfilled: 'MARKED_AS_FULFILLED',
  NotDelivered: 'NOT_DELIVERED',
  OutForDelivery: 'OUT_FOR_DELIVERY',
  PickedUp: 'PICKED_UP',
  ReadyForPickup: 'READY_FOR_PICKUP',
  Submitted: 'SUBMITTED'
} as const;

export type FulfillmentDisplayStatus = typeof FulfillmentDisplayStatus[keyof typeof FulfillmentDisplayStatus];
export type FulfillmentEdge = {
  cursor: Scalars['String']['output'];
  node: Fulfillment;
};

export type FulfillmentEvent = Node & {
  address1?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  estimatedDeliveryAt?: Maybe<Scalars['DateTime']['output']>;
  happenedAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  status: FulfillmentEventStatus;
  zip?: Maybe<Scalars['String']['output']>;
};

export type FulfillmentEventConnection = {
  edges: Array<FulfillmentEventEdge>;
  nodes: Array<FulfillmentEvent>;
  pageInfo: PageInfo;
};

export type FulfillmentEventCreatePayload = {
  fulfillmentEvent?: Maybe<FulfillmentEvent>;
  userErrors: Array<UserError>;
};

export type FulfillmentEventEdge = {
  cursor: Scalars['String']['output'];
  node: FulfillmentEvent;
};

export type FulfillmentEventInput = {
  address1?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  estimatedDeliveryAt?: InputMaybe<Scalars['DateTime']['input']>;
  fulfillmentId: Scalars['ID']['input'];
  happenedAt?: InputMaybe<Scalars['DateTime']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  status: FulfillmentEventStatus;
  zip?: InputMaybe<Scalars['String']['input']>;
};

export const FulfillmentEventSortKeys = {
  HappenedAt: 'HAPPENED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type FulfillmentEventSortKeys = typeof FulfillmentEventSortKeys[keyof typeof FulfillmentEventSortKeys];
export const FulfillmentEventStatus = {
  AttemptedDelivery: 'ATTEMPTED_DELIVERY',
  Confirmed: 'CONFIRMED',
  Delayed: 'DELAYED',
  Delivered: 'DELIVERED',
  Failure: 'FAILURE',
  InTransit: 'IN_TRANSIT',
  LabelPrinted: 'LABEL_PRINTED',
  LabelPurchased: 'LABEL_PURCHASED',
  OutForDelivery: 'OUT_FOR_DELIVERY',
  ReadyForPickup: 'READY_FOR_PICKUP'
} as const;

export type FulfillmentEventStatus = typeof FulfillmentEventStatus[keyof typeof FulfillmentEventStatus];
export type FulfillmentHold = Node & {
  displayReason: Scalars['String']['output'];
  handle?: Maybe<Scalars['String']['output']>;
  heldByApp?: Maybe<App>;
  heldByRequestingApp: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  reason: FulfillmentHoldReason;
  reasonNotes?: Maybe<Scalars['String']['output']>;
};

export const FulfillmentHoldReason = {
  AwaitingPayment: 'AWAITING_PAYMENT',
  AwaitingReturnItems: 'AWAITING_RETURN_ITEMS',
  HighRiskOfFraud: 'HIGH_RISK_OF_FRAUD',
  IncorrectAddress: 'INCORRECT_ADDRESS',
  InventoryOutOfStock: 'INVENTORY_OUT_OF_STOCK',
  OnlineStorePostPurchaseCrossSell: 'ONLINE_STORE_POST_PURCHASE_CROSS_SELL',
  Other: 'OTHER',
  UnknownDeliveryDate: 'UNKNOWN_DELIVERY_DATE'
} as const;

export type FulfillmentHoldReason = typeof FulfillmentHoldReason[keyof typeof FulfillmentHoldReason];
export type FulfillmentInput = {
  lineItemsByFulfillmentOrder: Array<FulfillmentOrderLineItemsInput>;
  notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  originAddress?: InputMaybe<FulfillmentOriginAddressInput>;
  trackingInfo?: InputMaybe<FulfillmentTrackingInput>;
};

export type FulfillmentLineItem = Node & {
  /** @deprecated Use `discountedTotalSet` instead. */
  discountedTotal: Scalars['Money']['output'];
  discountedTotalSet: MoneyBag;
  id: Scalars['ID']['output'];
  lineItem: LineItem;
  /** @deprecated Use `originalTotalSet` instead. */
  originalTotal: Scalars['Money']['output'];
  originalTotalSet: MoneyBag;
  quantity?: Maybe<Scalars['Int']['output']>;
};

export type FulfillmentLineItemConnection = {
  edges: Array<FulfillmentLineItemEdge>;
  nodes: Array<FulfillmentLineItem>;
  pageInfo: PageInfo;
};

export type FulfillmentLineItemEdge = {
  cursor: Scalars['String']['output'];
  node: FulfillmentLineItem;
};

export type FulfillmentOrder = Node & {
  assignedLocation: FulfillmentOrderAssignedLocation;
  channelId?: Maybe<Scalars['ID']['output']>;
  createdAt: Scalars['DateTime']['output'];
  deliveryMethod?: Maybe<DeliveryMethod>;
  destination?: Maybe<FulfillmentOrderDestination>;
  fulfillAt?: Maybe<Scalars['DateTime']['output']>;
  fulfillBy?: Maybe<Scalars['DateTime']['output']>;
  fulfillmentHolds: Array<FulfillmentHold>;
  fulfillmentOrdersForMerge: FulfillmentOrderConnection;
  fulfillments: FulfillmentConnection;
  id: Scalars['ID']['output'];
  internationalDuties?: Maybe<FulfillmentOrderInternationalDuties>;
  lineItems: FulfillmentOrderLineItemConnection;
  locationsForMove: FulfillmentOrderLocationForMoveConnection;
  merchantRequests: FulfillmentOrderMerchantRequestConnection;
  order: Order;
  orderId: Scalars['ID']['output'];
  orderName: Scalars['String']['output'];
  orderProcessedAt: Scalars['DateTime']['output'];
  requestStatus: FulfillmentOrderRequestStatus;
  status: FulfillmentOrderStatus;
  supportedActions: Array<FulfillmentOrderSupportedAction>;
  updatedAt: Scalars['DateTime']['output'];
};


export type FulfillmentOrderFulfillmentOrdersForMergeArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type FulfillmentOrderFulfillmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type FulfillmentOrderLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type FulfillmentOrderLocationsForMoveArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  lineItemIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  locationIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type FulfillmentOrderMerchantRequestsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  kind?: InputMaybe<FulfillmentOrderMerchantRequestKind>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type FulfillmentOrderAcceptCancellationRequestPayload = {
  fulfillmentOrder?: Maybe<FulfillmentOrder>;
  userErrors: Array<UserError>;
};

export type FulfillmentOrderAcceptFulfillmentRequestPayload = {
  fulfillmentOrder?: Maybe<FulfillmentOrder>;
  userErrors: Array<UserError>;
};

export const FulfillmentOrderAction = {
  CancelFulfillmentOrder: 'CANCEL_FULFILLMENT_ORDER',
  CreateFulfillment: 'CREATE_FULFILLMENT',
  External: 'EXTERNAL',
  Hold: 'HOLD',
  MarkAsOpen: 'MARK_AS_OPEN',
  Merge: 'MERGE',
  Move: 'MOVE',
  ReleaseHold: 'RELEASE_HOLD',
  RequestCancellation: 'REQUEST_CANCELLATION',
  RequestFulfillment: 'REQUEST_FULFILLMENT',
  Split: 'SPLIT'
} as const;

export type FulfillmentOrderAction = typeof FulfillmentOrderAction[keyof typeof FulfillmentOrderAction];
export type FulfillmentOrderAssignedLocation = {
  address1?: Maybe<Scalars['String']['output']>;
  address2?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  countryCode: CountryCode;
  location?: Maybe<Location>;
  name: Scalars['String']['output'];
  phone?: Maybe<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  zip?: Maybe<Scalars['String']['output']>;
};

export const FulfillmentOrderAssignmentStatus = {
  CancellationRequested: 'CANCELLATION_REQUESTED',
  FulfillmentAccepted: 'FULFILLMENT_ACCEPTED',
  FulfillmentRequested: 'FULFILLMENT_REQUESTED',
  FulfillmentUnsubmitted: 'FULFILLMENT_UNSUBMITTED'
} as const;

export type FulfillmentOrderAssignmentStatus = typeof FulfillmentOrderAssignmentStatus[keyof typeof FulfillmentOrderAssignmentStatus];
export type FulfillmentOrderCancelPayload = {
  fulfillmentOrder?: Maybe<FulfillmentOrder>;
  replacementFulfillmentOrder?: Maybe<FulfillmentOrder>;
  userErrors: Array<UserError>;
};

export type FulfillmentOrderClosePayload = {
  fulfillmentOrder?: Maybe<FulfillmentOrder>;
  userErrors: Array<UserError>;
};

export type FulfillmentOrderConnection = {
  edges: Array<FulfillmentOrderEdge>;
  nodes: Array<FulfillmentOrder>;
  pageInfo: PageInfo;
};

export type FulfillmentOrderDestination = Node & {
  address1?: Maybe<Scalars['String']['output']>;
  address2?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  company?: Maybe<Scalars['String']['output']>;
  countryCode?: Maybe<CountryCode>;
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  location?: Maybe<Location>;
  phone?: Maybe<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  zip?: Maybe<Scalars['String']['output']>;
};

export type FulfillmentOrderEdge = {
  cursor: Scalars['String']['output'];
  node: FulfillmentOrder;
};

export type FulfillmentOrderHoldInput = {
  externalId?: InputMaybe<Scalars['String']['input']>;
  fulfillmentOrderLineItems?: InputMaybe<Array<FulfillmentOrderLineItemInput>>;
  handle?: InputMaybe<Scalars['String']['input']>;
  notifyMerchant?: InputMaybe<Scalars['Boolean']['input']>;
  reason: FulfillmentHoldReason;
  reasonNotes?: InputMaybe<Scalars['String']['input']>;
};

export type FulfillmentOrderHoldPayload = {
  fulfillmentHold?: Maybe<FulfillmentHold>;
  fulfillmentOrder?: Maybe<FulfillmentOrder>;
  remainingFulfillmentOrder?: Maybe<FulfillmentOrder>;
  userErrors: Array<FulfillmentOrderHoldUserError>;
};

export type FulfillmentOrderHoldUserError = DisplayableError & {
  code?: Maybe<FulfillmentOrderHoldUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const FulfillmentOrderHoldUserErrorCode = {
  DuplicateFulfillmentHoldHandle: 'DUPLICATE_FULFILLMENT_HOLD_HANDLE',
  FulfillmentOrderHoldLimitReached: 'FULFILLMENT_ORDER_HOLD_LIMIT_REACHED',
  FulfillmentOrderNotFound: 'FULFILLMENT_ORDER_NOT_FOUND',
  FulfillmentOrderNotSplittable: 'FULFILLMENT_ORDER_NOT_SPLITTABLE',
  GreaterThanZero: 'GREATER_THAN_ZERO',
  InvalidLineItemQuantity: 'INVALID_LINE_ITEM_QUANTITY',
  Taken: 'TAKEN'
} as const;

export type FulfillmentOrderHoldUserErrorCode = typeof FulfillmentOrderHoldUserErrorCode[keyof typeof FulfillmentOrderHoldUserErrorCode];
export type FulfillmentOrderInternationalDuties = {
  incoterm: Scalars['String']['output'];
};

export type FulfillmentOrderLineItem = Node & {
  financialSummaries: Array<FulfillmentOrderLineItemFinancialSummary>;
  id: Scalars['ID']['output'];
  image?: Maybe<Image>;
  inventoryItemId?: Maybe<Scalars['ID']['output']>;
  lineItem: LineItem;
  /** @deprecated Use `financialSummaries` instead. */
  originalUnitPriceSet: MoneyBag;
  productTitle: Scalars['String']['output'];
  remainingQuantity: Scalars['Int']['output'];
  requiresShipping: Scalars['Boolean']['output'];
  sku?: Maybe<Scalars['String']['output']>;
  totalQuantity: Scalars['Int']['output'];
  variant?: Maybe<ProductVariant>;
  variantTitle?: Maybe<Scalars['String']['output']>;
  vendor?: Maybe<Scalars['String']['output']>;
  warnings: Array<FulfillmentOrderLineItemWarning>;
  weight?: Maybe<Weight>;
};

export type FulfillmentOrderLineItemConnection = {
  edges: Array<FulfillmentOrderLineItemEdge>;
  nodes: Array<FulfillmentOrderLineItem>;
  pageInfo: PageInfo;
};

export type FulfillmentOrderLineItemEdge = {
  cursor: Scalars['String']['output'];
  node: FulfillmentOrderLineItem;
};

export type FulfillmentOrderLineItemFinancialSummary = {
  approximateDiscountedUnitPriceSet: MoneyBag;
  discountAllocations: Array<FinancialSummaryDiscountAllocation>;
  originalUnitPriceSet: MoneyBag;
  quantity: Scalars['Int']['output'];
};

export type FulfillmentOrderLineItemInput = {
  id: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
};

export type FulfillmentOrderLineItemWarning = {
  description?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};

export type FulfillmentOrderLineItemsInput = {
  fulfillmentOrderId: Scalars['ID']['input'];
  fulfillmentOrderLineItems?: InputMaybe<Array<FulfillmentOrderLineItemInput>>;
};

export type FulfillmentOrderLineItemsPreparedForPickupInput = {
  lineItemsByFulfillmentOrder: Array<PreparedFulfillmentOrderLineItemsInput>;
};

export type FulfillmentOrderLineItemsPreparedForPickupPayload = {
  userErrors: Array<FulfillmentOrderLineItemsPreparedForPickupUserError>;
};

export type FulfillmentOrderLineItemsPreparedForPickupUserError = DisplayableError & {
  code?: Maybe<FulfillmentOrderLineItemsPreparedForPickupUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const FulfillmentOrderLineItemsPreparedForPickupUserErrorCode = {
  FulfillmentOrderInvalid: 'FULFILLMENT_ORDER_INVALID',
  NoLineItemsToPrepareForFulfillmentOrder: 'NO_LINE_ITEMS_TO_PREPARE_FOR_FULFILLMENT_ORDER',
  UnableToPrepareQuantity: 'UNABLE_TO_PREPARE_QUANTITY'
} as const;

export type FulfillmentOrderLineItemsPreparedForPickupUserErrorCode = typeof FulfillmentOrderLineItemsPreparedForPickupUserErrorCode[keyof typeof FulfillmentOrderLineItemsPreparedForPickupUserErrorCode];
export type FulfillmentOrderLocationForMove = {
  availableLineItems: FulfillmentOrderLineItemConnection;
  availableLineItemsCount?: Maybe<Count>;
  location: Location;
  message?: Maybe<Scalars['String']['output']>;
  movable: Scalars['Boolean']['output'];
  unavailableLineItems: FulfillmentOrderLineItemConnection;
  unavailableLineItemsCount?: Maybe<Count>;
};


export type FulfillmentOrderLocationForMoveAvailableLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type FulfillmentOrderLocationForMoveUnavailableLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type FulfillmentOrderLocationForMoveConnection = {
  edges: Array<FulfillmentOrderLocationForMoveEdge>;
  nodes: Array<FulfillmentOrderLocationForMove>;
  pageInfo: PageInfo;
};

export type FulfillmentOrderLocationForMoveEdge = {
  cursor: Scalars['String']['output'];
  node: FulfillmentOrderLocationForMove;
};

export type FulfillmentOrderMerchantRequest = Node & {
  fulfillmentOrder: FulfillmentOrder;
  id: Scalars['ID']['output'];
  kind: FulfillmentOrderMerchantRequestKind;
  message?: Maybe<Scalars['String']['output']>;
  requestOptions?: Maybe<Scalars['JSON']['output']>;
  responseData?: Maybe<Scalars['JSON']['output']>;
  sentAt: Scalars['DateTime']['output'];
};

export type FulfillmentOrderMerchantRequestConnection = {
  edges: Array<FulfillmentOrderMerchantRequestEdge>;
  nodes: Array<FulfillmentOrderMerchantRequest>;
  pageInfo: PageInfo;
};

export type FulfillmentOrderMerchantRequestEdge = {
  cursor: Scalars['String']['output'];
  node: FulfillmentOrderMerchantRequest;
};

export const FulfillmentOrderMerchantRequestKind = {
  CancellationRequest: 'CANCELLATION_REQUEST',
  FulfillmentRequest: 'FULFILLMENT_REQUEST'
} as const;

export type FulfillmentOrderMerchantRequestKind = typeof FulfillmentOrderMerchantRequestKind[keyof typeof FulfillmentOrderMerchantRequestKind];
export type FulfillmentOrderMergeInput = {
  mergeIntents: Array<FulfillmentOrderMergeInputMergeIntent>;
};

export type FulfillmentOrderMergeInputMergeIntent = {
  fulfillmentOrderId: Scalars['ID']['input'];
  fulfillmentOrderLineItems?: InputMaybe<Array<FulfillmentOrderLineItemInput>>;
};

export type FulfillmentOrderMergePayload = {
  fulfillmentOrderMerges?: Maybe<Array<FulfillmentOrderMergeResult>>;
  userErrors: Array<FulfillmentOrderMergeUserError>;
};

export type FulfillmentOrderMergeResult = {
  fulfillmentOrder: FulfillmentOrder;
};

export type FulfillmentOrderMergeUserError = DisplayableError & {
  code?: Maybe<FulfillmentOrderMergeUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const FulfillmentOrderMergeUserErrorCode = {
  FulfillmentOrderNotFound: 'FULFILLMENT_ORDER_NOT_FOUND',
  GreaterThan: 'GREATER_THAN',
  InvalidLineItemQuantity: 'INVALID_LINE_ITEM_QUANTITY'
} as const;

export type FulfillmentOrderMergeUserErrorCode = typeof FulfillmentOrderMergeUserErrorCode[keyof typeof FulfillmentOrderMergeUserErrorCode];
export type FulfillmentOrderMovePayload = {
  movedFulfillmentOrder?: Maybe<FulfillmentOrder>;
  originalFulfillmentOrder?: Maybe<FulfillmentOrder>;
  remainingFulfillmentOrder?: Maybe<FulfillmentOrder>;
  userErrors: Array<UserError>;
};

export type FulfillmentOrderOpenPayload = {
  fulfillmentOrder?: Maybe<FulfillmentOrder>;
  userErrors: Array<UserError>;
};

export type FulfillmentOrderRejectCancellationRequestPayload = {
  fulfillmentOrder?: Maybe<FulfillmentOrder>;
  userErrors: Array<UserError>;
};

export type FulfillmentOrderRejectFulfillmentRequestPayload = {
  fulfillmentOrder?: Maybe<FulfillmentOrder>;
  userErrors: Array<UserError>;
};

export const FulfillmentOrderRejectionReason = {
  IncorrectAddress: 'INCORRECT_ADDRESS',
  IneligibleProduct: 'INELIGIBLE_PRODUCT',
  InventoryOutOfStock: 'INVENTORY_OUT_OF_STOCK',
  Other: 'OTHER',
  UndeliverableDestination: 'UNDELIVERABLE_DESTINATION'
} as const;

export type FulfillmentOrderRejectionReason = typeof FulfillmentOrderRejectionReason[keyof typeof FulfillmentOrderRejectionReason];
export type FulfillmentOrderReleaseHoldPayload = {
  fulfillmentOrder?: Maybe<FulfillmentOrder>;
  userErrors: Array<FulfillmentOrderReleaseHoldUserError>;
};

export type FulfillmentOrderReleaseHoldUserError = DisplayableError & {
  code?: Maybe<FulfillmentOrderReleaseHoldUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const FulfillmentOrderReleaseHoldUserErrorCode = {
  FulfillmentOrderNotFound: 'FULFILLMENT_ORDER_NOT_FOUND',
  InvalidAccess: 'INVALID_ACCESS'
} as const;

export type FulfillmentOrderReleaseHoldUserErrorCode = typeof FulfillmentOrderReleaseHoldUserErrorCode[keyof typeof FulfillmentOrderReleaseHoldUserErrorCode];
export const FulfillmentOrderRequestStatus = {
  Accepted: 'ACCEPTED',
  CancellationAccepted: 'CANCELLATION_ACCEPTED',
  CancellationRejected: 'CANCELLATION_REJECTED',
  CancellationRequested: 'CANCELLATION_REQUESTED',
  Closed: 'CLOSED',
  Rejected: 'REJECTED',
  Submitted: 'SUBMITTED',
  Unsubmitted: 'UNSUBMITTED'
} as const;

export type FulfillmentOrderRequestStatus = typeof FulfillmentOrderRequestStatus[keyof typeof FulfillmentOrderRequestStatus];
export type FulfillmentOrderReschedulePayload = {
  fulfillmentOrder?: Maybe<FulfillmentOrder>;
  userErrors: Array<FulfillmentOrderRescheduleUserError>;
};

export type FulfillmentOrderRescheduleUserError = DisplayableError & {
  code?: Maybe<FulfillmentOrderRescheduleUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const FulfillmentOrderRescheduleUserErrorCode = {
  FulfillmentOrderNotFound: 'FULFILLMENT_ORDER_NOT_FOUND'
} as const;

export type FulfillmentOrderRescheduleUserErrorCode = typeof FulfillmentOrderRescheduleUserErrorCode[keyof typeof FulfillmentOrderRescheduleUserErrorCode];
export const FulfillmentOrderSortKeys = {
  Id: 'ID',
  Relevance: 'RELEVANCE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type FulfillmentOrderSortKeys = typeof FulfillmentOrderSortKeys[keyof typeof FulfillmentOrderSortKeys];
export type FulfillmentOrderSplitInput = {
  fulfillmentOrderId: Scalars['ID']['input'];
  fulfillmentOrderLineItems: Array<FulfillmentOrderLineItemInput>;
};

export type FulfillmentOrderSplitPayload = {
  fulfillmentOrderSplits?: Maybe<Array<FulfillmentOrderSplitResult>>;
  userErrors: Array<FulfillmentOrderSplitUserError>;
};

export type FulfillmentOrderSplitResult = {
  fulfillmentOrder: FulfillmentOrder;
  remainingFulfillmentOrder: FulfillmentOrder;
  replacementFulfillmentOrder?: Maybe<FulfillmentOrder>;
};

export type FulfillmentOrderSplitUserError = DisplayableError & {
  code?: Maybe<FulfillmentOrderSplitUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const FulfillmentOrderSplitUserErrorCode = {
  FulfillmentOrderNotFound: 'FULFILLMENT_ORDER_NOT_FOUND',
  GreaterThan: 'GREATER_THAN',
  InvalidLineItemQuantity: 'INVALID_LINE_ITEM_QUANTITY',
  NoLineItemsProvidedToSplit: 'NO_LINE_ITEMS_PROVIDED_TO_SPLIT'
} as const;

export type FulfillmentOrderSplitUserErrorCode = typeof FulfillmentOrderSplitUserErrorCode[keyof typeof FulfillmentOrderSplitUserErrorCode];
export const FulfillmentOrderStatus = {
  Cancelled: 'CANCELLED',
  Closed: 'CLOSED',
  Incomplete: 'INCOMPLETE',
  InProgress: 'IN_PROGRESS',
  OnHold: 'ON_HOLD',
  Open: 'OPEN',
  Scheduled: 'SCHEDULED'
} as const;

export type FulfillmentOrderStatus = typeof FulfillmentOrderStatus[keyof typeof FulfillmentOrderStatus];
export type FulfillmentOrderSubmitCancellationRequestPayload = {
  fulfillmentOrder?: Maybe<FulfillmentOrder>;
  userErrors: Array<UserError>;
};

export type FulfillmentOrderSubmitFulfillmentRequestPayload = {
  originalFulfillmentOrder?: Maybe<FulfillmentOrder>;
  submittedFulfillmentOrder?: Maybe<FulfillmentOrder>;
  unsubmittedFulfillmentOrder?: Maybe<FulfillmentOrder>;
  userErrors: Array<UserError>;
};

export type FulfillmentOrderSupportedAction = {
  action: FulfillmentOrderAction;
  externalUrl?: Maybe<Scalars['URL']['output']>;
};

export type FulfillmentOrdersSetFulfillmentDeadlinePayload = {
  success?: Maybe<Scalars['Boolean']['output']>;
  userErrors: Array<FulfillmentOrdersSetFulfillmentDeadlineUserError>;
};

export type FulfillmentOrdersSetFulfillmentDeadlineUserError = DisplayableError & {
  code?: Maybe<FulfillmentOrdersSetFulfillmentDeadlineUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const FulfillmentOrdersSetFulfillmentDeadlineUserErrorCode = {
  FulfillmentOrdersNotFound: 'FULFILLMENT_ORDERS_NOT_FOUND'
} as const;

export type FulfillmentOrdersSetFulfillmentDeadlineUserErrorCode = typeof FulfillmentOrdersSetFulfillmentDeadlineUserErrorCode[keyof typeof FulfillmentOrdersSetFulfillmentDeadlineUserErrorCode];
export type FulfillmentOriginAddress = {
  address1?: Maybe<Scalars['String']['output']>;
  address2?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  countryCode: Scalars['String']['output'];
  provinceCode?: Maybe<Scalars['String']['output']>;
  zip?: Maybe<Scalars['String']['output']>;
};

export type FulfillmentOriginAddressInput = {
  address1?: InputMaybe<Scalars['String']['input']>;
  address2?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  countryCode: Scalars['String']['input'];
  provinceCode?: InputMaybe<Scalars['String']['input']>;
  zip?: InputMaybe<Scalars['String']['input']>;
};

export type FulfillmentService = {
  callbackUrl?: Maybe<Scalars['URL']['output']>;
  /** @deprecated Migration period ended. All correctly functioning fulfillment services have `fulfillmentOrdersOptIn` set to `true`. */
  fulfillmentOrdersOptIn: Scalars['Boolean']['output'];
  handle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  inventoryManagement: Scalars['Boolean']['output'];
  location?: Maybe<Location>;
  permitsSkuSharing: Scalars['Boolean']['output'];
  serviceName: Scalars['String']['output'];
  trackingSupport: Scalars['Boolean']['output'];
  type: FulfillmentServiceType;
};

export type FulfillmentServiceCreatePayload = {
  fulfillmentService?: Maybe<FulfillmentService>;
  userErrors: Array<UserError>;
};

export const FulfillmentServiceDeleteInventoryAction = {
  Delete: 'DELETE',
  Keep: 'KEEP',
  Transfer: 'TRANSFER'
} as const;

export type FulfillmentServiceDeleteInventoryAction = typeof FulfillmentServiceDeleteInventoryAction[keyof typeof FulfillmentServiceDeleteInventoryAction];
export type FulfillmentServiceDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<UserError>;
};

export const FulfillmentServiceType = {
  GiftCard: 'GIFT_CARD',
  Manual: 'MANUAL',
  ThirdParty: 'THIRD_PARTY'
} as const;

export type FulfillmentServiceType = typeof FulfillmentServiceType[keyof typeof FulfillmentServiceType];
export type FulfillmentServiceUpdatePayload = {
  fulfillmentService?: Maybe<FulfillmentService>;
  userErrors: Array<UserError>;
};

export const FulfillmentStatus = {
  Cancelled: 'CANCELLED',
  Error: 'ERROR',
  Failure: 'FAILURE',
  Open: 'OPEN',
  Pending: 'PENDING',
  Success: 'SUCCESS'
} as const;

export type FulfillmentStatus = typeof FulfillmentStatus[keyof typeof FulfillmentStatus];
export type FulfillmentTrackingInfo = {
  company?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['URL']['output']>;
};

export type FulfillmentTrackingInfoUpdatePayload = {
  fulfillment?: Maybe<Fulfillment>;
  userErrors: Array<UserError>;
};

export type FulfillmentTrackingInfoUpdateV2Payload = {
  fulfillment?: Maybe<Fulfillment>;
  userErrors: Array<UserError>;
};

export type FulfillmentTrackingInput = {
  company?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  numbers?: InputMaybe<Array<Scalars['String']['input']>>;
  url?: InputMaybe<Scalars['URL']['input']>;
  urls?: InputMaybe<Array<Scalars['URL']['input']>>;
};

export type FulfillmentV2Input = {
  lineItemsByFulfillmentOrder: Array<FulfillmentOrderLineItemsInput>;
  notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  originAddress?: InputMaybe<FulfillmentOriginAddressInput>;
  trackingInfo?: InputMaybe<FulfillmentTrackingInput>;
};

export type FunctionsAppBridge = {
  createPath: Scalars['String']['output'];
  detailsPath: Scalars['String']['output'];
};

export type FunctionsErrorHistory = {
  errorsFirstOccurredAt: Scalars['DateTime']['output'];
  firstOccurredAt: Scalars['DateTime']['output'];
  hasBeenSharedSinceLastError: Scalars['Boolean']['output'];
  hasSharedRecentErrors: Scalars['Boolean']['output'];
};

export type GenericFile = File & Node & {
  alt?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  fileErrors: Array<FileError>;
  fileStatus: FileStatus;
  id: Scalars['ID']['output'];
  mimeType?: Maybe<Scalars['String']['output']>;
  originalFileSize?: Maybe<Scalars['Int']['output']>;
  preview?: Maybe<MediaPreviewImage>;
  updatedAt: Scalars['DateTime']['output'];
  url?: Maybe<Scalars['URL']['output']>;
};

export type GiftCard = Node & {
  balance: MoneyV2;
  createdAt: Scalars['DateTime']['output'];
  customer?: Maybe<Customer>;
  deactivatedAt?: Maybe<Scalars['DateTime']['output']>;
  enabled: Scalars['Boolean']['output'];
  expiresOn?: Maybe<Scalars['Date']['output']>;
  id: Scalars['ID']['output'];
  initialValue: MoneyV2;
  lastCharacters: Scalars['String']['output'];
  maskedCode: Scalars['String']['output'];
  note?: Maybe<Scalars['String']['output']>;
  order?: Maybe<Order>;
  recipientAttributes?: Maybe<GiftCardRecipient>;
  templateSuffix?: Maybe<Scalars['String']['output']>;
  transactions?: Maybe<GiftCardTransactionConnection>;
  updatedAt: Scalars['DateTime']['output'];
};


export type GiftCardTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GiftCardConnection = {
  edges: Array<GiftCardEdge>;
  nodes: Array<GiftCard>;
  pageInfo: PageInfo;
};

export type GiftCardCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  customerId?: InputMaybe<Scalars['ID']['input']>;
  expiresOn?: InputMaybe<Scalars['Date']['input']>;
  initialValue: Scalars['Decimal']['input'];
  note?: InputMaybe<Scalars['String']['input']>;
  recipientAttributes?: InputMaybe<GiftCardRecipientInput>;
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
};

export type GiftCardCreatePayload = {
  giftCard?: Maybe<GiftCard>;
  giftCardCode?: Maybe<Scalars['String']['output']>;
  userErrors: Array<GiftCardUserError>;
};

export type GiftCardCreditInput = {
  creditAmount: MoneyInput;
  note?: InputMaybe<Scalars['String']['input']>;
  processedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GiftCardCreditPayload = {
  giftCardCreditTransaction?: Maybe<GiftCardCreditTransaction>;
  userErrors: Array<GiftCardTransactionUserError>;
};

export type GiftCardCreditTransaction = GiftCardTransaction & HasMetafields & Node & {
  amount: MoneyV2;
  giftCard: GiftCard;
  id: Scalars['ID']['output'];
  metafield?: Maybe<Metafield>;
  metafields: MetafieldConnection;
  note?: Maybe<Scalars['String']['output']>;
  processedAt: Scalars['DateTime']['output'];
};


export type GiftCardCreditTransactionMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type GiftCardCreditTransactionMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GiftCardDeactivatePayload = {
  giftCard?: Maybe<GiftCard>;
  userErrors: Array<GiftCardDeactivateUserError>;
};

export type GiftCardDeactivateUserError = DisplayableError & {
  code?: Maybe<GiftCardDeactivateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const GiftCardDeactivateUserErrorCode = {
  GiftCardNotFound: 'GIFT_CARD_NOT_FOUND'
} as const;

export type GiftCardDeactivateUserErrorCode = typeof GiftCardDeactivateUserErrorCode[keyof typeof GiftCardDeactivateUserErrorCode];
export type GiftCardDebitInput = {
  debitAmount: MoneyInput;
  note?: InputMaybe<Scalars['String']['input']>;
  processedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GiftCardDebitPayload = {
  giftCardDebitTransaction?: Maybe<GiftCardDebitTransaction>;
  userErrors: Array<GiftCardTransactionUserError>;
};

export type GiftCardDebitTransaction = GiftCardTransaction & HasMetafields & Node & {
  amount: MoneyV2;
  giftCard: GiftCard;
  id: Scalars['ID']['output'];
  metafield?: Maybe<Metafield>;
  metafields: MetafieldConnection;
  note?: Maybe<Scalars['String']['output']>;
  processedAt: Scalars['DateTime']['output'];
};


export type GiftCardDebitTransactionMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type GiftCardDebitTransactionMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GiftCardEdge = {
  cursor: Scalars['String']['output'];
  node: GiftCard;
};

export const GiftCardErrorCode = {
  CustomerNotFound: 'CUSTOMER_NOT_FOUND',
  GiftCardLimitExceeded: 'GIFT_CARD_LIMIT_EXCEEDED',
  GreaterThan: 'GREATER_THAN',
  InternalError: 'INTERNAL_ERROR',
  Invalid: 'INVALID',
  MissingArgument: 'MISSING_ARGUMENT',
  RecipientNotFound: 'RECIPIENT_NOT_FOUND',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  TooShort: 'TOO_SHORT'
} as const;

export type GiftCardErrorCode = typeof GiftCardErrorCode[keyof typeof GiftCardErrorCode];
export type GiftCardRecipient = {
  message?: Maybe<Scalars['String']['output']>;
  preferredName?: Maybe<Scalars['String']['output']>;
  recipient: Customer;
  sendNotificationAt?: Maybe<Scalars['DateTime']['output']>;
};

export type GiftCardRecipientInput = {
  id: Scalars['ID']['input'];
  message?: InputMaybe<Scalars['String']['input']>;
  preferredName?: InputMaybe<Scalars['String']['input']>;
  sendNotificationAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type GiftCardSale = Sale & {
  actionType: SaleActionType;
  id: Scalars['ID']['output'];
  lineItem: LineItem;
  lineType: SaleLineType;
  quantity?: Maybe<Scalars['Int']['output']>;
  taxes: Array<SaleTax>;
  totalAmount: MoneyBag;
  totalDiscountAmountAfterTaxes: MoneyBag;
  totalDiscountAmountBeforeTaxes: MoneyBag;
  totalTaxAmount: MoneyBag;
};

export type GiftCardSendNotificationToCustomerPayload = {
  giftCard?: Maybe<GiftCard>;
  userErrors: Array<GiftCardSendNotificationToCustomerUserError>;
};

export type GiftCardSendNotificationToCustomerUserError = DisplayableError & {
  code?: Maybe<GiftCardSendNotificationToCustomerUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const GiftCardSendNotificationToCustomerUserErrorCode = {
  CustomerNotFound: 'CUSTOMER_NOT_FOUND',
  GiftCardNotFound: 'GIFT_CARD_NOT_FOUND',
  Invalid: 'INVALID'
} as const;

export type GiftCardSendNotificationToCustomerUserErrorCode = typeof GiftCardSendNotificationToCustomerUserErrorCode[keyof typeof GiftCardSendNotificationToCustomerUserErrorCode];
export type GiftCardSendNotificationToRecipientPayload = {
  giftCard?: Maybe<GiftCard>;
  userErrors: Array<GiftCardSendNotificationToRecipientUserError>;
};

export type GiftCardSendNotificationToRecipientUserError = DisplayableError & {
  code?: Maybe<GiftCardSendNotificationToRecipientUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const GiftCardSendNotificationToRecipientUserErrorCode = {
  GiftCardNotFound: 'GIFT_CARD_NOT_FOUND',
  Invalid: 'INVALID',
  RecipientNotFound: 'RECIPIENT_NOT_FOUND'
} as const;

export type GiftCardSendNotificationToRecipientUserErrorCode = typeof GiftCardSendNotificationToRecipientUserErrorCode[keyof typeof GiftCardSendNotificationToRecipientUserErrorCode];
export const GiftCardSortKeys = {
  AmountSpent: 'AMOUNT_SPENT',
  Balance: 'BALANCE',
  Code: 'CODE',
  CreatedAt: 'CREATED_AT',
  CustomerName: 'CUSTOMER_NAME',
  DisabledAt: 'DISABLED_AT',
  ExpiresOn: 'EXPIRES_ON',
  Id: 'ID',
  InitialValue: 'INITIAL_VALUE',
  Relevance: 'RELEVANCE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type GiftCardSortKeys = typeof GiftCardSortKeys[keyof typeof GiftCardSortKeys];
export type GiftCardTransaction = {
  amount: MoneyV2;
  giftCard: GiftCard;
  id: Scalars['ID']['output'];
  metafield?: Maybe<Metafield>;
  metafields: MetafieldConnection;
  note?: Maybe<Scalars['String']['output']>;
  processedAt: Scalars['DateTime']['output'];
};


export type GiftCardTransactionMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type GiftCardTransactionMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GiftCardTransactionConnection = {
  edges: Array<GiftCardTransactionEdge>;
  nodes: Array<GiftCardTransaction>;
  pageInfo: PageInfo;
};

export type GiftCardTransactionEdge = {
  cursor: Scalars['String']['output'];
  node: GiftCardTransaction;
};

export type GiftCardTransactionUserError = DisplayableError & {
  code?: Maybe<GiftCardTransactionUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const GiftCardTransactionUserErrorCode = {
  GiftCardLimitExceeded: 'GIFT_CARD_LIMIT_EXCEEDED',
  GiftCardNotFound: 'GIFT_CARD_NOT_FOUND',
  InsufficientFunds: 'INSUFFICIENT_FUNDS',
  InternalError: 'INTERNAL_ERROR',
  Invalid: 'INVALID',
  MismatchingCurrency: 'MISMATCHING_CURRENCY',
  NegativeOrZeroAmount: 'NEGATIVE_OR_ZERO_AMOUNT'
} as const;

export type GiftCardTransactionUserErrorCode = typeof GiftCardTransactionUserErrorCode[keyof typeof GiftCardTransactionUserErrorCode];
export type GiftCardUpdateInput = {
  customerId?: InputMaybe<Scalars['ID']['input']>;
  expiresOn?: InputMaybe<Scalars['Date']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  recipientAttributes?: InputMaybe<GiftCardRecipientInput>;
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
};

export type GiftCardUpdatePayload = {
  giftCard?: Maybe<GiftCard>;
  userErrors: Array<UserError>;
};

export type GiftCardUserError = DisplayableError & {
  code?: Maybe<GiftCardErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type HasCompareDigest = {
  compareDigest: Scalars['String']['output'];
};

export type HasEvents = {
  events: EventConnection;
};


export type HasEventsEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};

export type HasLocalizationExtensions = {
  /** @deprecated This connection will be removed in a future version. Use `localizedFields` instead. */
  localizationExtensions: LocalizationExtensionConnection;
};


export type HasLocalizationExtensionsLocalizationExtensionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  countryCodes?: InputMaybe<Array<CountryCode>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  purposes?: InputMaybe<Array<LocalizationExtensionPurpose>>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type HasLocalizedFields = {
  localizedFields: LocalizedFieldConnection;
};


export type HasLocalizedFieldsLocalizedFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  countryCodes?: InputMaybe<Array<CountryCode>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  purposes?: InputMaybe<Array<LocalizedFieldPurpose>>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type HasMetafieldDefinitions = {
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
};


export type HasMetafieldDefinitionsMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};

export type HasMetafields = {
  metafield?: Maybe<Metafield>;
  metafields: MetafieldConnection;
};


export type HasMetafieldsMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type HasMetafieldsMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type HasPublishedTranslations = {
  translations: Array<Translation>;
};


export type HasPublishedTranslationsTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export type HasStoreCreditAccounts = {
  storeCreditAccounts: StoreCreditAccountConnection;
};


export type HasStoreCreditAccountsStoreCreditAccountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};

export type Image = HasMetafields & {
  altText?: Maybe<Scalars['String']['output']>;
  height?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['ID']['output']>;
  metafield?: Maybe<Metafield>;
  metafields: MetafieldConnection;
  /** @deprecated Use `url` instead. */
  originalSrc: Scalars['URL']['output'];
  /** @deprecated Use `url` instead. */
  src: Scalars['URL']['output'];
  /** @deprecated Use `url(transform:)` instead */
  transformedSrc: Scalars['URL']['output'];
  url: Scalars['URL']['output'];
  width?: Maybe<Scalars['Int']['output']>;
};


export type ImageMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type ImageMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ImageTransformedSrcArgs = {
  crop?: InputMaybe<CropRegion>;
  maxHeight?: InputMaybe<Scalars['Int']['input']>;
  maxWidth?: InputMaybe<Scalars['Int']['input']>;
  preferredContentType?: InputMaybe<ImageContentType>;
  scale?: InputMaybe<Scalars['Int']['input']>;
};


export type ImageUrlArgs = {
  transform?: InputMaybe<ImageTransformInput>;
};

export type ImageConnection = {
  edges: Array<ImageEdge>;
  nodes: Array<Image>;
  pageInfo: PageInfo;
};

export const ImageContentType = {
  Jpg: 'JPG',
  Png: 'PNG',
  Webp: 'WEBP'
} as const;

export type ImageContentType = typeof ImageContentType[keyof typeof ImageContentType];
export type ImageEdge = {
  cursor: Scalars['String']['output'];
  node: Image;
};

export type ImageInput = {
  altText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  src?: InputMaybe<Scalars['String']['input']>;
};

export type ImageTransformInput = {
  crop?: InputMaybe<CropRegion>;
  maxHeight?: InputMaybe<Scalars['Int']['input']>;
  maxWidth?: InputMaybe<Scalars['Int']['input']>;
  preferredContentType?: InputMaybe<ImageContentType>;
  scale?: InputMaybe<Scalars['Int']['input']>;
};

export type ImageUploadParameter = {
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type IncomingRequestLineItemInput = {
  fulfillmentOrderLineItemId: Scalars['ID']['input'];
  message?: InputMaybe<Scalars['String']['input']>;
};

export type InventoryActivatePayload = {
  inventoryLevel?: Maybe<InventoryLevel>;
  userErrors: Array<UserError>;
};

export type InventoryAdjustQuantitiesInput = {
  changes: Array<InventoryChangeInput>;
  name: Scalars['String']['input'];
  reason: Scalars['String']['input'];
  referenceDocumentUri?: InputMaybe<Scalars['String']['input']>;
};

export type InventoryAdjustQuantitiesPayload = {
  inventoryAdjustmentGroup?: Maybe<InventoryAdjustmentGroup>;
  userErrors: Array<InventoryAdjustQuantitiesUserError>;
};

export type InventoryAdjustQuantitiesUserError = DisplayableError & {
  code?: Maybe<InventoryAdjustQuantitiesUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const InventoryAdjustQuantitiesUserErrorCode = {
  AdjustQuantitiesFailed: 'ADJUST_QUANTITIES_FAILED',
  InternalLedgerDocument: 'INTERNAL_LEDGER_DOCUMENT',
  InvalidAvailableDocument: 'INVALID_AVAILABLE_DOCUMENT',
  InvalidInventoryItem: 'INVALID_INVENTORY_ITEM',
  InvalidLedgerDocument: 'INVALID_LEDGER_DOCUMENT',
  InvalidLocation: 'INVALID_LOCATION',
  InvalidQuantityDocument: 'INVALID_QUANTITY_DOCUMENT',
  InvalidQuantityName: 'INVALID_QUANTITY_NAME',
  InvalidQuantityTooHigh: 'INVALID_QUANTITY_TOO_HIGH',
  InvalidQuantityTooLow: 'INVALID_QUANTITY_TOO_LOW',
  InvalidReason: 'INVALID_REASON',
  InvalidReferenceDocument: 'INVALID_REFERENCE_DOCUMENT',
  ItemNotStockedAtLocation: 'ITEM_NOT_STOCKED_AT_LOCATION',
  MaxOneLedgerDocument: 'MAX_ONE_LEDGER_DOCUMENT',
  NonMutableInventoryItem: 'NON_MUTABLE_INVENTORY_ITEM'
} as const;

export type InventoryAdjustQuantitiesUserErrorCode = typeof InventoryAdjustQuantitiesUserErrorCode[keyof typeof InventoryAdjustQuantitiesUserErrorCode];
export type InventoryAdjustmentGroup = Node & {
  app?: Maybe<App>;
  changes: Array<InventoryChange>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  reason: Scalars['String']['output'];
  referenceDocumentUri?: Maybe<Scalars['String']['output']>;
  staffMember?: Maybe<StaffMember>;
};


export type InventoryAdjustmentGroupChangesArgs = {
  inventoryItemIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  locationIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  quantityNames?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type InventoryBulkToggleActivationInput = {
  activate: Scalars['Boolean']['input'];
  locationId: Scalars['ID']['input'];
};

export type InventoryBulkToggleActivationPayload = {
  inventoryItem?: Maybe<InventoryItem>;
  inventoryLevels?: Maybe<Array<InventoryLevel>>;
  userErrors: Array<InventoryBulkToggleActivationUserError>;
};

export type InventoryBulkToggleActivationUserError = DisplayableError & {
  code?: Maybe<InventoryBulkToggleActivationUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const InventoryBulkToggleActivationUserErrorCode = {
  CannotDeactivateFromOnlyLocation: 'CANNOT_DEACTIVATE_FROM_ONLY_LOCATION',
  CommittedAndIncomingInventoryAtLocation: 'COMMITTED_AND_INCOMING_INVENTORY_AT_LOCATION',
  CommittedInventoryAtLocation: 'COMMITTED_INVENTORY_AT_LOCATION',
  FailedToStockAtLocation: 'FAILED_TO_STOCK_AT_LOCATION',
  FailedToUnstockFromLocation: 'FAILED_TO_UNSTOCK_FROM_LOCATION',
  GenericError: 'GENERIC_ERROR',
  IncomingInventoryAtLocation: 'INCOMING_INVENTORY_AT_LOCATION',
  InventoryItemNotFound: 'INVENTORY_ITEM_NOT_FOUND',
  InventoryManagedBy_3RdParty: 'INVENTORY_MANAGED_BY_3RD_PARTY',
  InventoryManagedByShopify: 'INVENTORY_MANAGED_BY_SHOPIFY',
  LocationNotFound: 'LOCATION_NOT_FOUND',
  MissingSku: 'MISSING_SKU',
  ReservedInventoryAtLocation: 'RESERVED_INVENTORY_AT_LOCATION'
} as const;

export type InventoryBulkToggleActivationUserErrorCode = typeof InventoryBulkToggleActivationUserErrorCode[keyof typeof InventoryBulkToggleActivationUserErrorCode];
export type InventoryChange = {
  delta: Scalars['Int']['output'];
  item?: Maybe<InventoryItem>;
  ledgerDocumentUri?: Maybe<Scalars['String']['output']>;
  location?: Maybe<Location>;
  name: Scalars['String']['output'];
  quantityAfterChange?: Maybe<Scalars['Int']['output']>;
};

export type InventoryChangeInput = {
  delta: Scalars['Int']['input'];
  inventoryItemId: Scalars['ID']['input'];
  ledgerDocumentUri?: InputMaybe<Scalars['String']['input']>;
  locationId: Scalars['ID']['input'];
};

export type InventoryDeactivatePayload = {
  userErrors: Array<UserError>;
};

export type InventoryItem = LegacyInteroperability & Node & {
  countryCodeOfOrigin?: Maybe<CountryCode>;
  countryHarmonizedSystemCodes: CountryHarmonizedSystemCodeConnection;
  createdAt: Scalars['DateTime']['output'];
  duplicateSkuCount: Scalars['Int']['output'];
  harmonizedSystemCode?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  inventoryHistoryUrl?: Maybe<Scalars['URL']['output']>;
  inventoryLevel?: Maybe<InventoryLevel>;
  inventoryLevels: InventoryLevelConnection;
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  locationsCount?: Maybe<Count>;
  measurement: InventoryItemMeasurement;
  provinceCodeOfOrigin?: Maybe<Scalars['String']['output']>;
  requiresShipping: Scalars['Boolean']['output'];
  sku?: Maybe<Scalars['String']['output']>;
  tracked: Scalars['Boolean']['output'];
  trackedEditable: EditableProperty;
  unitCost?: Maybe<MoneyV2>;
  updatedAt: Scalars['DateTime']['output'];
  variant: ProductVariant;
};


export type InventoryItemCountryHarmonizedSystemCodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type InventoryItemInventoryLevelArgs = {
  locationId: Scalars['ID']['input'];
};


export type InventoryItemInventoryLevelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type InventoryItemConnection = {
  edges: Array<InventoryItemEdge>;
  nodes: Array<InventoryItem>;
  pageInfo: PageInfo;
};

export type InventoryItemEdge = {
  cursor: Scalars['String']['output'];
  node: InventoryItem;
};

export type InventoryItemInput = {
  cost?: InputMaybe<Scalars['Decimal']['input']>;
  countryCodeOfOrigin?: InputMaybe<CountryCode>;
  countryHarmonizedSystemCodes?: InputMaybe<Array<CountryHarmonizedSystemCodeInput>>;
  harmonizedSystemCode?: InputMaybe<Scalars['String']['input']>;
  measurement?: InputMaybe<InventoryItemMeasurementInput>;
  provinceCodeOfOrigin?: InputMaybe<Scalars['String']['input']>;
  requiresShipping?: InputMaybe<Scalars['Boolean']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  tracked?: InputMaybe<Scalars['Boolean']['input']>;
};

export type InventoryItemMeasurement = Node & {
  id: Scalars['ID']['output'];
  weight?: Maybe<Weight>;
};

export type InventoryItemMeasurementInput = {
  weight?: InputMaybe<WeightInput>;
};

export type InventoryItemUpdatePayload = {
  inventoryItem?: Maybe<InventoryItem>;
  userErrors: Array<UserError>;
};

export type InventoryLevel = Node & {
  canDeactivate: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  deactivationAlert?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  item: InventoryItem;
  location: Location;
  quantities: Array<InventoryQuantity>;
  scheduledChanges: InventoryScheduledChangeConnection;
  updatedAt: Scalars['DateTime']['output'];
};


export type InventoryLevelQuantitiesArgs = {
  names: Array<Scalars['String']['input']>;
};


export type InventoryLevelScheduledChangesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<ScheduledChangeSortKeys>;
};

export type InventoryLevelConnection = {
  edges: Array<InventoryLevelEdge>;
  nodes: Array<InventoryLevel>;
  pageInfo: PageInfo;
};

export type InventoryLevelEdge = {
  cursor: Scalars['String']['output'];
  node: InventoryLevel;
};

export type InventoryLevelInput = {
  availableQuantity: Scalars['Int']['input'];
  locationId: Scalars['ID']['input'];
};

export type InventoryMoveQuantitiesInput = {
  changes: Array<InventoryMoveQuantityChange>;
  reason: Scalars['String']['input'];
  referenceDocumentUri: Scalars['String']['input'];
};

export type InventoryMoveQuantitiesPayload = {
  inventoryAdjustmentGroup?: Maybe<InventoryAdjustmentGroup>;
  userErrors: Array<InventoryMoveQuantitiesUserError>;
};

export type InventoryMoveQuantitiesUserError = DisplayableError & {
  code?: Maybe<InventoryMoveQuantitiesUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const InventoryMoveQuantitiesUserErrorCode = {
  DifferentLocations: 'DIFFERENT_LOCATIONS',
  InternalLedgerDocument: 'INTERNAL_LEDGER_DOCUMENT',
  InvalidAvailableDocument: 'INVALID_AVAILABLE_DOCUMENT',
  InvalidInventoryItem: 'INVALID_INVENTORY_ITEM',
  InvalidLedgerDocument: 'INVALID_LEDGER_DOCUMENT',
  InvalidLocation: 'INVALID_LOCATION',
  InvalidQuantityDocument: 'INVALID_QUANTITY_DOCUMENT',
  InvalidQuantityName: 'INVALID_QUANTITY_NAME',
  InvalidQuantityNegative: 'INVALID_QUANTITY_NEGATIVE',
  InvalidQuantityTooHigh: 'INVALID_QUANTITY_TOO_HIGH',
  InvalidReason: 'INVALID_REASON',
  InvalidReferenceDocument: 'INVALID_REFERENCE_DOCUMENT',
  ItemNotStockedAtLocation: 'ITEM_NOT_STOCKED_AT_LOCATION',
  MaximumLedgerDocumentUris: 'MAXIMUM_LEDGER_DOCUMENT_URIS',
  MoveQuantitiesFailed: 'MOVE_QUANTITIES_FAILED',
  NonMutableInventoryItem: 'NON_MUTABLE_INVENTORY_ITEM',
  SameQuantityName: 'SAME_QUANTITY_NAME'
} as const;

export type InventoryMoveQuantitiesUserErrorCode = typeof InventoryMoveQuantitiesUserErrorCode[keyof typeof InventoryMoveQuantitiesUserErrorCode];
export type InventoryMoveQuantityChange = {
  from: InventoryMoveQuantityTerminalInput;
  inventoryItemId: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
  to: InventoryMoveQuantityTerminalInput;
};

export type InventoryMoveQuantityTerminalInput = {
  ledgerDocumentUri?: InputMaybe<Scalars['String']['input']>;
  locationId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};

export type InventoryProperties = {
  quantityNames: Array<InventoryQuantityName>;
};

export type InventoryQuantity = Node & {
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type InventoryQuantityInput = {
  compareQuantity?: InputMaybe<Scalars['Int']['input']>;
  inventoryItemId: Scalars['ID']['input'];
  locationId: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
};

export type InventoryQuantityName = {
  belongsTo: Array<Scalars['String']['output']>;
  comprises: Array<Scalars['String']['output']>;
  displayName?: Maybe<Scalars['String']['output']>;
  isInUse: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
};

export type InventoryScheduledChange = {
  expectedAt: Scalars['DateTime']['output'];
  fromName: Scalars['String']['output'];
  inventoryLevel: InventoryLevel;
  ledgerDocumentUri: Scalars['URL']['output'];
  quantity: Scalars['Int']['output'];
  toName: Scalars['String']['output'];
};

export type InventoryScheduledChangeConnection = {
  edges: Array<InventoryScheduledChangeEdge>;
  nodes: Array<InventoryScheduledChange>;
  pageInfo: PageInfo;
};

export type InventoryScheduledChangeEdge = {
  cursor: Scalars['String']['output'];
  node: InventoryScheduledChange;
};

export type InventoryScheduledChangeInput = {
  expectedAt: Scalars['DateTime']['input'];
  fromName: Scalars['String']['input'];
  toName: Scalars['String']['input'];
};

export type InventoryScheduledChangeItemInput = {
  inventoryItemId: Scalars['ID']['input'];
  ledgerDocumentUri: Scalars['URL']['input'];
  locationId: Scalars['ID']['input'];
  scheduledChanges: Array<InventoryScheduledChangeInput>;
};

export type InventorySetOnHandQuantitiesInput = {
  reason: Scalars['String']['input'];
  referenceDocumentUri?: InputMaybe<Scalars['String']['input']>;
  setQuantities: Array<InventorySetQuantityInput>;
};

export type InventorySetOnHandQuantitiesPayload = {
  inventoryAdjustmentGroup?: Maybe<InventoryAdjustmentGroup>;
  userErrors: Array<InventorySetOnHandQuantitiesUserError>;
};

export type InventorySetOnHandQuantitiesUserError = DisplayableError & {
  code?: Maybe<InventorySetOnHandQuantitiesUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const InventorySetOnHandQuantitiesUserErrorCode = {
  InvalidInventoryItem: 'INVALID_INVENTORY_ITEM',
  InvalidLocation: 'INVALID_LOCATION',
  InvalidQuantityNegative: 'INVALID_QUANTITY_NEGATIVE',
  InvalidQuantityTooHigh: 'INVALID_QUANTITY_TOO_HIGH',
  InvalidReason: 'INVALID_REASON',
  InvalidReferenceDocument: 'INVALID_REFERENCE_DOCUMENT',
  ItemNotStockedAtLocation: 'ITEM_NOT_STOCKED_AT_LOCATION',
  NonMutableInventoryItem: 'NON_MUTABLE_INVENTORY_ITEM',
  SetOnHandQuantitiesFailed: 'SET_ON_HAND_QUANTITIES_FAILED'
} as const;

export type InventorySetOnHandQuantitiesUserErrorCode = typeof InventorySetOnHandQuantitiesUserErrorCode[keyof typeof InventorySetOnHandQuantitiesUserErrorCode];
export type InventorySetQuantitiesInput = {
  ignoreCompareQuantity?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  quantities: Array<InventoryQuantityInput>;
  reason: Scalars['String']['input'];
  referenceDocumentUri?: InputMaybe<Scalars['String']['input']>;
};

export type InventorySetQuantitiesPayload = {
  inventoryAdjustmentGroup?: Maybe<InventoryAdjustmentGroup>;
  userErrors: Array<InventorySetQuantitiesUserError>;
};

export type InventorySetQuantitiesUserError = DisplayableError & {
  code?: Maybe<InventorySetQuantitiesUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const InventorySetQuantitiesUserErrorCode = {
  CompareQuantityRequired: 'COMPARE_QUANTITY_REQUIRED',
  CompareQuantityStale: 'COMPARE_QUANTITY_STALE',
  InvalidInventoryItem: 'INVALID_INVENTORY_ITEM',
  InvalidLocation: 'INVALID_LOCATION',
  InvalidName: 'INVALID_NAME',
  InvalidQuantityNegative: 'INVALID_QUANTITY_NEGATIVE',
  InvalidQuantityTooHigh: 'INVALID_QUANTITY_TOO_HIGH',
  InvalidQuantityTooLow: 'INVALID_QUANTITY_TOO_LOW',
  InvalidReason: 'INVALID_REASON',
  InvalidReferenceDocument: 'INVALID_REFERENCE_DOCUMENT',
  ItemNotStockedAtLocation: 'ITEM_NOT_STOCKED_AT_LOCATION',
  NonMutableInventoryItem: 'NON_MUTABLE_INVENTORY_ITEM',
  NoDuplicateInventoryItemIdGroupIdPair: 'NO_DUPLICATE_INVENTORY_ITEM_ID_GROUP_ID_PAIR'
} as const;

export type InventorySetQuantitiesUserErrorCode = typeof InventorySetQuantitiesUserErrorCode[keyof typeof InventorySetQuantitiesUserErrorCode];
export type InventorySetQuantityInput = {
  inventoryItemId: Scalars['ID']['input'];
  locationId: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
};

export type InventorySetScheduledChangesInput = {
  items: Array<InventoryScheduledChangeItemInput>;
  reason: Scalars['String']['input'];
  referenceDocumentUri: Scalars['URL']['input'];
};

export type InventorySetScheduledChangesPayload = {
  scheduledChanges?: Maybe<Array<InventoryScheduledChange>>;
  userErrors: Array<InventorySetScheduledChangesUserError>;
};

export type InventorySetScheduledChangesUserError = DisplayableError & {
  code?: Maybe<InventorySetScheduledChangesUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const InventorySetScheduledChangesUserErrorCode = {
  DuplicateFromName: 'DUPLICATE_FROM_NAME',
  DuplicateToName: 'DUPLICATE_TO_NAME',
  ErrorUpdatingScheduled: 'ERROR_UPDATING_SCHEDULED',
  Inclusion: 'INCLUSION',
  InvalidFromName: 'INVALID_FROM_NAME',
  InvalidReason: 'INVALID_REASON',
  InvalidToName: 'INVALID_TO_NAME',
  InventoryItemNotFound: 'INVENTORY_ITEM_NOT_FOUND',
  InventoryStateNotFound: 'INVENTORY_STATE_NOT_FOUND',
  ItemsEmpty: 'ITEMS_EMPTY',
  LedgerDocumentInvalid: 'LEDGER_DOCUMENT_INVALID',
  LocationNotFound: 'LOCATION_NOT_FOUND',
  SameFromToNames: 'SAME_FROM_TO_NAMES'
} as const;

export type InventorySetScheduledChangesUserErrorCode = typeof InventorySetScheduledChangesUserErrorCode[keyof typeof InventorySetScheduledChangesUserErrorCode];
export type Job = {
  done: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  query?: Maybe<QueryRoot>;
};

export type JobResult = {
  done: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
};

export const LanguageCode = {
  Af: 'AF',
  Ak: 'AK',
  Am: 'AM',
  Ar: 'AR',
  As: 'AS',
  Az: 'AZ',
  Be: 'BE',
  Bg: 'BG',
  Bm: 'BM',
  Bn: 'BN',
  Bo: 'BO',
  Br: 'BR',
  Bs: 'BS',
  Ca: 'CA',
  Ce: 'CE',
  Ckb: 'CKB',
  Cs: 'CS',
  Cu: 'CU',
  Cy: 'CY',
  Da: 'DA',
  De: 'DE',
  Dz: 'DZ',
  Ee: 'EE',
  El: 'EL',
  En: 'EN',
  Eo: 'EO',
  Es: 'ES',
  Et: 'ET',
  Eu: 'EU',
  Fa: 'FA',
  Ff: 'FF',
  Fi: 'FI',
  Fil: 'FIL',
  Fo: 'FO',
  Fr: 'FR',
  Fy: 'FY',
  Ga: 'GA',
  Gd: 'GD',
  Gl: 'GL',
  Gu: 'GU',
  Gv: 'GV',
  Ha: 'HA',
  He: 'HE',
  Hi: 'HI',
  Hr: 'HR',
  Hu: 'HU',
  Hy: 'HY',
  Ia: 'IA',
  Id: 'ID',
  Ig: 'IG',
  Ii: 'II',
  Is: 'IS',
  It: 'IT',
  Ja: 'JA',
  Jv: 'JV',
  Ka: 'KA',
  Ki: 'KI',
  Kk: 'KK',
  Kl: 'KL',
  Km: 'KM',
  Kn: 'KN',
  Ko: 'KO',
  Ks: 'KS',
  Ku: 'KU',
  Kw: 'KW',
  Ky: 'KY',
  Lb: 'LB',
  Lg: 'LG',
  Ln: 'LN',
  Lo: 'LO',
  Lt: 'LT',
  Lu: 'LU',
  Lv: 'LV',
  Mg: 'MG',
  Mi: 'MI',
  Mk: 'MK',
  Ml: 'ML',
  Mn: 'MN',
  Mr: 'MR',
  Ms: 'MS',
  Mt: 'MT',
  My: 'MY',
  Nb: 'NB',
  Nd: 'ND',
  Ne: 'NE',
  Nl: 'NL',
  Nn: 'NN',
  No: 'NO',
  Om: 'OM',
  Or: 'OR',
  Os: 'OS',
  Pa: 'PA',
  Pl: 'PL',
  Ps: 'PS',
  Pt: 'PT',
  PtBr: 'PT_BR',
  PtPt: 'PT_PT',
  Qu: 'QU',
  Rm: 'RM',
  Rn: 'RN',
  Ro: 'RO',
  Ru: 'RU',
  Rw: 'RW',
  Sa: 'SA',
  Sc: 'SC',
  Sd: 'SD',
  Se: 'SE',
  Sg: 'SG',
  Si: 'SI',
  Sk: 'SK',
  Sl: 'SL',
  Sn: 'SN',
  So: 'SO',
  Sq: 'SQ',
  Sr: 'SR',
  Su: 'SU',
  Sv: 'SV',
  Sw: 'SW',
  Ta: 'TA',
  Te: 'TE',
  Tg: 'TG',
  Th: 'TH',
  Ti: 'TI',
  Tk: 'TK',
  To: 'TO',
  Tr: 'TR',
  Tt: 'TT',
  Ug: 'UG',
  Uk: 'UK',
  Ur: 'UR',
  Uz: 'UZ',
  Vi: 'VI',
  Vo: 'VO',
  Wo: 'WO',
  Xh: 'XH',
  Yi: 'YI',
  Yo: 'YO',
  Zh: 'ZH',
  ZhCn: 'ZH_CN',
  ZhTw: 'ZH_TW',
  Zu: 'ZU'
} as const;

export type LanguageCode = typeof LanguageCode[keyof typeof LanguageCode];
export type LegacyInteroperability = {
  legacyResourceId: Scalars['UnsignedInt64']['output'];
};

export const LengthUnit = {
  Centimeters: 'CENTIMETERS',
  Feet: 'FEET',
  Inches: 'INCHES',
  Meters: 'METERS',
  Millimeters: 'MILLIMETERS',
  Yards: 'YARDS'
} as const;

export type LengthUnit = typeof LengthUnit[keyof typeof LengthUnit];
export type LimitedPendingOrderCount = {
  atMax: Scalars['Boolean']['output'];
  count: Scalars['Int']['output'];
};

export type LineItem = Node & {
  /** @deprecated Use `restockable` instead. */
  canRestock: Scalars['Boolean']['output'];
  contract?: Maybe<SubscriptionContract>;
  currentQuantity: Scalars['Int']['output'];
  customAttributes: Array<Attribute>;
  discountAllocations: Array<DiscountAllocation>;
  /** @deprecated Use `discountedTotalSet` instead. */
  discountedTotal: Scalars['Money']['output'];
  discountedTotalSet: MoneyBag;
  /** @deprecated Use `discountedUnitPriceSet` instead. */
  discountedUnitPrice: Scalars['Money']['output'];
  discountedUnitPriceAfterAllDiscountsSet: MoneyBag;
  discountedUnitPriceSet: MoneyBag;
  duties: Array<Duty>;
  /** @deprecated Use [FulfillmentOrderLineItem#remainingQuantity](https://shopify.dev/api/admin-graphql/latest/objects/FulfillmentOrderLineItem#field-fulfillmentorderlineitem-remainingquantity) instead. */
  fulfillableQuantity: Scalars['Int']['output'];
  /**
   * @deprecated
   * The [relationship between a product variant and a fulfillment service was changed in the `2022-07` API version](/changelog/fulfillment-service-sku-sharing). A [ProductVariant](/api/admin-graphql/latest/objects/ProductVariant) can be stocked by multiple fulfillment services. As a result, we recommend that you use the [inventoryItem field](/api/admin-graphql/latest/objects/ProductVariant#field-productvariant-inventoryitem) if you need to determine where a product variant is stocked.
   *
   * If you need to determine whether a product is a gift card, then you should continue to use this field until an alternative is available.
   *
   * Altering the locations which stock a product variant won't change the value of this field for existing orders.
   *
   * Learn about [managing inventory quantities and states](/apps/fulfillment/inventory-management-apps/quantities-states).
   *
   */
  fulfillmentService?: Maybe<FulfillmentService>;
  /** @deprecated Use [FulfillmentOrderLineItem#remainingQuantity](https://shopify.dev/api/admin-graphql/latest/objects/FulfillmentOrderLineItem#field-fulfillmentorderlineitem-remainingquantity) instead */
  fulfillmentStatus: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  image?: Maybe<Image>;
  isGiftCard: Scalars['Boolean']['output'];
  lineItemGroup?: Maybe<LineItemGroup>;
  merchantEditable: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  nonFulfillableQuantity: Scalars['Int']['output'];
  /** @deprecated Use `originalTotalSet` instead. */
  originalTotal: Scalars['Money']['output'];
  originalTotalSet: MoneyBag;
  /** @deprecated Use `originalUnitPriceSet` instead. */
  originalUnitPrice: Scalars['Money']['output'];
  originalUnitPriceSet: MoneyBag;
  product?: Maybe<Product>;
  quantity: Scalars['Int']['output'];
  refundableQuantity: Scalars['Int']['output'];
  requiresShipping: Scalars['Boolean']['output'];
  restockable: Scalars['Boolean']['output'];
  sellingPlan?: Maybe<LineItemSellingPlan>;
  sku?: Maybe<Scalars['String']['output']>;
  staffMember?: Maybe<StaffMember>;
  taxLines: Array<TaxLine>;
  taxable: Scalars['Boolean']['output'];
  title: Scalars['String']['output'];
  /** @deprecated Use `totalDiscountSet` instead. */
  totalDiscount: Scalars['Money']['output'];
  totalDiscountSet: MoneyBag;
  /** @deprecated Use `unfulfilledDiscountedTotalSet` instead. */
  unfulfilledDiscountedTotal: Scalars['Money']['output'];
  unfulfilledDiscountedTotalSet: MoneyBag;
  /** @deprecated Use `unfulfilledOriginalTotalSet` instead. */
  unfulfilledOriginalTotal: Scalars['Money']['output'];
  unfulfilledOriginalTotalSet: MoneyBag;
  unfulfilledQuantity: Scalars['Int']['output'];
  variant?: Maybe<ProductVariant>;
  variantTitle?: Maybe<Scalars['String']['output']>;
  vendor?: Maybe<Scalars['String']['output']>;
};


export type LineItemDiscountedTotalSetArgs = {
  withCodeDiscounts?: InputMaybe<Scalars['Boolean']['input']>;
};


export type LineItemTaxLinesArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};

export type LineItemConnection = {
  edges: Array<LineItemEdge>;
  nodes: Array<LineItem>;
  pageInfo: PageInfo;
};

export type LineItemEdge = {
  cursor: Scalars['String']['output'];
  node: LineItem;
};

export type LineItemGroup = Node & {
  customAttributes: Array<Attribute>;
  id: Scalars['ID']['output'];
  quantity: Scalars['Int']['output'];
  title: Scalars['String']['output'];
  variantId?: Maybe<Scalars['ID']['output']>;
  variantSku?: Maybe<Scalars['String']['output']>;
};

export type LineItemSellingPlan = {
  name: Scalars['String']['output'];
  sellingPlanId?: Maybe<Scalars['ID']['output']>;
};

export type Link = HasPublishedTranslations & {
  label: Scalars['String']['output'];
  translations: Array<Translation>;
  url: Scalars['URL']['output'];
};


export type LinkTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export type LinkedMetafield = {
  key?: Maybe<Scalars['String']['output']>;
  namespace?: Maybe<Scalars['String']['output']>;
};

export type LinkedMetafieldCreateInput = {
  key: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type LinkedMetafieldInput = {
  key: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  values: Array<Scalars['String']['input']>;
};

export type LinkedMetafieldUpdateInput = {
  key: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
};

export type LocalPaymentMethodsPaymentDetails = BasePaymentDetails & {
  paymentDescriptor?: Maybe<Scalars['String']['output']>;
  paymentMethodName?: Maybe<Scalars['String']['output']>;
};

export type Locale = {
  isoCode: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export const LocalizableContentType = {
  FileReference: 'FILE_REFERENCE',
  Html: 'HTML',
  InlineRichText: 'INLINE_RICH_TEXT',
  Json: 'JSON',
  JsonString: 'JSON_STRING',
  Link: 'LINK',
  ListFileReference: 'LIST_FILE_REFERENCE',
  ListLink: 'LIST_LINK',
  ListMultiLineTextField: 'LIST_MULTI_LINE_TEXT_FIELD',
  ListSingleLineTextField: 'LIST_SINGLE_LINE_TEXT_FIELD',
  ListUrl: 'LIST_URL',
  MultiLineTextField: 'MULTI_LINE_TEXT_FIELD',
  RichTextField: 'RICH_TEXT_FIELD',
  SingleLineTextField: 'SINGLE_LINE_TEXT_FIELD',
  String: 'STRING',
  Uri: 'URI',
  Url: 'URL'
} as const;

export type LocalizableContentType = typeof LocalizableContentType[keyof typeof LocalizableContentType];
export type LocalizationExtension = {
  countryCode: CountryCode;
  key: LocalizationExtensionKey;
  purpose: LocalizationExtensionPurpose;
  title: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type LocalizationExtensionConnection = {
  edges: Array<LocalizationExtensionEdge>;
  nodes: Array<LocalizationExtension>;
  pageInfo: PageInfo;
};

export type LocalizationExtensionEdge = {
  cursor: Scalars['String']['output'];
  node: LocalizationExtension;
};

export type LocalizationExtensionInput = {
  key: LocalizationExtensionKey;
  value: Scalars['String']['input'];
};

export const LocalizationExtensionKey = {
  ShippingCredentialBr: 'SHIPPING_CREDENTIAL_BR',
  ShippingCredentialCl: 'SHIPPING_CREDENTIAL_CL',
  ShippingCredentialCn: 'SHIPPING_CREDENTIAL_CN',
  ShippingCredentialCo: 'SHIPPING_CREDENTIAL_CO',
  ShippingCredentialCr: 'SHIPPING_CREDENTIAL_CR',
  ShippingCredentialEc: 'SHIPPING_CREDENTIAL_EC',
  ShippingCredentialEs: 'SHIPPING_CREDENTIAL_ES',
  ShippingCredentialGt: 'SHIPPING_CREDENTIAL_GT',
  ShippingCredentialId: 'SHIPPING_CREDENTIAL_ID',
  ShippingCredentialKr: 'SHIPPING_CREDENTIAL_KR',
  ShippingCredentialMx: 'SHIPPING_CREDENTIAL_MX',
  ShippingCredentialMy: 'SHIPPING_CREDENTIAL_MY',
  ShippingCredentialPe: 'SHIPPING_CREDENTIAL_PE',
  ShippingCredentialPt: 'SHIPPING_CREDENTIAL_PT',
  ShippingCredentialPy: 'SHIPPING_CREDENTIAL_PY',
  ShippingCredentialTr: 'SHIPPING_CREDENTIAL_TR',
  ShippingCredentialTw: 'SHIPPING_CREDENTIAL_TW',
  ShippingCredentialTypeCo: 'SHIPPING_CREDENTIAL_TYPE_CO',
  TaxCredentialBr: 'TAX_CREDENTIAL_BR',
  TaxCredentialCl: 'TAX_CREDENTIAL_CL',
  TaxCredentialCo: 'TAX_CREDENTIAL_CO',
  TaxCredentialCr: 'TAX_CREDENTIAL_CR',
  TaxCredentialEc: 'TAX_CREDENTIAL_EC',
  TaxCredentialEs: 'TAX_CREDENTIAL_ES',
  TaxCredentialGt: 'TAX_CREDENTIAL_GT',
  TaxCredentialId: 'TAX_CREDENTIAL_ID',
  TaxCredentialIt: 'TAX_CREDENTIAL_IT',
  TaxCredentialMx: 'TAX_CREDENTIAL_MX',
  TaxCredentialMy: 'TAX_CREDENTIAL_MY',
  TaxCredentialPe: 'TAX_CREDENTIAL_PE',
  TaxCredentialPt: 'TAX_CREDENTIAL_PT',
  TaxCredentialPy: 'TAX_CREDENTIAL_PY',
  TaxCredentialTr: 'TAX_CREDENTIAL_TR',
  TaxCredentialTypeCo: 'TAX_CREDENTIAL_TYPE_CO',
  TaxCredentialTypeMx: 'TAX_CREDENTIAL_TYPE_MX',
  TaxCredentialUseMx: 'TAX_CREDENTIAL_USE_MX',
  TaxEmailIt: 'TAX_EMAIL_IT'
} as const;

export type LocalizationExtensionKey = typeof LocalizationExtensionKey[keyof typeof LocalizationExtensionKey];
export const LocalizationExtensionPurpose = {
  Shipping: 'SHIPPING',
  Tax: 'TAX'
} as const;

export type LocalizationExtensionPurpose = typeof LocalizationExtensionPurpose[keyof typeof LocalizationExtensionPurpose];
export type LocalizedField = {
  countryCode: CountryCode;
  key: LocalizedFieldKey;
  purpose: LocalizedFieldPurpose;
  title: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type LocalizedFieldConnection = {
  edges: Array<LocalizedFieldEdge>;
  nodes: Array<LocalizedField>;
  pageInfo: PageInfo;
};

export type LocalizedFieldEdge = {
  cursor: Scalars['String']['output'];
  node: LocalizedField;
};

export type LocalizedFieldInput = {
  key: LocalizedFieldKey;
  value: Scalars['String']['input'];
};

export const LocalizedFieldKey = {
  ShippingCredentialBr: 'SHIPPING_CREDENTIAL_BR',
  ShippingCredentialCl: 'SHIPPING_CREDENTIAL_CL',
  ShippingCredentialCn: 'SHIPPING_CREDENTIAL_CN',
  ShippingCredentialCo: 'SHIPPING_CREDENTIAL_CO',
  ShippingCredentialCr: 'SHIPPING_CREDENTIAL_CR',
  ShippingCredentialEc: 'SHIPPING_CREDENTIAL_EC',
  ShippingCredentialEs: 'SHIPPING_CREDENTIAL_ES',
  ShippingCredentialGt: 'SHIPPING_CREDENTIAL_GT',
  ShippingCredentialId: 'SHIPPING_CREDENTIAL_ID',
  ShippingCredentialKr: 'SHIPPING_CREDENTIAL_KR',
  ShippingCredentialMx: 'SHIPPING_CREDENTIAL_MX',
  ShippingCredentialMy: 'SHIPPING_CREDENTIAL_MY',
  ShippingCredentialPe: 'SHIPPING_CREDENTIAL_PE',
  ShippingCredentialPt: 'SHIPPING_CREDENTIAL_PT',
  ShippingCredentialPy: 'SHIPPING_CREDENTIAL_PY',
  ShippingCredentialTr: 'SHIPPING_CREDENTIAL_TR',
  ShippingCredentialTw: 'SHIPPING_CREDENTIAL_TW',
  ShippingCredentialTypeCo: 'SHIPPING_CREDENTIAL_TYPE_CO',
  TaxCredentialBr: 'TAX_CREDENTIAL_BR',
  TaxCredentialCl: 'TAX_CREDENTIAL_CL',
  TaxCredentialCo: 'TAX_CREDENTIAL_CO',
  TaxCredentialCr: 'TAX_CREDENTIAL_CR',
  TaxCredentialEc: 'TAX_CREDENTIAL_EC',
  TaxCredentialEs: 'TAX_CREDENTIAL_ES',
  TaxCredentialGt: 'TAX_CREDENTIAL_GT',
  TaxCredentialId: 'TAX_CREDENTIAL_ID',
  TaxCredentialIt: 'TAX_CREDENTIAL_IT',
  TaxCredentialMx: 'TAX_CREDENTIAL_MX',
  TaxCredentialMy: 'TAX_CREDENTIAL_MY',
  TaxCredentialPe: 'TAX_CREDENTIAL_PE',
  TaxCredentialPt: 'TAX_CREDENTIAL_PT',
  TaxCredentialPy: 'TAX_CREDENTIAL_PY',
  TaxCredentialTr: 'TAX_CREDENTIAL_TR',
  TaxCredentialTypeCo: 'TAX_CREDENTIAL_TYPE_CO',
  TaxCredentialTypeMx: 'TAX_CREDENTIAL_TYPE_MX',
  TaxCredentialUseMx: 'TAX_CREDENTIAL_USE_MX',
  TaxEmailIt: 'TAX_EMAIL_IT'
} as const;

export type LocalizedFieldKey = typeof LocalizedFieldKey[keyof typeof LocalizedFieldKey];
export const LocalizedFieldPurpose = {
  Shipping: 'SHIPPING',
  Tax: 'TAX'
} as const;

export type LocalizedFieldPurpose = typeof LocalizedFieldPurpose[keyof typeof LocalizedFieldPurpose];
export type Location = HasMetafieldDefinitions & HasMetafields & LegacyInteroperability & Node & {
  activatable: Scalars['Boolean']['output'];
  address: LocationAddress;
  addressVerified: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  deactivatable: Scalars['Boolean']['output'];
  deactivatedAt?: Maybe<Scalars['String']['output']>;
  deletable: Scalars['Boolean']['output'];
  fulfillmentService?: Maybe<FulfillmentService>;
  fulfillsOnlineOrders: Scalars['Boolean']['output'];
  hasActiveInventory: Scalars['Boolean']['output'];
  hasUnfulfilledOrders: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  inventoryLevel?: Maybe<InventoryLevel>;
  inventoryLevels: InventoryLevelConnection;
  isActive: Scalars['Boolean']['output'];
  isFulfillmentService: Scalars['Boolean']['output'];
  /** @deprecated The concept of a primary location is deprecated, shipsInventory can be used to get a fallback location */
  isPrimary: Scalars['Boolean']['output'];
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  localPickupSettingsV2?: Maybe<DeliveryLocalPickupSettings>;
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  name: Scalars['String']['output'];
  shipsInventory: Scalars['Boolean']['output'];
  suggestedAddresses: Array<LocationSuggestedAddress>;
  updatedAt: Scalars['DateTime']['output'];
};


export type LocationInventoryLevelArgs = {
  inventoryItemId: Scalars['ID']['input'];
};


export type LocationInventoryLevelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type LocationMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type LocationMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type LocationMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type LocationActivatePayload = {
  location?: Maybe<Location>;
  locationActivateUserErrors: Array<LocationActivateUserError>;
};

export type LocationActivateUserError = DisplayableError & {
  code?: Maybe<LocationActivateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const LocationActivateUserErrorCode = {
  GenericError: 'GENERIC_ERROR',
  HasNonUniqueName: 'HAS_NON_UNIQUE_NAME',
  HasOngoingRelocation: 'HAS_ONGOING_RELOCATION',
  LocationLimit: 'LOCATION_LIMIT',
  LocationNotFound: 'LOCATION_NOT_FOUND'
} as const;

export type LocationActivateUserErrorCode = typeof LocationActivateUserErrorCode[keyof typeof LocationActivateUserErrorCode];
export type LocationAddAddressInput = {
  address1?: InputMaybe<Scalars['String']['input']>;
  address2?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  countryCode: CountryCode;
  phone?: InputMaybe<Scalars['String']['input']>;
  provinceCode?: InputMaybe<Scalars['String']['input']>;
  zip?: InputMaybe<Scalars['String']['input']>;
};

export type LocationAddInput = {
  address: LocationAddAddressInput;
  fulfillsOnlineOrders?: InputMaybe<Scalars['Boolean']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  name: Scalars['String']['input'];
};

export type LocationAddPayload = {
  location?: Maybe<Location>;
  userErrors: Array<LocationAddUserError>;
};

export type LocationAddUserError = DisplayableError & {
  code?: Maybe<LocationAddUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const LocationAddUserErrorCode = {
  AppNotAuthorized: 'APP_NOT_AUTHORIZED',
  Blank: 'BLANK',
  CapabilityViolation: 'CAPABILITY_VIOLATION',
  DisallowedOwnerType: 'DISALLOWED_OWNER_TYPE',
  GenericError: 'GENERIC_ERROR',
  Inclusion: 'INCLUSION',
  InternalError: 'INTERNAL_ERROR',
  Invalid: 'INVALID',
  InvalidType: 'INVALID_TYPE',
  InvalidUsZipcode: 'INVALID_US_ZIPCODE',
  InvalidValue: 'INVALID_VALUE',
  Present: 'PRESENT',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  TooShort: 'TOO_SHORT',
  UnstructuredReservedNamespace: 'UNSTRUCTURED_RESERVED_NAMESPACE'
} as const;

export type LocationAddUserErrorCode = typeof LocationAddUserErrorCode[keyof typeof LocationAddUserErrorCode];
export type LocationAddress = {
  address1?: Maybe<Scalars['String']['output']>;
  address2?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  countryCode?: Maybe<Scalars['String']['output']>;
  formatted: Array<Scalars['String']['output']>;
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  provinceCode?: Maybe<Scalars['String']['output']>;
  zip?: Maybe<Scalars['String']['output']>;
};

export type LocationConnection = {
  edges: Array<LocationEdge>;
  nodes: Array<Location>;
  pageInfo: PageInfo;
};

export type LocationDeactivatePayload = {
  location?: Maybe<Location>;
  locationDeactivateUserErrors: Array<LocationDeactivateUserError>;
};

export type LocationDeactivateUserError = DisplayableError & {
  code?: Maybe<LocationDeactivateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const LocationDeactivateUserErrorCode = {
  CannotDisableOnlineOrderFulfillment: 'CANNOT_DISABLE_ONLINE_ORDER_FULFILLMENT',
  DestinationLocationIsTheSameLocation: 'DESTINATION_LOCATION_IS_THE_SAME_LOCATION',
  DestinationLocationNotFoundOrInactive: 'DESTINATION_LOCATION_NOT_FOUND_OR_INACTIVE',
  FailedToRelocateActiveInventories: 'FAILED_TO_RELOCATE_ACTIVE_INVENTORIES',
  FailedToRelocateIncomingMovements: 'FAILED_TO_RELOCATE_INCOMING_MOVEMENTS',
  FailedToRelocateOpenPurchaseOrders: 'FAILED_TO_RELOCATE_OPEN_PURCHASE_ORDERS',
  HasActiveInventoryError: 'HAS_ACTIVE_INVENTORY_ERROR',
  HasActiveRetailSubscriptions: 'HAS_ACTIVE_RETAIL_SUBSCRIPTIONS',
  HasFulfillmentOrdersError: 'HAS_FULFILLMENT_ORDERS_ERROR',
  HasIncomingMovementsError: 'HAS_INCOMING_MOVEMENTS_ERROR',
  HasOpenPurchaseOrdersError: 'HAS_OPEN_PURCHASE_ORDERS_ERROR',
  LocationNotFound: 'LOCATION_NOT_FOUND',
  PermanentlyBlockedFromDeactivationError: 'PERMANENTLY_BLOCKED_FROM_DEACTIVATION_ERROR',
  TemporarilyBlockedFromDeactivationError: 'TEMPORARILY_BLOCKED_FROM_DEACTIVATION_ERROR'
} as const;

export type LocationDeactivateUserErrorCode = typeof LocationDeactivateUserErrorCode[keyof typeof LocationDeactivateUserErrorCode];
export type LocationDeletePayload = {
  deletedLocationId?: Maybe<Scalars['ID']['output']>;
  locationDeleteUserErrors: Array<LocationDeleteUserError>;
};

export type LocationDeleteUserError = DisplayableError & {
  code?: Maybe<LocationDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const LocationDeleteUserErrorCode = {
  GenericError: 'GENERIC_ERROR',
  LocationHasActiveRetailSubscription: 'LOCATION_HAS_ACTIVE_RETAIL_SUBSCRIPTION',
  LocationHasInventory: 'LOCATION_HAS_INVENTORY',
  LocationHasPendingOrders: 'LOCATION_HAS_PENDING_ORDERS',
  LocationIsActive: 'LOCATION_IS_ACTIVE',
  LocationNotFound: 'LOCATION_NOT_FOUND'
} as const;

export type LocationDeleteUserErrorCode = typeof LocationDeleteUserErrorCode[keyof typeof LocationDeleteUserErrorCode];
export type LocationEdge = {
  cursor: Scalars['String']['output'];
  node: Location;
};

export type LocationEditAddressInput = {
  address1?: InputMaybe<Scalars['String']['input']>;
  address2?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  countryCode?: InputMaybe<CountryCode>;
  phone?: InputMaybe<Scalars['String']['input']>;
  provinceCode?: InputMaybe<Scalars['String']['input']>;
  zip?: InputMaybe<Scalars['String']['input']>;
};

export type LocationEditInput = {
  address?: InputMaybe<LocationEditAddressInput>;
  fulfillsOnlineOrders?: InputMaybe<Scalars['Boolean']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type LocationEditPayload = {
  location?: Maybe<Location>;
  userErrors: Array<LocationEditUserError>;
};

export type LocationEditUserError = DisplayableError & {
  code?: Maybe<LocationEditUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const LocationEditUserErrorCode = {
  AppNotAuthorized: 'APP_NOT_AUTHORIZED',
  Blank: 'BLANK',
  CannotDisableOnlineOrderFulfillment: 'CANNOT_DISABLE_ONLINE_ORDER_FULFILLMENT',
  CannotModifyOnlineOrderFulfillmentForFsLocation: 'CANNOT_MODIFY_ONLINE_ORDER_FULFILLMENT_FOR_FS_LOCATION',
  CapabilityViolation: 'CAPABILITY_VIOLATION',
  DisallowedOwnerType: 'DISALLOWED_OWNER_TYPE',
  GenericError: 'GENERIC_ERROR',
  Inclusion: 'INCLUSION',
  InternalError: 'INTERNAL_ERROR',
  Invalid: 'INVALID',
  InvalidType: 'INVALID_TYPE',
  InvalidUsZipcode: 'INVALID_US_ZIPCODE',
  InvalidValue: 'INVALID_VALUE',
  NotFound: 'NOT_FOUND',
  Present: 'PRESENT',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  TooShort: 'TOO_SHORT',
  UnstructuredReservedNamespace: 'UNSTRUCTURED_RESERVED_NAMESPACE'
} as const;

export type LocationEditUserErrorCode = typeof LocationEditUserErrorCode[keyof typeof LocationEditUserErrorCode];
export type LocationLocalPickupDisablePayload = {
  locationId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<DeliveryLocationLocalPickupSettingsError>;
};

export type LocationLocalPickupEnablePayload = {
  localPickupSettings?: Maybe<DeliveryLocalPickupSettings>;
  userErrors: Array<DeliveryLocationLocalPickupSettingsError>;
};

export const LocationSortKeys = {
  Id: 'ID',
  Name: 'NAME',
  Relevance: 'RELEVANCE'
} as const;

export type LocationSortKeys = typeof LocationSortKeys[keyof typeof LocationSortKeys];
export type LocationSuggestedAddress = {
  address1?: Maybe<Scalars['String']['output']>;
  address2?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  countryCode?: Maybe<CountryCode>;
  formatted: Array<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  provinceCode?: Maybe<Scalars['String']['output']>;
  zip?: Maybe<Scalars['String']['output']>;
};

export type MailingAddress = Node & {
  address1?: Maybe<Scalars['String']['output']>;
  address2?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  company?: Maybe<Scalars['String']['output']>;
  coordinatesValidated: Scalars['Boolean']['output'];
  country?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use `countryCodeV2` instead. */
  countryCode?: Maybe<Scalars['String']['output']>;
  countryCodeV2?: Maybe<CountryCode>;
  firstName?: Maybe<Scalars['String']['output']>;
  formatted: Array<Scalars['String']['output']>;
  formattedArea?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  provinceCode?: Maybe<Scalars['String']['output']>;
  timeZone?: Maybe<Scalars['String']['output']>;
  validationResultSummary?: Maybe<MailingAddressValidationResult>;
  zip?: Maybe<Scalars['String']['output']>;
};


export type MailingAddressFormattedArgs = {
  withCompany?: InputMaybe<Scalars['Boolean']['input']>;
  withName?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MailingAddressConnection = {
  edges: Array<MailingAddressEdge>;
  nodes: Array<MailingAddress>;
  pageInfo: PageInfo;
};

export type MailingAddressEdge = {
  cursor: Scalars['String']['output'];
  node: MailingAddress;
};

export type MailingAddressInput = {
  address1?: InputMaybe<Scalars['String']['input']>;
  address2?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  company?: InputMaybe<Scalars['String']['input']>;
  countryCode?: InputMaybe<CountryCode>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  provinceCode?: InputMaybe<Scalars['String']['input']>;
  zip?: InputMaybe<Scalars['String']['input']>;
};

export const MailingAddressValidationResult = {
  Error: 'ERROR',
  NoIssues: 'NO_ISSUES',
  Warning: 'WARNING'
} as const;

export type MailingAddressValidationResult = typeof MailingAddressValidationResult[keyof typeof MailingAddressValidationResult];
export type ManualDiscountApplication = DiscountApplication & {
  allocationMethod: DiscountApplicationAllocationMethod;
  description?: Maybe<Scalars['String']['output']>;
  index: Scalars['Int']['output'];
  targetSelection: DiscountApplicationTargetSelection;
  targetType: DiscountApplicationTargetType;
  title: Scalars['String']['output'];
  value: PricingValue;
};

export type Market = HasMetafieldDefinitions & HasMetafields & Node & {
  catalogs: MarketCatalogConnection;
  catalogsCount?: Maybe<Count>;
  currencySettings: MarketCurrencySettings;
  /** @deprecated Use `status` instead. */
  enabled: Scalars['Boolean']['output'];
  handle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  name: Scalars['String']['output'];
  /** @deprecated Use `catalogs` instead. */
  priceList?: Maybe<PriceList>;
  /** @deprecated This field is deprecated and will be removed in the future. */
  primary: Scalars['Boolean']['output'];
  /** @deprecated This field is deprecated and will be removed in the future. Use `conditions.regionConditions` instead. */
  regions: MarketRegionConnection;
  /** @deprecated Use `webPresences` instead. */
  webPresence?: Maybe<MarketWebPresence>;
  webPresences: MarketWebPresenceConnection;
};


export type MarketCatalogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MarketMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type MarketMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type MarketMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MarketRegionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MarketWebPresencesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MarketCatalog = Catalog & Node & {
  id: Scalars['ID']['output'];
  markets: MarketConnection;
  operations: Array<ResourceOperation>;
  priceList?: Maybe<PriceList>;
  publication?: Maybe<Publication>;
  status: CatalogStatus;
  title: Scalars['String']['output'];
};


export type MarketCatalogMarketsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MarketCatalogConnection = {
  edges: Array<MarketCatalogEdge>;
  nodes: Array<MarketCatalog>;
  pageInfo: PageInfo;
};

export type MarketCatalogEdge = {
  cursor: Scalars['String']['output'];
  node: MarketCatalog;
};

export type MarketConnection = {
  edges: Array<MarketEdge>;
  nodes: Array<Market>;
  pageInfo: PageInfo;
};

export type MarketCreateInput = {
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  regions: Array<MarketRegionCreateInput>;
};

export type MarketCreatePayload = {
  market?: Maybe<Market>;
  userErrors: Array<MarketUserError>;
};

export type MarketCurrencySettings = {
  baseCurrency: CurrencySetting;
  localCurrencies: Scalars['Boolean']['output'];
};

export type MarketCurrencySettingsUpdateInput = {
  baseCurrency?: InputMaybe<CurrencyCode>;
  localCurrencies?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MarketCurrencySettingsUpdatePayload = {
  market?: Maybe<Market>;
  userErrors: Array<MarketCurrencySettingsUserError>;
};

export type MarketCurrencySettingsUserError = DisplayableError & {
  code?: Maybe<MarketCurrencySettingsUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MarketCurrencySettingsUserErrorCode = {
  ManagedMarket: 'MANAGED_MARKET',
  MarketNotFound: 'MARKET_NOT_FOUND',
  MultipleCurrenciesNotSupported: 'MULTIPLE_CURRENCIES_NOT_SUPPORTED',
  NoLocalCurrenciesOnSingleCountryMarket: 'NO_LOCAL_CURRENCIES_ON_SINGLE_COUNTRY_MARKET',
  PrimaryMarketUsesShopCurrency: 'PRIMARY_MARKET_USES_SHOP_CURRENCY',
  UnsupportedCurrency: 'UNSUPPORTED_CURRENCY'
} as const;

export type MarketCurrencySettingsUserErrorCode = typeof MarketCurrencySettingsUserErrorCode[keyof typeof MarketCurrencySettingsUserErrorCode];
export type MarketDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<MarketUserError>;
};

export type MarketEdge = {
  cursor: Scalars['String']['output'];
  node: Market;
};

export type MarketLocalizableContent = {
  digest?: Maybe<Scalars['String']['output']>;
  key: Scalars['String']['output'];
  value?: Maybe<Scalars['String']['output']>;
};

export type MarketLocalizableResource = {
  marketLocalizableContent: Array<MarketLocalizableContent>;
  marketLocalizations: Array<MarketLocalization>;
  resourceId: Scalars['ID']['output'];
};


export type MarketLocalizableResourceMarketLocalizationsArgs = {
  marketId: Scalars['ID']['input'];
};

export type MarketLocalizableResourceConnection = {
  edges: Array<MarketLocalizableResourceEdge>;
  nodes: Array<MarketLocalizableResource>;
  pageInfo: PageInfo;
};

export type MarketLocalizableResourceEdge = {
  cursor: Scalars['String']['output'];
  node: MarketLocalizableResource;
};

export const MarketLocalizableResourceType = {
  Metafield: 'METAFIELD',
  Metaobject: 'METAOBJECT'
} as const;

export type MarketLocalizableResourceType = typeof MarketLocalizableResourceType[keyof typeof MarketLocalizableResourceType];
export type MarketLocalization = {
  key: Scalars['String']['output'];
  market: Market;
  outdated: Scalars['Boolean']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

export type MarketLocalizationRegisterInput = {
  key: Scalars['String']['input'];
  marketId: Scalars['ID']['input'];
  marketLocalizableContentDigest: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type MarketLocalizationsRegisterPayload = {
  marketLocalizations?: Maybe<Array<MarketLocalization>>;
  userErrors: Array<TranslationUserError>;
};

export type MarketLocalizationsRemovePayload = {
  marketLocalizations?: Maybe<Array<MarketLocalization>>;
  userErrors: Array<TranslationUserError>;
};

export type MarketRegion = {
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type MarketRegionConnection = {
  edges: Array<MarketRegionEdge>;
  nodes: Array<MarketRegion>;
  pageInfo: PageInfo;
};

export type MarketRegionCountry = MarketRegion & Node & {
  code: CountryCode;
  currency: CurrencySetting;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type MarketRegionCreateInput = {
  countryCode: CountryCode;
};

export type MarketRegionDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  market?: Maybe<Market>;
  userErrors: Array<MarketUserError>;
};

export type MarketRegionEdge = {
  cursor: Scalars['String']['output'];
  node: MarketRegion;
};

export type MarketRegionsCreatePayload = {
  market?: Maybe<Market>;
  userErrors: Array<MarketUserError>;
};

export type MarketRegionsDeletePayload = {
  deletedIds?: Maybe<Array<Scalars['ID']['output']>>;
  userErrors: Array<MarketUserError>;
};

export type MarketUpdateInput = {
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type MarketUpdatePayload = {
  market?: Maybe<Market>;
  userErrors: Array<MarketUserError>;
};

export type MarketUserError = DisplayableError & {
  code?: Maybe<MarketUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MarketUserErrorCode = {
  Blank: 'BLANK',
  CannotAddCustomerDomain: 'CANNOT_ADD_CUSTOMER_DOMAIN',
  CannotAddRegionsToPrimaryMarket: 'CANNOT_ADD_REGIONS_TO_PRIMARY_MARKET',
  CannotAddWebPresenceToPrimaryMarket: 'CANNOT_ADD_WEB_PRESENCE_TO_PRIMARY_MARKET',
  CannotDeleteOnlyRegion: 'CANNOT_DELETE_ONLY_REGION',
  CannotDeletePrimaryMarket: 'CANNOT_DELETE_PRIMARY_MARKET',
  CannotDeletePrimaryMarketWebPresence: 'CANNOT_DELETE_PRIMARY_MARKET_WEB_PRESENCE',
  CannotDisablePrimaryMarket: 'CANNOT_DISABLE_PRIMARY_MARKET',
  CannotHaveBothSubfolderAndDomainWebPresences: 'CANNOT_HAVE_BOTH_SUBFOLDER_AND_DOMAIN_WEB_PRESENCES',
  CannotHaveMultipleSubfoldersPerMarket: 'CANNOT_HAVE_MULTIPLE_SUBFOLDERS_PER_MARKET',
  CannotHaveSubfolderAndDomain: 'CANNOT_HAVE_SUBFOLDER_AND_DOMAIN',
  CannotSetDefaultLocaleToNull: 'CANNOT_SET_DEFAULT_LOCALE_TO_NULL',
  DisabledLanguage: 'DISABLED_LANGUAGE',
  DomainNotFound: 'DOMAIN_NOT_FOUND',
  DuplicateLanguages: 'DUPLICATE_LANGUAGES',
  Invalid: 'INVALID',
  MarketNotFound: 'MARKET_NOT_FOUND',
  MarketReachedWebPresenceLimit: 'MARKET_REACHED_WEB_PRESENCE_LIMIT',
  NoLanguages: 'NO_LANGUAGES',
  PrimaryMarketMustUsePrimaryDomain: 'PRIMARY_MARKET_MUST_USE_PRIMARY_DOMAIN',
  RegionNotFound: 'REGION_NOT_FOUND',
  RegionSpecificLanguage: 'REGION_SPECIFIC_LANGUAGE',
  RequiresDomainOrSubfolder: 'REQUIRES_DOMAIN_OR_SUBFOLDER',
  RequiresExactlyOneOption: 'REQUIRES_EXACTLY_ONE_OPTION',
  ShopReachedMarketsLimit: 'SHOP_REACHED_MARKETS_LIMIT',
  SubfolderSuffixCannotBeScriptCode: 'SUBFOLDER_SUFFIX_CANNOT_BE_SCRIPT_CODE',
  SubfolderSuffixMustContainOnlyLetters: 'SUBFOLDER_SUFFIX_MUST_CONTAIN_ONLY_LETTERS',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  TooShort: 'TOO_SHORT',
  UnpublishedLanguage: 'UNPUBLISHED_LANGUAGE',
  UnsupportedCountryRegion: 'UNSUPPORTED_COUNTRY_REGION',
  WebPresenceNotFound: 'WEB_PRESENCE_NOT_FOUND'
} as const;

export type MarketUserErrorCode = typeof MarketUserErrorCode[keyof typeof MarketUserErrorCode];
export type MarketWebPresence = Node & {
  alternateLocales: Array<ShopLocale>;
  defaultLocale: ShopLocale;
  domain?: Maybe<Domain>;
  id: Scalars['ID']['output'];
  market: Market;
  rootUrls: Array<MarketWebPresenceRootUrl>;
  subfolderSuffix?: Maybe<Scalars['String']['output']>;
};

export type MarketWebPresenceConnection = {
  edges: Array<MarketWebPresenceEdge>;
  nodes: Array<MarketWebPresence>;
  pageInfo: PageInfo;
};

export type MarketWebPresenceCreateInput = {
  alternateLocales?: InputMaybe<Array<Scalars['String']['input']>>;
  defaultLocale: Scalars['String']['input'];
  domainId?: InputMaybe<Scalars['ID']['input']>;
  subfolderSuffix?: InputMaybe<Scalars['String']['input']>;
};

export type MarketWebPresenceCreatePayload = {
  market?: Maybe<Market>;
  userErrors: Array<MarketUserError>;
};

export type MarketWebPresenceDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  market?: Maybe<Market>;
  userErrors: Array<MarketUserError>;
};

export type MarketWebPresenceEdge = {
  cursor: Scalars['String']['output'];
  node: MarketWebPresence;
};

export type MarketWebPresenceRootUrl = {
  locale: Scalars['String']['output'];
  url: Scalars['URL']['output'];
};

export type MarketWebPresenceUpdateInput = {
  alternateLocales?: InputMaybe<Array<Scalars['String']['input']>>;
  defaultLocale?: InputMaybe<Scalars['String']['input']>;
  domainId?: InputMaybe<Scalars['ID']['input']>;
  subfolderSuffix?: InputMaybe<Scalars['String']['input']>;
};

export type MarketWebPresenceUpdatePayload = {
  market?: Maybe<Market>;
  userErrors: Array<MarketUserError>;
};

export type MarketingActivitiesDeleteAllExternalPayload = {
  job?: Maybe<Job>;
  userErrors: Array<MarketingActivityUserError>;
};

export type MarketingActivity = Node & {
  activityListUrl?: Maybe<Scalars['URL']['output']>;
  adSpend?: Maybe<MoneyV2>;
  app: App;
  appErrors?: Maybe<MarketingActivityExtensionAppErrors>;
  budget?: Maybe<MarketingBudget>;
  createdAt: Scalars['DateTime']['output'];
  formData?: Maybe<Scalars['String']['output']>;
  hierarchyLevel?: Maybe<MarketingActivityHierarchyLevel>;
  id: Scalars['ID']['output'];
  inMainWorkflowVersion: Scalars['Boolean']['output'];
  isExternal: Scalars['Boolean']['output'];
  /** @deprecated Use `marketingChannelType` instead. */
  marketingChannel: MarketingChannel;
  marketingChannelType: MarketingChannel;
  marketingEvent?: Maybe<MarketingEvent>;
  parentActivityId?: Maybe<Scalars['ID']['output']>;
  parentRemoteId?: Maybe<Scalars['String']['output']>;
  sourceAndMedium: Scalars['String']['output'];
  status: MarketingActivityStatus;
  /** @deprecated Use `statusBadgeTypeV2` instead. */
  statusBadgeType?: Maybe<MarketingActivityStatusBadgeType>;
  statusBadgeTypeV2?: Maybe<BadgeType>;
  statusLabel: Scalars['String']['output'];
  statusTransitionedAt?: Maybe<Scalars['DateTime']['output']>;
  tactic: MarketingTactic;
  targetStatus?: Maybe<MarketingActivityStatus>;
  title: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  urlParameterValue?: Maybe<Scalars['String']['output']>;
  utmParameters?: Maybe<UtmParameters>;
};

export type MarketingActivityBudgetInput = {
  budgetType?: InputMaybe<MarketingBudgetBudgetType>;
  total?: InputMaybe<MoneyInput>;
};

export type MarketingActivityConnection = {
  edges: Array<MarketingActivityEdge>;
  nodes: Array<MarketingActivity>;
  pageInfo: PageInfo;
};

export type MarketingActivityCreateExternalInput = {
  adSpend?: InputMaybe<MoneyInput>;
  budget?: InputMaybe<MarketingActivityBudgetInput>;
  channelHandle?: InputMaybe<Scalars['String']['input']>;
  end?: InputMaybe<Scalars['DateTime']['input']>;
  hierarchyLevel?: InputMaybe<MarketingActivityHierarchyLevel>;
  marketingChannelType: MarketingChannel;
  parentActivityId?: InputMaybe<Scalars['ID']['input']>;
  parentRemoteId?: InputMaybe<Scalars['String']['input']>;
  referringDomain?: InputMaybe<Scalars['String']['input']>;
  remoteId?: InputMaybe<Scalars['String']['input']>;
  remotePreviewImageUrl?: InputMaybe<Scalars['URL']['input']>;
  remoteUrl: Scalars['URL']['input'];
  scheduledEnd?: InputMaybe<Scalars['DateTime']['input']>;
  scheduledStart?: InputMaybe<Scalars['DateTime']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
  status?: InputMaybe<MarketingActivityExternalStatus>;
  tactic: MarketingTactic;
  title: Scalars['String']['input'];
  urlParameterValue?: InputMaybe<Scalars['String']['input']>;
  utm?: InputMaybe<UtmInput>;
};

export type MarketingActivityCreateExternalPayload = {
  marketingActivity?: Maybe<MarketingActivity>;
  userErrors: Array<MarketingActivityUserError>;
};

export type MarketingActivityCreateInput = {
  budget?: InputMaybe<MarketingActivityBudgetInput>;
  context?: InputMaybe<Scalars['String']['input']>;
  formData?: InputMaybe<Scalars['String']['input']>;
  marketingActivityExtensionId: Scalars['ID']['input'];
  marketingActivityTitle?: InputMaybe<Scalars['String']['input']>;
  status: MarketingActivityStatus;
  urlParameterValue?: InputMaybe<Scalars['String']['input']>;
  utm?: InputMaybe<UtmInput>;
};

export type MarketingActivityCreatePayload = {
  marketingActivity?: Maybe<MarketingActivity>;
  redirectPath?: Maybe<Scalars['String']['output']>;
  userErrors: Array<UserError>;
};

export type MarketingActivityDeleteExternalPayload = {
  deletedMarketingActivityId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<MarketingActivityUserError>;
};

export type MarketingActivityEdge = {
  cursor: Scalars['String']['output'];
  node: MarketingActivity;
};

export const MarketingActivityExtensionAppErrorCode = {
  ApiError: 'API_ERROR',
  InstallRequiredError: 'INSTALL_REQUIRED_ERROR',
  NotOnboardedError: 'NOT_ONBOARDED_ERROR',
  PlatformError: 'PLATFORM_ERROR',
  ValidationError: 'VALIDATION_ERROR'
} as const;

export type MarketingActivityExtensionAppErrorCode = typeof MarketingActivityExtensionAppErrorCode[keyof typeof MarketingActivityExtensionAppErrorCode];
export type MarketingActivityExtensionAppErrors = {
  code: MarketingActivityExtensionAppErrorCode;
  userErrors: Array<UserError>;
};

export const MarketingActivityExternalStatus = {
  Active: 'ACTIVE',
  DeletedExternally: 'DELETED_EXTERNALLY',
  Inactive: 'INACTIVE',
  Paused: 'PAUSED',
  Scheduled: 'SCHEDULED',
  Undefined: 'UNDEFINED'
} as const;

export type MarketingActivityExternalStatus = typeof MarketingActivityExternalStatus[keyof typeof MarketingActivityExternalStatus];
export const MarketingActivityHierarchyLevel = {
  Ad: 'AD',
  AdGroup: 'AD_GROUP',
  Campaign: 'CAMPAIGN'
} as const;

export type MarketingActivityHierarchyLevel = typeof MarketingActivityHierarchyLevel[keyof typeof MarketingActivityHierarchyLevel];
export const MarketingActivitySortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE',
  Title: 'TITLE'
} as const;

export type MarketingActivitySortKeys = typeof MarketingActivitySortKeys[keyof typeof MarketingActivitySortKeys];
export const MarketingActivityStatus = {
  Active: 'ACTIVE',
  Deleted: 'DELETED',
  DeletedExternally: 'DELETED_EXTERNALLY',
  Disconnected: 'DISCONNECTED',
  Draft: 'DRAFT',
  Failed: 'FAILED',
  Inactive: 'INACTIVE',
  Paused: 'PAUSED',
  Pending: 'PENDING',
  Scheduled: 'SCHEDULED',
  Undefined: 'UNDEFINED'
} as const;

export type MarketingActivityStatus = typeof MarketingActivityStatus[keyof typeof MarketingActivityStatus];
export const MarketingActivityStatusBadgeType = {
  Attention: 'ATTENTION',
  Critical: 'CRITICAL',
  Default: 'DEFAULT',
  Info: 'INFO',
  Success: 'SUCCESS',
  Warning: 'WARNING'
} as const;

export type MarketingActivityStatusBadgeType = typeof MarketingActivityStatusBadgeType[keyof typeof MarketingActivityStatusBadgeType];
export type MarketingActivityUpdateExternalInput = {
  adSpend?: InputMaybe<MoneyInput>;
  budget?: InputMaybe<MarketingActivityBudgetInput>;
  end?: InputMaybe<Scalars['DateTime']['input']>;
  marketingChannelType?: InputMaybe<MarketingChannel>;
  referringDomain?: InputMaybe<Scalars['String']['input']>;
  remotePreviewImageUrl?: InputMaybe<Scalars['URL']['input']>;
  remoteUrl?: InputMaybe<Scalars['URL']['input']>;
  scheduledEnd?: InputMaybe<Scalars['DateTime']['input']>;
  scheduledStart?: InputMaybe<Scalars['DateTime']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
  status?: InputMaybe<MarketingActivityExternalStatus>;
  tactic?: InputMaybe<MarketingTactic>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type MarketingActivityUpdateExternalPayload = {
  marketingActivity?: Maybe<MarketingActivity>;
  userErrors: Array<MarketingActivityUserError>;
};

export type MarketingActivityUpdateInput = {
  budget?: InputMaybe<MarketingActivityBudgetInput>;
  errors?: InputMaybe<Scalars['JSON']['input']>;
  formData?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  marketedResources?: InputMaybe<Array<Scalars['ID']['input']>>;
  marketingRecommendationId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<MarketingActivityStatus>;
  targetStatus?: InputMaybe<MarketingActivityStatus>;
  title?: InputMaybe<Scalars['String']['input']>;
  urlParameterValue?: InputMaybe<Scalars['String']['input']>;
  utm?: InputMaybe<UtmInput>;
};

export type MarketingActivityUpdatePayload = {
  marketingActivity?: Maybe<MarketingActivity>;
  redirectPath?: Maybe<Scalars['String']['output']>;
  userErrors: Array<UserError>;
};

export type MarketingActivityUpsertExternalInput = {
  adSpend?: InputMaybe<MoneyInput>;
  budget?: InputMaybe<MarketingActivityBudgetInput>;
  channelHandle?: InputMaybe<Scalars['String']['input']>;
  end?: InputMaybe<Scalars['DateTime']['input']>;
  hierarchyLevel?: InputMaybe<MarketingActivityHierarchyLevel>;
  marketingChannelType: MarketingChannel;
  parentRemoteId?: InputMaybe<Scalars['String']['input']>;
  referringDomain?: InputMaybe<Scalars['String']['input']>;
  remoteId: Scalars['String']['input'];
  remotePreviewImageUrl?: InputMaybe<Scalars['URL']['input']>;
  remoteUrl: Scalars['URL']['input'];
  scheduledEnd?: InputMaybe<Scalars['DateTime']['input']>;
  scheduledStart?: InputMaybe<Scalars['DateTime']['input']>;
  start?: InputMaybe<Scalars['DateTime']['input']>;
  status: MarketingActivityExternalStatus;
  tactic: MarketingTactic;
  title: Scalars['String']['input'];
  urlParameterValue?: InputMaybe<Scalars['String']['input']>;
  utm?: InputMaybe<UtmInput>;
};

export type MarketingActivityUpsertExternalPayload = {
  marketingActivity?: Maybe<MarketingActivity>;
  userErrors: Array<MarketingActivityUserError>;
};

export type MarketingActivityUserError = DisplayableError & {
  code?: Maybe<MarketingActivityUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MarketingActivityUserErrorCode = {
  ActivityNotExternal: 'ACTIVITY_NOT_EXTERNAL',
  CannotDeleteActivityWithChildEvents: 'CANNOT_DELETE_ACTIVITY_WITH_CHILD_EVENTS',
  CannotUpdateTacticIfOriginallyStorefrontApp: 'CANNOT_UPDATE_TACTIC_IF_ORIGINALLY_STOREFRONT_APP',
  CannotUpdateTacticToStorefrontApp: 'CANNOT_UPDATE_TACTIC_TO_STOREFRONT_APP',
  CurrencyCodeMismatchInput: 'CURRENCY_CODE_MISMATCH_INPUT',
  DeleteJobEnqueued: 'DELETE_JOB_ENQUEUED',
  DeleteJobFailedToEnqueue: 'DELETE_JOB_FAILED_TO_ENQUEUE',
  ImmutableChannelHandle: 'IMMUTABLE_CHANNEL_HANDLE',
  ImmutableHierarchyLevel: 'IMMUTABLE_HIERARCHY_LEVEL',
  ImmutableParentId: 'IMMUTABLE_PARENT_ID',
  ImmutableUrlParameter: 'IMMUTABLE_URL_PARAMETER',
  ImmutableUtmParameters: 'IMMUTABLE_UTM_PARAMETERS',
  Invalid: 'INVALID',
  InvalidChannelHandle: 'INVALID_CHANNEL_HANDLE',
  InvalidDeleteActivityExternalArguments: 'INVALID_DELETE_ACTIVITY_EXTERNAL_ARGUMENTS',
  InvalidDeleteEngagementsArguments: 'INVALID_DELETE_ENGAGEMENTS_ARGUMENTS',
  InvalidMarketingActivityExternalArguments: 'INVALID_MARKETING_ACTIVITY_EXTERNAL_ARGUMENTS',
  InvalidMarketingEngagementArguments: 'INVALID_MARKETING_ENGAGEMENT_ARGUMENTS',
  InvalidMarketingEngagementArgumentMissing: 'INVALID_MARKETING_ENGAGEMENT_ARGUMENT_MISSING',
  InvalidRemoteId: 'INVALID_REMOTE_ID',
  MarketingActivityCurrencyCodeMismatch: 'MARKETING_ACTIVITY_CURRENCY_CODE_MISMATCH',
  MarketingActivityDoesNotExist: 'MARKETING_ACTIVITY_DOES_NOT_EXIST',
  MarketingEventDoesNotExist: 'MARKETING_EVENT_DOES_NOT_EXIST',
  NonHierarchialRequiresUtmUrlParameter: 'NON_HIERARCHIAL_REQUIRES_UTM_URL_PARAMETER',
  Taken: 'TAKEN'
} as const;

export type MarketingActivityUserErrorCode = typeof MarketingActivityUserErrorCode[keyof typeof MarketingActivityUserErrorCode];
export type MarketingBudget = {
  budgetType: MarketingBudgetBudgetType;
  total: MoneyV2;
};

export const MarketingBudgetBudgetType = {
  Daily: 'DAILY',
  Lifetime: 'LIFETIME'
} as const;

export type MarketingBudgetBudgetType = typeof MarketingBudgetBudgetType[keyof typeof MarketingBudgetBudgetType];
export const MarketingChannel = {
  Display: 'DISPLAY',
  Email: 'EMAIL',
  Referral: 'REFERRAL',
  Search: 'SEARCH',
  Social: 'SOCIAL'
} as const;

export type MarketingChannel = typeof MarketingChannel[keyof typeof MarketingChannel];
export type MarketingEngagement = {
  adSpend?: Maybe<MoneyV2>;
  channelHandle?: Maybe<Scalars['String']['output']>;
  clicksCount?: Maybe<Scalars['Int']['output']>;
  commentsCount?: Maybe<Scalars['Int']['output']>;
  complaintsCount?: Maybe<Scalars['Int']['output']>;
  failsCount?: Maybe<Scalars['Int']['output']>;
  favoritesCount?: Maybe<Scalars['Int']['output']>;
  firstTimeCustomers?: Maybe<Scalars['Decimal']['output']>;
  impressionsCount?: Maybe<Scalars['Int']['output']>;
  isCumulative: Scalars['Boolean']['output'];
  marketingActivity?: Maybe<MarketingActivity>;
  occurredOn: Scalars['Date']['output'];
  orders?: Maybe<Scalars['Decimal']['output']>;
  returningCustomers?: Maybe<Scalars['Decimal']['output']>;
  sales?: Maybe<MoneyV2>;
  sendsCount?: Maybe<Scalars['Int']['output']>;
  sessionsCount?: Maybe<Scalars['Int']['output']>;
  sharesCount?: Maybe<Scalars['Int']['output']>;
  uniqueClicksCount?: Maybe<Scalars['Int']['output']>;
  uniqueViewsCount?: Maybe<Scalars['Int']['output']>;
  unsubscribesCount?: Maybe<Scalars['Int']['output']>;
  utcOffset: Scalars['UtcOffset']['output'];
  viewsCount?: Maybe<Scalars['Int']['output']>;
};

export type MarketingEngagementCreatePayload = {
  marketingEngagement?: Maybe<MarketingEngagement>;
  userErrors: Array<MarketingActivityUserError>;
};

export type MarketingEngagementInput = {
  adSpend?: InputMaybe<MoneyInput>;
  clicksCount?: InputMaybe<Scalars['Int']['input']>;
  commentsCount?: InputMaybe<Scalars['Int']['input']>;
  complaintsCount?: InputMaybe<Scalars['Int']['input']>;
  failsCount?: InputMaybe<Scalars['Int']['input']>;
  favoritesCount?: InputMaybe<Scalars['Int']['input']>;
  firstTimeCustomers?: InputMaybe<Scalars['Decimal']['input']>;
  impressionsCount?: InputMaybe<Scalars['Int']['input']>;
  isCumulative: Scalars['Boolean']['input'];
  occurredOn: Scalars['Date']['input'];
  orders?: InputMaybe<Scalars['Decimal']['input']>;
  returningCustomers?: InputMaybe<Scalars['Decimal']['input']>;
  sales?: InputMaybe<MoneyInput>;
  sendsCount?: InputMaybe<Scalars['Int']['input']>;
  sessionsCount?: InputMaybe<Scalars['Int']['input']>;
  sharesCount?: InputMaybe<Scalars['Int']['input']>;
  uniqueClicksCount?: InputMaybe<Scalars['Int']['input']>;
  uniqueViewsCount?: InputMaybe<Scalars['Int']['input']>;
  unsubscribesCount?: InputMaybe<Scalars['Int']['input']>;
  utcOffset: Scalars['UtcOffset']['input'];
  viewsCount?: InputMaybe<Scalars['Int']['input']>;
};

export type MarketingEngagementsDeletePayload = {
  result?: Maybe<Scalars['String']['output']>;
  userErrors: Array<MarketingActivityUserError>;
};

export type MarketingEvent = LegacyInteroperability & Node & {
  app: App;
  /** @deprecated Use `marketingChannelType` instead. */
  channel?: Maybe<MarketingChannel>;
  channelHandle?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  endedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  manageUrl?: Maybe<Scalars['URL']['output']>;
  marketingChannelType?: Maybe<MarketingChannel>;
  previewUrl?: Maybe<Scalars['URL']['output']>;
  remoteId?: Maybe<Scalars['String']['output']>;
  scheduledToEndAt?: Maybe<Scalars['DateTime']['output']>;
  sourceAndMedium: Scalars['String']['output'];
  startedAt: Scalars['DateTime']['output'];
  /** @deprecated Use `sourceAndMedium` instead. */
  targetTypeDisplayText: Scalars['String']['output'];
  type: MarketingTactic;
  utmCampaign?: Maybe<Scalars['String']['output']>;
  utmMedium?: Maybe<Scalars['String']['output']>;
  utmSource?: Maybe<Scalars['String']['output']>;
};

export type MarketingEventConnection = {
  edges: Array<MarketingEventEdge>;
  nodes: Array<MarketingEvent>;
  pageInfo: PageInfo;
};

export type MarketingEventEdge = {
  cursor: Scalars['String']['output'];
  node: MarketingEvent;
};

export const MarketingEventSortKeys = {
  Id: 'ID',
  Relevance: 'RELEVANCE',
  StartedAt: 'STARTED_AT'
} as const;

export type MarketingEventSortKeys = typeof MarketingEventSortKeys[keyof typeof MarketingEventSortKeys];
export const MarketingTactic = {
  AbandonedCart: 'ABANDONED_CART',
  Ad: 'AD',
  Affiliate: 'AFFILIATE',
  Link: 'LINK',
  Loyalty: 'LOYALTY',
  Message: 'MESSAGE',
  Newsletter: 'NEWSLETTER',
  Notification: 'NOTIFICATION',
  Post: 'POST',
  Retargeting: 'RETARGETING',
  Seo: 'SEO',
  StorefrontApp: 'STOREFRONT_APP',
  Transactional: 'TRANSACTIONAL'
} as const;

export type MarketingTactic = typeof MarketingTactic[keyof typeof MarketingTactic];
export type Media = {
  alt?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  mediaContentType: MediaContentType;
  mediaErrors: Array<MediaError>;
  mediaWarnings: Array<MediaWarning>;
  preview?: Maybe<MediaPreviewImage>;
  status: MediaStatus;
};

export type MediaConnection = {
  edges: Array<MediaEdge>;
  nodes: Array<Media>;
  pageInfo: PageInfo;
};

export const MediaContentType = {
  ExternalVideo: 'EXTERNAL_VIDEO',
  Image: 'IMAGE',
  Model_3D: 'MODEL_3D',
  Video: 'VIDEO'
} as const;

export type MediaContentType = typeof MediaContentType[keyof typeof MediaContentType];
export type MediaEdge = {
  cursor: Scalars['String']['output'];
  node: Media;
};

export type MediaError = {
  code: MediaErrorCode;
  details?: Maybe<Scalars['String']['output']>;
  message: Scalars['String']['output'];
};

export const MediaErrorCode = {
  DuplicateFilenameError: 'DUPLICATE_FILENAME_ERROR',
  ExternalVideoEmbedDisabled: 'EXTERNAL_VIDEO_EMBED_DISABLED',
  ExternalVideoEmbedNotFoundOrTranscoding: 'EXTERNAL_VIDEO_EMBED_NOT_FOUND_OR_TRANSCODING',
  ExternalVideoInvalidAspectRatio: 'EXTERNAL_VIDEO_INVALID_ASPECT_RATIO',
  ExternalVideoNotFound: 'EXTERNAL_VIDEO_NOT_FOUND',
  ExternalVideoUnlisted: 'EXTERNAL_VIDEO_UNLISTED',
  FileStorageLimitExceeded: 'FILE_STORAGE_LIMIT_EXCEEDED',
  GenericFileDownloadFailure: 'GENERIC_FILE_DOWNLOAD_FAILURE',
  GenericFileInvalidSize: 'GENERIC_FILE_INVALID_SIZE',
  ImageDownloadFailure: 'IMAGE_DOWNLOAD_FAILURE',
  ImageProcessingFailure: 'IMAGE_PROCESSING_FAILURE',
  InvalidImageAspectRatio: 'INVALID_IMAGE_ASPECT_RATIO',
  InvalidImageFileSize: 'INVALID_IMAGE_FILE_SIZE',
  InvalidImageResolution: 'INVALID_IMAGE_RESOLUTION',
  InvalidSignedUrl: 'INVALID_SIGNED_URL',
  MediaTimeoutError: 'MEDIA_TIMEOUT_ERROR',
  Model3DGlbOutputCreationError: 'MODEL3D_GLB_OUTPUT_CREATION_ERROR',
  Model3DGlbToUsdzConversionError: 'MODEL3D_GLB_TO_USDZ_CONVERSION_ERROR',
  Model3DProcessingFailure: 'MODEL3D_PROCESSING_FAILURE',
  Model3DThumbnailGenerationError: 'MODEL3D_THUMBNAIL_GENERATION_ERROR',
  Model3DThumbnailRegenerationError: 'MODEL3D_THUMBNAIL_REGENERATION_ERROR',
  Model3DValidationError: 'MODEL3D_VALIDATION_ERROR',
  Unknown: 'UNKNOWN',
  UnsupportedImageFileType: 'UNSUPPORTED_IMAGE_FILE_TYPE',
  VideoInvalidFiletypeError: 'VIDEO_INVALID_FILETYPE_ERROR',
  VideoMaxDurationError: 'VIDEO_MAX_DURATION_ERROR',
  VideoMaxHeightError: 'VIDEO_MAX_HEIGHT_ERROR',
  VideoMaxWidthError: 'VIDEO_MAX_WIDTH_ERROR',
  VideoMetadataReadError: 'VIDEO_METADATA_READ_ERROR',
  VideoMinDurationError: 'VIDEO_MIN_DURATION_ERROR',
  VideoMinHeightError: 'VIDEO_MIN_HEIGHT_ERROR',
  VideoMinWidthError: 'VIDEO_MIN_WIDTH_ERROR',
  VideoValidationError: 'VIDEO_VALIDATION_ERROR'
} as const;

export type MediaErrorCode = typeof MediaErrorCode[keyof typeof MediaErrorCode];
export const MediaHost = {
  Vimeo: 'VIMEO',
  Youtube: 'YOUTUBE'
} as const;

export type MediaHost = typeof MediaHost[keyof typeof MediaHost];
export type MediaImage = File & HasMetafields & Media & Node & {
  alt?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  fileErrors: Array<FileError>;
  fileStatus: FileStatus;
  id: Scalars['ID']['output'];
  image?: Maybe<Image>;
  mediaContentType: MediaContentType;
  mediaErrors: Array<MediaError>;
  mediaWarnings: Array<MediaWarning>;
  metafield?: Maybe<Metafield>;
  metafields: MetafieldConnection;
  mimeType?: Maybe<Scalars['String']['output']>;
  originalSource?: Maybe<MediaImageOriginalSource>;
  preview?: Maybe<MediaPreviewImage>;
  status: MediaStatus;
  updatedAt: Scalars['DateTime']['output'];
};


export type MediaImageMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type MediaImageMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MediaImageOriginalSource = {
  fileSize?: Maybe<Scalars['Int']['output']>;
  url?: Maybe<Scalars['URL']['output']>;
};

export type MediaPreviewImage = {
  image?: Maybe<Image>;
  status: MediaPreviewImageStatus;
};

export const MediaPreviewImageStatus = {
  Failed: 'FAILED',
  Processing: 'PROCESSING',
  Ready: 'READY',
  Uploaded: 'UPLOADED'
} as const;

export type MediaPreviewImageStatus = typeof MediaPreviewImageStatus[keyof typeof MediaPreviewImageStatus];
export const MediaStatus = {
  Failed: 'FAILED',
  Processing: 'PROCESSING',
  Ready: 'READY',
  Uploaded: 'UPLOADED'
} as const;

export type MediaStatus = typeof MediaStatus[keyof typeof MediaStatus];
export type MediaUserError = DisplayableError & {
  code?: Maybe<MediaUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MediaUserErrorCode = {
  Blank: 'BLANK',
  Invalid: 'INVALID',
  InvalidMediaType: 'INVALID_MEDIA_TYPE',
  MaximumVariantMediaPairsExceeded: 'MAXIMUM_VARIANT_MEDIA_PAIRS_EXCEEDED',
  MediaCannotBeModified: 'MEDIA_CANNOT_BE_MODIFIED',
  MediaDoesNotExist: 'MEDIA_DOES_NOT_EXIST',
  MediaDoesNotExistOnProduct: 'MEDIA_DOES_NOT_EXIST_ON_PRODUCT',
  MediaIsNotAttachedToVariant: 'MEDIA_IS_NOT_ATTACHED_TO_VARIANT',
  MissingArguments: 'MISSING_ARGUMENTS',
  Model3DThrottleExceeded: 'MODEL3D_THROTTLE_EXCEEDED',
  Model3DValidationError: 'MODEL3D_VALIDATION_ERROR',
  NonReadyMedia: 'NON_READY_MEDIA',
  ProductDoesNotExist: 'PRODUCT_DOES_NOT_EXIST',
  ProductMediaLimitExceeded: 'PRODUCT_MEDIA_LIMIT_EXCEEDED',
  ProductSuspended: 'PRODUCT_SUSPENDED',
  ProductVariantAlreadyHasMedia: 'PRODUCT_VARIANT_ALREADY_HAS_MEDIA',
  ProductVariantDoesNotExistOnProduct: 'PRODUCT_VARIANT_DOES_NOT_EXIST_ON_PRODUCT',
  ProductVariantSpecifiedMultipleTimes: 'PRODUCT_VARIANT_SPECIFIED_MULTIPLE_TIMES',
  ShopMediaLimitExceeded: 'SHOP_MEDIA_LIMIT_EXCEEDED',
  TooManyMediaPerInputPair: 'TOO_MANY_MEDIA_PER_INPUT_PAIR',
  VideoThrottleExceeded: 'VIDEO_THROTTLE_EXCEEDED',
  VideoValidationError: 'VIDEO_VALIDATION_ERROR'
} as const;

export type MediaUserErrorCode = typeof MediaUserErrorCode[keyof typeof MediaUserErrorCode];
export type MediaWarning = {
  code: MediaWarningCode;
  message?: Maybe<Scalars['String']['output']>;
};

export const MediaWarningCode = {
  ModelLargePhysicalSize: 'MODEL_LARGE_PHYSICAL_SIZE',
  ModelSmallPhysicalSize: 'MODEL_SMALL_PHYSICAL_SIZE'
} as const;

export type MediaWarningCode = typeof MediaWarningCode[keyof typeof MediaWarningCode];
export type Menu = HasPublishedTranslations & Node & {
  handle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isDefault: Scalars['Boolean']['output'];
  items: Array<MenuItem>;
  title: Scalars['String']['output'];
  translations: Array<Translation>;
};


export type MenuItemsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type MenuTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export type MenuConnection = {
  edges: Array<MenuEdge>;
  nodes: Array<Menu>;
  pageInfo: PageInfo;
};

export type MenuCreatePayload = {
  menu?: Maybe<Menu>;
  userErrors: Array<MenuCreateUserError>;
};

export type MenuCreateUserError = DisplayableError & {
  code?: Maybe<MenuCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MenuCreateUserErrorCode = {
  NestingTooDeep: 'NESTING_TOO_DEEP',
  NotFound: 'NOT_FOUND'
} as const;

export type MenuCreateUserErrorCode = typeof MenuCreateUserErrorCode[keyof typeof MenuCreateUserErrorCode];
export type MenuDeletePayload = {
  deletedMenuId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<MenuDeleteUserError>;
};

export type MenuDeleteUserError = DisplayableError & {
  code?: Maybe<MenuDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MenuDeleteUserErrorCode = {
  MenuDoesNotExist: 'MENU_DOES_NOT_EXIST',
  UnableToDeleteDefaultMenu: 'UNABLE_TO_DELETE_DEFAULT_MENU'
} as const;

export type MenuDeleteUserErrorCode = typeof MenuDeleteUserErrorCode[keyof typeof MenuDeleteUserErrorCode];
export type MenuEdge = {
  cursor: Scalars['String']['output'];
  node: Menu;
};

export type MenuItem = {
  id: Scalars['ID']['output'];
  items: Array<MenuItem>;
  resourceId?: Maybe<Scalars['ID']['output']>;
  tags: Array<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  type: MenuItemType;
  url?: Maybe<Scalars['String']['output']>;
};

export type MenuItemCreateInput = {
  items?: InputMaybe<Array<MenuItemCreateInput>>;
  resourceId?: InputMaybe<Scalars['ID']['input']>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  title: Scalars['String']['input'];
  type: MenuItemType;
  url?: InputMaybe<Scalars['String']['input']>;
};

export const MenuItemType = {
  Article: 'ARTICLE',
  Blog: 'BLOG',
  Catalog: 'CATALOG',
  Collection: 'COLLECTION',
  Collections: 'COLLECTIONS',
  CustomerAccountPage: 'CUSTOMER_ACCOUNT_PAGE',
  Frontpage: 'FRONTPAGE',
  Http: 'HTTP',
  Metaobject: 'METAOBJECT',
  Page: 'PAGE',
  Product: 'PRODUCT',
  Search: 'SEARCH',
  ShopPolicy: 'SHOP_POLICY'
} as const;

export type MenuItemType = typeof MenuItemType[keyof typeof MenuItemType];
export type MenuItemUpdateInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  items?: InputMaybe<Array<MenuItemUpdateInput>>;
  resourceId?: InputMaybe<Scalars['ID']['input']>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  title: Scalars['String']['input'];
  type: MenuItemType;
  url?: InputMaybe<Scalars['String']['input']>;
};

export const MenuSortKeys = {
  Id: 'ID',
  Relevance: 'RELEVANCE',
  Title: 'TITLE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type MenuSortKeys = typeof MenuSortKeys[keyof typeof MenuSortKeys];
export type MenuUpdatePayload = {
  menu?: Maybe<Menu>;
  userErrors: Array<MenuUpdateUserError>;
};

export type MenuUpdateUserError = DisplayableError & {
  code?: Maybe<MenuUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MenuUpdateUserErrorCode = {
  NestingTooDeep: 'NESTING_TOO_DEEP',
  NotFound: 'NOT_FOUND'
} as const;

export type MenuUpdateUserErrorCode = typeof MenuUpdateUserErrorCode[keyof typeof MenuUpdateUserErrorCode];
export const MerchandiseDiscountClass = {
  Order: 'ORDER',
  Product: 'PRODUCT'
} as const;

export type MerchandiseDiscountClass = typeof MerchandiseDiscountClass[keyof typeof MerchandiseDiscountClass];
export type MerchantApprovalSignals = {
  identityVerified: Scalars['Boolean']['output'];
  verifiedByShopify: Scalars['Boolean']['output'];
  verifiedByShopifyTier: Scalars['String']['output'];
};

export type Metafield = HasCompareDigest & LegacyInteroperability & Node & {
  compareDigest: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  definition?: Maybe<MetafieldDefinition>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  jsonValue: Scalars['JSON']['output'];
  key: Scalars['String']['output'];
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  namespace: Scalars['String']['output'];
  owner: HasMetafields;
  ownerType: MetafieldOwnerType;
  reference?: Maybe<MetafieldReference>;
  references?: Maybe<MetafieldReferenceConnection>;
  type: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  value: Scalars['String']['output'];
};


export type MetafieldReferencesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type MetafieldAccess = {
  admin?: Maybe<MetafieldAdminAccess>;
  customerAccount: MetafieldCustomerAccountAccess;
  /**
   * @deprecated Explicit grants are [deprecated](https://shopify.dev/changelog/deprecating-explicit-access-grants-for-app-owned-metafields).
   *
   */
  grants: Array<MetafieldAccessGrant>;
  storefront?: Maybe<MetafieldStorefrontAccess>;
};

export type MetafieldAccessGrant = {
  access: MetafieldGrantAccessLevel;
  grantee: Scalars['String']['output'];
};

export type MetafieldAccessInput = {
  admin?: InputMaybe<MetafieldAdminAccessInput>;
  customerAccount?: InputMaybe<MetafieldCustomerAccountAccessInput>;
  storefront?: InputMaybe<MetafieldStorefrontAccessInput>;
};

export type MetafieldAccessUpdateInput = {
  admin?: InputMaybe<MetafieldAdminAccessInput>;
  customerAccount?: InputMaybe<MetafieldCustomerAccountAccessInput>;
  storefront?: InputMaybe<MetafieldStorefrontAccessInput>;
};

export const MetafieldAdminAccess = {
  MerchantRead: 'MERCHANT_READ',
  MerchantReadWrite: 'MERCHANT_READ_WRITE',
  Private: 'PRIVATE',
  PublicRead: 'PUBLIC_READ',
  PublicReadWrite: 'PUBLIC_READ_WRITE'
} as const;

export type MetafieldAdminAccess = typeof MetafieldAdminAccess[keyof typeof MetafieldAdminAccess];
export const MetafieldAdminAccessInput = {
  MerchantRead: 'MERCHANT_READ',
  MerchantReadWrite: 'MERCHANT_READ_WRITE'
} as const;

export type MetafieldAdminAccessInput = typeof MetafieldAdminAccessInput[keyof typeof MetafieldAdminAccessInput];
export type MetafieldCapabilities = {
  adminFilterable: MetafieldCapabilityAdminFilterable;
  smartCollectionCondition: MetafieldCapabilitySmartCollectionCondition;
  uniqueValues: MetafieldCapabilityUniqueValues;
};

export type MetafieldCapabilityAdminFilterable = {
  eligible: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
  status: MetafieldDefinitionAdminFilterStatus;
};

export type MetafieldCapabilityAdminFilterableInput = {
  enabled: Scalars['Boolean']['input'];
};

export type MetafieldCapabilityCreateInput = {
  adminFilterable?: InputMaybe<MetafieldCapabilityAdminFilterableInput>;
  smartCollectionCondition?: InputMaybe<MetafieldCapabilitySmartCollectionConditionInput>;
  uniqueValues?: InputMaybe<MetafieldCapabilityUniqueValuesInput>;
};

export type MetafieldCapabilitySmartCollectionCondition = {
  eligible: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
};

export type MetafieldCapabilitySmartCollectionConditionInput = {
  enabled: Scalars['Boolean']['input'];
};

export type MetafieldCapabilityUniqueValues = {
  eligible: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
};

export type MetafieldCapabilityUniqueValuesInput = {
  enabled: Scalars['Boolean']['input'];
};

export type MetafieldCapabilityUpdateInput = {
  adminFilterable?: InputMaybe<MetafieldCapabilityAdminFilterableInput>;
  smartCollectionCondition?: InputMaybe<MetafieldCapabilitySmartCollectionConditionInput>;
  uniqueValues?: InputMaybe<MetafieldCapabilityUniqueValuesInput>;
};

export type MetafieldConnection = {
  edges: Array<MetafieldEdge>;
  nodes: Array<Metafield>;
  pageInfo: PageInfo;
};

export const MetafieldCustomerAccountAccess = {
  None: 'NONE',
  Read: 'READ',
  ReadWrite: 'READ_WRITE'
} as const;

export type MetafieldCustomerAccountAccess = typeof MetafieldCustomerAccountAccess[keyof typeof MetafieldCustomerAccountAccess];
export const MetafieldCustomerAccountAccessInput = {
  None: 'NONE',
  Read: 'READ',
  ReadWrite: 'READ_WRITE'
} as const;

export type MetafieldCustomerAccountAccessInput = typeof MetafieldCustomerAccountAccessInput[keyof typeof MetafieldCustomerAccountAccessInput];
export type MetafieldDefinition = Node & {
  access: MetafieldAccess;
  capabilities: MetafieldCapabilities;
  constraints?: Maybe<MetafieldDefinitionConstraints>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  metafields: MetafieldConnection;
  metafieldsCount: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  namespace: Scalars['String']['output'];
  ownerType: MetafieldOwnerType;
  pinnedPosition?: Maybe<Scalars['Int']['output']>;
  standardTemplate?: Maybe<StandardMetafieldDefinitionTemplate>;
  type: MetafieldDefinitionType;
  useAsCollectionCondition: Scalars['Boolean']['output'];
  validationStatus: MetafieldDefinitionValidationStatus;
  validations: Array<MetafieldDefinitionValidation>;
};


export type MetafieldDefinitionMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  validationStatus?: InputMaybe<MetafieldValidationStatus>;
};


export type MetafieldDefinitionMetafieldsCountArgs = {
  validationStatus?: InputMaybe<MetafieldValidationStatus>;
};

export const MetafieldDefinitionAdminFilterStatus = {
  Failed: 'FAILED',
  Filterable: 'FILTERABLE',
  InProgress: 'IN_PROGRESS',
  NotFilterable: 'NOT_FILTERABLE'
} as const;

export type MetafieldDefinitionAdminFilterStatus = typeof MetafieldDefinitionAdminFilterStatus[keyof typeof MetafieldDefinitionAdminFilterStatus];
export type MetafieldDefinitionConnection = {
  edges: Array<MetafieldDefinitionEdge>;
  nodes: Array<MetafieldDefinition>;
  pageInfo: PageInfo;
};

export const MetafieldDefinitionConstraintStatus = {
  ConstrainedAndUnconstrained: 'CONSTRAINED_AND_UNCONSTRAINED',
  ConstrainedOnly: 'CONSTRAINED_ONLY',
  UnconstrainedOnly: 'UNCONSTRAINED_ONLY'
} as const;

export type MetafieldDefinitionConstraintStatus = typeof MetafieldDefinitionConstraintStatus[keyof typeof MetafieldDefinitionConstraintStatus];
export type MetafieldDefinitionConstraintSubtypeIdentifier = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type MetafieldDefinitionConstraintValue = {
  value: Scalars['String']['output'];
};

export type MetafieldDefinitionConstraintValueConnection = {
  edges: Array<MetafieldDefinitionConstraintValueEdge>;
  nodes: Array<MetafieldDefinitionConstraintValue>;
  pageInfo: PageInfo;
};

export type MetafieldDefinitionConstraintValueEdge = {
  cursor: Scalars['String']['output'];
  node: MetafieldDefinitionConstraintValue;
};

export type MetafieldDefinitionConstraintValueUpdateInput = {
  create?: InputMaybe<Scalars['String']['input']>;
  delete?: InputMaybe<Scalars['String']['input']>;
};

export type MetafieldDefinitionConstraints = {
  key?: Maybe<Scalars['String']['output']>;
  values: MetafieldDefinitionConstraintValueConnection;
};


export type MetafieldDefinitionConstraintsValuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MetafieldDefinitionConstraintsInput = {
  key: Scalars['String']['input'];
  values: Array<Scalars['String']['input']>;
};

export type MetafieldDefinitionConstraintsUpdatesInput = {
  key?: InputMaybe<Scalars['String']['input']>;
  values?: InputMaybe<Array<MetafieldDefinitionConstraintValueUpdateInput>>;
};

export type MetafieldDefinitionCreatePayload = {
  createdDefinition?: Maybe<MetafieldDefinition>;
  userErrors: Array<MetafieldDefinitionCreateUserError>;
};

export type MetafieldDefinitionCreateUserError = DisplayableError & {
  code?: Maybe<MetafieldDefinitionCreateUserErrorCode>;
  elementIndex?: Maybe<Scalars['Int']['output']>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MetafieldDefinitionCreateUserErrorCode = {
  AdminAccessInputNotAllowed: 'ADMIN_ACCESS_INPUT_NOT_ALLOWED',
  CapabilityRequiredButDisabled: 'CAPABILITY_REQUIRED_BUT_DISABLED',
  DuplicateOption: 'DUPLICATE_OPTION',
  GrantLimitExceeded: 'GRANT_LIMIT_EXCEEDED',
  Inclusion: 'INCLUSION',
  Invalid: 'INVALID',
  InvalidCapability: 'INVALID_CAPABILITY',
  InvalidCharacter: 'INVALID_CHARACTER',
  InvalidConstraints: 'INVALID_CONSTRAINTS',
  InvalidInputCombination: 'INVALID_INPUT_COMBINATION',
  InvalidOption: 'INVALID_OPTION',
  LimitExceeded: 'LIMIT_EXCEEDED',
  OwnerTypeLimitExceededForAutomatedCollections: 'OWNER_TYPE_LIMIT_EXCEEDED_FOR_AUTOMATED_COLLECTIONS',
  PinnedLimitReached: 'PINNED_LIMIT_REACHED',
  Present: 'PRESENT',
  ReservedNamespaceKey: 'RESERVED_NAMESPACE_KEY',
  ResourceTypeLimitExceeded: 'RESOURCE_TYPE_LIMIT_EXCEEDED',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  TooShort: 'TOO_SHORT',
  TypeNotAllowedForConditions: 'TYPE_NOT_ALLOWED_FOR_CONDITIONS',
  UnstructuredAlreadyExists: 'UNSTRUCTURED_ALREADY_EXISTS',
  UnsupportedPinning: 'UNSUPPORTED_PINNING'
} as const;

export type MetafieldDefinitionCreateUserErrorCode = typeof MetafieldDefinitionCreateUserErrorCode[keyof typeof MetafieldDefinitionCreateUserErrorCode];
export type MetafieldDefinitionDeletePayload = {
  deletedDefinitionId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<MetafieldDefinitionDeleteUserError>;
};

export type MetafieldDefinitionDeleteUserError = DisplayableError & {
  code?: Maybe<MetafieldDefinitionDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MetafieldDefinitionDeleteUserErrorCode = {
  DisallowedOwnerType: 'DISALLOWED_OWNER_TYPE',
  IdTypeDeletionError: 'ID_TYPE_DELETION_ERROR',
  InternalError: 'INTERNAL_ERROR',
  MetafieldDefinitionInUse: 'METAFIELD_DEFINITION_IN_USE',
  NotFound: 'NOT_FOUND',
  Present: 'PRESENT',
  ReferenceTypeDeletionError: 'REFERENCE_TYPE_DELETION_ERROR',
  ReservedNamespaceOrphanedMetafields: 'RESERVED_NAMESPACE_ORPHANED_METAFIELDS'
} as const;

export type MetafieldDefinitionDeleteUserErrorCode = typeof MetafieldDefinitionDeleteUserErrorCode[keyof typeof MetafieldDefinitionDeleteUserErrorCode];
export type MetafieldDefinitionEdge = {
  cursor: Scalars['String']['output'];
  node: MetafieldDefinition;
};

export type MetafieldDefinitionInput = {
  access?: InputMaybe<MetafieldAccessInput>;
  capabilities?: InputMaybe<MetafieldCapabilityCreateInput>;
  constraints?: InputMaybe<MetafieldDefinitionConstraintsInput>;
  description?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  name: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
  ownerType: MetafieldOwnerType;
  pin?: InputMaybe<Scalars['Boolean']['input']>;
  type: Scalars['String']['input'];
  validations?: InputMaybe<Array<MetafieldDefinitionValidationInput>>;
};

export type MetafieldDefinitionPinPayload = {
  pinnedDefinition?: Maybe<MetafieldDefinition>;
  userErrors: Array<MetafieldDefinitionPinUserError>;
};

export type MetafieldDefinitionPinUserError = DisplayableError & {
  code?: Maybe<MetafieldDefinitionPinUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MetafieldDefinitionPinUserErrorCode = {
  AlreadyPinned: 'ALREADY_PINNED',
  DisallowedOwnerType: 'DISALLOWED_OWNER_TYPE',
  InternalError: 'INTERNAL_ERROR',
  NotFound: 'NOT_FOUND',
  PinnedLimitReached: 'PINNED_LIMIT_REACHED',
  UnsupportedPinning: 'UNSUPPORTED_PINNING'
} as const;

export type MetafieldDefinitionPinUserErrorCode = typeof MetafieldDefinitionPinUserErrorCode[keyof typeof MetafieldDefinitionPinUserErrorCode];
export const MetafieldDefinitionPinnedStatus = {
  Any: 'ANY',
  Pinned: 'PINNED',
  Unpinned: 'UNPINNED'
} as const;

export type MetafieldDefinitionPinnedStatus = typeof MetafieldDefinitionPinnedStatus[keyof typeof MetafieldDefinitionPinnedStatus];
export const MetafieldDefinitionSortKeys = {
  Id: 'ID',
  Name: 'NAME',
  PinnedPosition: 'PINNED_POSITION',
  Relevance: 'RELEVANCE'
} as const;

export type MetafieldDefinitionSortKeys = typeof MetafieldDefinitionSortKeys[keyof typeof MetafieldDefinitionSortKeys];
export type MetafieldDefinitionSupportedValidation = {
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

export type MetafieldDefinitionType = {
  category: Scalars['String']['output'];
  name: Scalars['String']['output'];
  supportedValidations: Array<MetafieldDefinitionSupportedValidation>;
  supportsDefinitionMigrations: Scalars['Boolean']['output'];
  /** @deprecated `valueType` is deprecated and `name` should be used for type information. */
  valueType: MetafieldValueType;
};

export type MetafieldDefinitionUnpinPayload = {
  unpinnedDefinition?: Maybe<MetafieldDefinition>;
  userErrors: Array<MetafieldDefinitionUnpinUserError>;
};

export type MetafieldDefinitionUnpinUserError = DisplayableError & {
  code?: Maybe<MetafieldDefinitionUnpinUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MetafieldDefinitionUnpinUserErrorCode = {
  DisallowedOwnerType: 'DISALLOWED_OWNER_TYPE',
  InternalError: 'INTERNAL_ERROR',
  NotFound: 'NOT_FOUND',
  NotPinned: 'NOT_PINNED'
} as const;

export type MetafieldDefinitionUnpinUserErrorCode = typeof MetafieldDefinitionUnpinUserErrorCode[keyof typeof MetafieldDefinitionUnpinUserErrorCode];
export type MetafieldDefinitionUpdateInput = {
  access?: InputMaybe<MetafieldAccessUpdateInput>;
  capabilities?: InputMaybe<MetafieldCapabilityUpdateInput>;
  constraintsUpdates?: InputMaybe<MetafieldDefinitionConstraintsUpdatesInput>;
  description?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  ownerType: MetafieldOwnerType;
  pin?: InputMaybe<Scalars['Boolean']['input']>;
  validations?: InputMaybe<Array<MetafieldDefinitionValidationInput>>;
};

export type MetafieldDefinitionUpdatePayload = {
  updatedDefinition?: Maybe<MetafieldDefinition>;
  userErrors: Array<MetafieldDefinitionUpdateUserError>;
  validationJob?: Maybe<Job>;
};

export type MetafieldDefinitionUpdateUserError = DisplayableError & {
  code?: Maybe<MetafieldDefinitionUpdateUserErrorCode>;
  elementIndex?: Maybe<Scalars['Int']['output']>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MetafieldDefinitionUpdateUserErrorCode = {
  AdminAccessInputNotAllowed: 'ADMIN_ACCESS_INPUT_NOT_ALLOWED',
  CapabilityCannotBeDisabled: 'CAPABILITY_CANNOT_BE_DISABLED',
  CapabilityRequiredButDisabled: 'CAPABILITY_REQUIRED_BUT_DISABLED',
  GrantLimitExceeded: 'GRANT_LIMIT_EXCEEDED',
  InternalError: 'INTERNAL_ERROR',
  InvalidCapability: 'INVALID_CAPABILITY',
  InvalidConstraints: 'INVALID_CONSTRAINTS',
  InvalidInput: 'INVALID_INPUT',
  InvalidInputCombination: 'INVALID_INPUT_COMBINATION',
  MetafieldDefinitionInUse: 'METAFIELD_DEFINITION_IN_USE',
  MetaobjectDefinitionChanged: 'METAOBJECT_DEFINITION_CHANGED',
  NotFound: 'NOT_FOUND',
  OwnerTypeLimitExceededForAutomatedCollections: 'OWNER_TYPE_LIMIT_EXCEEDED_FOR_AUTOMATED_COLLECTIONS',
  PinnedLimitReached: 'PINNED_LIMIT_REACHED',
  Present: 'PRESENT',
  TooLong: 'TOO_LONG',
  TypeNotAllowedForConditions: 'TYPE_NOT_ALLOWED_FOR_CONDITIONS',
  UnsupportedPinning: 'UNSUPPORTED_PINNING'
} as const;

export type MetafieldDefinitionUpdateUserErrorCode = typeof MetafieldDefinitionUpdateUserErrorCode[keyof typeof MetafieldDefinitionUpdateUserErrorCode];
export type MetafieldDefinitionValidation = {
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
  value?: Maybe<Scalars['String']['output']>;
};

export type MetafieldDefinitionValidationInput = {
  name: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export const MetafieldDefinitionValidationStatus = {
  AllValid: 'ALL_VALID',
  InProgress: 'IN_PROGRESS',
  SomeInvalid: 'SOME_INVALID'
} as const;

export type MetafieldDefinitionValidationStatus = typeof MetafieldDefinitionValidationStatus[keyof typeof MetafieldDefinitionValidationStatus];
export type MetafieldEdge = {
  cursor: Scalars['String']['output'];
  node: Metafield;
};

export const MetafieldGrantAccessLevel = {
  Read: 'READ',
  ReadWrite: 'READ_WRITE'
} as const;

export type MetafieldGrantAccessLevel = typeof MetafieldGrantAccessLevel[keyof typeof MetafieldGrantAccessLevel];
export type MetafieldIdentifier = {
  key: Scalars['String']['output'];
  namespace: Scalars['String']['output'];
  ownerId: Scalars['ID']['output'];
};

export type MetafieldIdentifierInput = {
  key: Scalars['String']['input'];
  namespace: Scalars['String']['input'];
  ownerId: Scalars['ID']['input'];
};

export type MetafieldInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

export const MetafieldOwnerType = {
  ApiPermission: 'API_PERMISSION',
  Article: 'ARTICLE',
  Blog: 'BLOG',
  Carttransform: 'CARTTRANSFORM',
  Collection: 'COLLECTION',
  Company: 'COMPANY',
  CompanyLocation: 'COMPANY_LOCATION',
  Customer: 'CUSTOMER',
  DeliveryCustomization: 'DELIVERY_CUSTOMIZATION',
  Discount: 'DISCOUNT',
  Draftorder: 'DRAFTORDER',
  FulfillmentConstraintRule: 'FULFILLMENT_CONSTRAINT_RULE',
  GiftCardTransaction: 'GIFT_CARD_TRANSACTION',
  Location: 'LOCATION',
  Market: 'MARKET',
  MediaImage: 'MEDIA_IMAGE',
  Order: 'ORDER',
  OrderRoutingLocationRule: 'ORDER_ROUTING_LOCATION_RULE',
  Page: 'PAGE',
  PaymentCustomization: 'PAYMENT_CUSTOMIZATION',
  Product: 'PRODUCT',
  Productvariant: 'PRODUCTVARIANT',
  SellingPlan: 'SELLING_PLAN',
  Shop: 'SHOP',
  Validation: 'VALIDATION'
} as const;

export type MetafieldOwnerType = typeof MetafieldOwnerType[keyof typeof MetafieldOwnerType];
export type MetafieldReference = Collection | Company | Customer | GenericFile | MediaImage | Metaobject | Model3d | Order | Page | Product | ProductVariant | TaxonomyValue | Video;

export type MetafieldReferenceConnection = {
  edges: Array<MetafieldReferenceEdge>;
  nodes: Array<Maybe<MetafieldReference>>;
  pageInfo: PageInfo;
};

export type MetafieldReferenceEdge = {
  cursor: Scalars['String']['output'];
  node?: Maybe<MetafieldReference>;
};

export type MetafieldReferencer = AppInstallation | Article | Blog | Collection | Company | CompanyLocation | Customer | DeliveryCustomization | DiscountAutomaticNode | DiscountCodeNode | DiscountNode | DraftOrder | FulfillmentOrder | Location | Market | Metaobject | Order | Page | PaymentCustomization | Product | ProductVariant | Shop;

export type MetafieldRelation = {
  key: Scalars['String']['output'];
  name: Scalars['String']['output'];
  namespace: Scalars['String']['output'];
  referencer: MetafieldReferencer;
  target: MetafieldReference;
};

export type MetafieldRelationConnection = {
  edges: Array<MetafieldRelationEdge>;
  nodes: Array<MetafieldRelation>;
  pageInfo: PageInfo;
};

export type MetafieldRelationEdge = {
  cursor: Scalars['String']['output'];
  node: MetafieldRelation;
};

export const MetafieldStorefrontAccess = {
  None: 'NONE',
  PublicRead: 'PUBLIC_READ'
} as const;

export type MetafieldStorefrontAccess = typeof MetafieldStorefrontAccess[keyof typeof MetafieldStorefrontAccess];
export const MetafieldStorefrontAccessInput = {
  None: 'NONE',
  PublicRead: 'PUBLIC_READ'
} as const;

export type MetafieldStorefrontAccessInput = typeof MetafieldStorefrontAccessInput[keyof typeof MetafieldStorefrontAccessInput];
export const MetafieldValidationStatus = {
  Any: 'ANY',
  Invalid: 'INVALID',
  Valid: 'VALID'
} as const;

export type MetafieldValidationStatus = typeof MetafieldValidationStatus[keyof typeof MetafieldValidationStatus];
export const MetafieldValueType = {
  Boolean: 'BOOLEAN',
  Integer: 'INTEGER',
  JsonString: 'JSON_STRING',
  String: 'STRING'
} as const;

export type MetafieldValueType = typeof MetafieldValueType[keyof typeof MetafieldValueType];
export type MetafieldsDeletePayload = {
  deletedMetafields?: Maybe<Array<Maybe<MetafieldIdentifier>>>;
  userErrors: Array<UserError>;
};

export type MetafieldsSetInput = {
  compareDigest?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
  ownerId: Scalars['ID']['input'];
  type?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};

export type MetafieldsSetPayload = {
  metafields?: Maybe<Array<Metafield>>;
  userErrors: Array<MetafieldsSetUserError>;
};

export type MetafieldsSetUserError = DisplayableError & {
  code?: Maybe<MetafieldsSetUserErrorCode>;
  elementIndex?: Maybe<Scalars['Int']['output']>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MetafieldsSetUserErrorCode = {
  AppNotAuthorized: 'APP_NOT_AUTHORIZED',
  Blank: 'BLANK',
  CapabilityViolation: 'CAPABILITY_VIOLATION',
  Inclusion: 'INCLUSION',
  InternalError: 'INTERNAL_ERROR',
  InvalidCompareDigest: 'INVALID_COMPARE_DIGEST',
  InvalidType: 'INVALID_TYPE',
  InvalidValue: 'INVALID_VALUE',
  LessThanOrEqualTo: 'LESS_THAN_OR_EQUAL_TO',
  Present: 'PRESENT',
  StaleObject: 'STALE_OBJECT',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  TooShort: 'TOO_SHORT'
} as const;

export type MetafieldsSetUserErrorCode = typeof MetafieldsSetUserErrorCode[keyof typeof MetafieldsSetUserErrorCode];
export type Metaobject = Node & {
  capabilities: MetaobjectCapabilityData;
  createdBy: App;
  createdByApp: App;
  createdByStaff?: Maybe<StaffMember>;
  definition: MetaobjectDefinition;
  displayName: Scalars['String']['output'];
  field?: Maybe<MetaobjectField>;
  fields: Array<MetaobjectField>;
  handle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  referencedBy: MetafieldRelationConnection;
  /** @deprecated Use `createdByStaff` instead. */
  staffMember?: Maybe<StaffMember>;
  thumbnailField?: Maybe<MetaobjectField>;
  type: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};


export type MetaobjectFieldArgs = {
  key: Scalars['String']['input'];
};


export type MetaobjectReferencedByArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MetaobjectAccess = {
  admin: MetaobjectAdminAccess;
  storefront: MetaobjectStorefrontAccess;
};

export type MetaobjectAccessInput = {
  admin?: InputMaybe<MetaobjectAdminAccessInput>;
  storefront?: InputMaybe<MetaobjectStorefrontAccess>;
};

export const MetaobjectAdminAccess = {
  MerchantRead: 'MERCHANT_READ',
  MerchantReadWrite: 'MERCHANT_READ_WRITE',
  Private: 'PRIVATE',
  PublicRead: 'PUBLIC_READ',
  PublicReadWrite: 'PUBLIC_READ_WRITE'
} as const;

export type MetaobjectAdminAccess = typeof MetaobjectAdminAccess[keyof typeof MetaobjectAdminAccess];
export const MetaobjectAdminAccessInput = {
  MerchantRead: 'MERCHANT_READ',
  MerchantReadWrite: 'MERCHANT_READ_WRITE'
} as const;

export type MetaobjectAdminAccessInput = typeof MetaobjectAdminAccessInput[keyof typeof MetaobjectAdminAccessInput];
export type MetaobjectBulkDeletePayload = {
  job?: Maybe<Job>;
  userErrors: Array<MetaobjectUserError>;
};

export type MetaobjectBulkDeleteWhereCondition = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  type?: InputMaybe<Scalars['String']['input']>;
};

export type MetaobjectCapabilities = {
  onlineStore?: Maybe<MetaobjectCapabilitiesOnlineStore>;
  publishable: MetaobjectCapabilitiesPublishable;
  renderable?: Maybe<MetaobjectCapabilitiesRenderable>;
  translatable: MetaobjectCapabilitiesTranslatable;
};

export type MetaobjectCapabilitiesOnlineStore = {
  data?: Maybe<MetaobjectCapabilityDefinitionDataOnlineStore>;
  enabled: Scalars['Boolean']['output'];
};

export type MetaobjectCapabilitiesPublishable = {
  enabled: Scalars['Boolean']['output'];
};

export type MetaobjectCapabilitiesRenderable = {
  data?: Maybe<MetaobjectCapabilityDefinitionDataRenderable>;
  enabled: Scalars['Boolean']['output'];
};

export type MetaobjectCapabilitiesTranslatable = {
  enabled: Scalars['Boolean']['output'];
};

export type MetaobjectCapabilityCreateInput = {
  onlineStore?: InputMaybe<MetaobjectCapabilityOnlineStoreInput>;
  publishable?: InputMaybe<MetaobjectCapabilityPublishableInput>;
  renderable?: InputMaybe<MetaobjectCapabilityRenderableInput>;
  translatable?: InputMaybe<MetaobjectCapabilityTranslatableInput>;
};

export type MetaobjectCapabilityData = {
  onlineStore?: Maybe<MetaobjectCapabilityDataOnlineStore>;
  publishable?: Maybe<MetaobjectCapabilityDataPublishable>;
};

export type MetaobjectCapabilityDataInput = {
  onlineStore?: InputMaybe<MetaobjectCapabilityDataOnlineStoreInput>;
  publishable?: InputMaybe<MetaobjectCapabilityDataPublishableInput>;
};

export type MetaobjectCapabilityDataOnlineStore = {
  templateSuffix?: Maybe<Scalars['String']['output']>;
};

export type MetaobjectCapabilityDataOnlineStoreInput = {
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
};

export type MetaobjectCapabilityDataPublishable = {
  status: MetaobjectStatus;
};

export type MetaobjectCapabilityDataPublishableInput = {
  status: MetaobjectStatus;
};

export type MetaobjectCapabilityDefinitionDataOnlineStore = {
  canCreateRedirects: Scalars['Boolean']['output'];
  urlHandle: Scalars['String']['output'];
};

export type MetaobjectCapabilityDefinitionDataOnlineStoreInput = {
  createRedirects?: InputMaybe<Scalars['Boolean']['input']>;
  urlHandle: Scalars['String']['input'];
};

export type MetaobjectCapabilityDefinitionDataRenderable = {
  metaDescriptionKey?: Maybe<Scalars['String']['output']>;
  metaTitleKey?: Maybe<Scalars['String']['output']>;
};

export type MetaobjectCapabilityDefinitionDataRenderableInput = {
  metaDescriptionKey?: InputMaybe<Scalars['String']['input']>;
  metaTitleKey?: InputMaybe<Scalars['String']['input']>;
};

export type MetaobjectCapabilityOnlineStoreInput = {
  data?: InputMaybe<MetaobjectCapabilityDefinitionDataOnlineStoreInput>;
  enabled: Scalars['Boolean']['input'];
};

export type MetaobjectCapabilityPublishableInput = {
  enabled: Scalars['Boolean']['input'];
};

export type MetaobjectCapabilityRenderableInput = {
  data?: InputMaybe<MetaobjectCapabilityDefinitionDataRenderableInput>;
  enabled: Scalars['Boolean']['input'];
};

export type MetaobjectCapabilityTranslatableInput = {
  enabled: Scalars['Boolean']['input'];
};

export type MetaobjectCapabilityUpdateInput = {
  onlineStore?: InputMaybe<MetaobjectCapabilityOnlineStoreInput>;
  publishable?: InputMaybe<MetaobjectCapabilityPublishableInput>;
  renderable?: InputMaybe<MetaobjectCapabilityRenderableInput>;
  translatable?: InputMaybe<MetaobjectCapabilityTranslatableInput>;
};

export type MetaobjectConnection = {
  edges: Array<MetaobjectEdge>;
  nodes: Array<Metaobject>;
  pageInfo: PageInfo;
};

export type MetaobjectCreateInput = {
  capabilities?: InputMaybe<MetaobjectCapabilityDataInput>;
  fields?: InputMaybe<Array<MetaobjectFieldInput>>;
  handle?: InputMaybe<Scalars['String']['input']>;
  type: Scalars['String']['input'];
};

export type MetaobjectCreatePayload = {
  metaobject?: Maybe<Metaobject>;
  userErrors: Array<MetaobjectUserError>;
};

export type MetaobjectDefinition = Node & {
  access: MetaobjectAccess;
  capabilities: MetaobjectCapabilities;
  createdByApp: App;
  createdByStaff?: Maybe<StaffMember>;
  description?: Maybe<Scalars['String']['output']>;
  displayNameKey?: Maybe<Scalars['String']['output']>;
  fieldDefinitions: Array<MetaobjectFieldDefinition>;
  hasThumbnailField: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  metaobjects: MetaobjectConnection;
  metaobjectsCount: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  type: Scalars['String']['output'];
};


export type MetaobjectDefinitionMetaobjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MetaobjectDefinitionConnection = {
  edges: Array<MetaobjectDefinitionEdge>;
  nodes: Array<MetaobjectDefinition>;
  pageInfo: PageInfo;
};

export type MetaobjectDefinitionCreateInput = {
  access?: InputMaybe<MetaobjectAccessInput>;
  capabilities?: InputMaybe<MetaobjectCapabilityCreateInput>;
  description?: InputMaybe<Scalars['String']['input']>;
  displayNameKey?: InputMaybe<Scalars['String']['input']>;
  fieldDefinitions: Array<MetaobjectFieldDefinitionCreateInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  type: Scalars['String']['input'];
};

export type MetaobjectDefinitionCreatePayload = {
  metaobjectDefinition?: Maybe<MetaobjectDefinition>;
  userErrors: Array<MetaobjectUserError>;
};

export type MetaobjectDefinitionDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<MetaobjectUserError>;
};

export type MetaobjectDefinitionEdge = {
  cursor: Scalars['String']['output'];
  node: MetaobjectDefinition;
};

export type MetaobjectDefinitionUpdateInput = {
  access?: InputMaybe<MetaobjectAccessInput>;
  capabilities?: InputMaybe<MetaobjectCapabilityUpdateInput>;
  description?: InputMaybe<Scalars['String']['input']>;
  displayNameKey?: InputMaybe<Scalars['String']['input']>;
  fieldDefinitions?: InputMaybe<Array<MetaobjectFieldDefinitionOperationInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
  resetFieldOrder?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MetaobjectDefinitionUpdatePayload = {
  metaobjectDefinition?: Maybe<MetaobjectDefinition>;
  userErrors: Array<MetaobjectUserError>;
};

export type MetaobjectDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<MetaobjectUserError>;
};

export type MetaobjectEdge = {
  cursor: Scalars['String']['output'];
  node: Metaobject;
};

export type MetaobjectField = {
  definition: MetaobjectFieldDefinition;
  jsonValue?: Maybe<Scalars['JSON']['output']>;
  key: Scalars['String']['output'];
  reference?: Maybe<MetafieldReference>;
  references?: Maybe<MetafieldReferenceConnection>;
  thumbnail?: Maybe<MetaobjectThumbnail>;
  type: Scalars['String']['output'];
  value?: Maybe<Scalars['String']['output']>;
};


export type MetaobjectFieldReferencesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type MetaobjectFieldDefinition = {
  description?: Maybe<Scalars['String']['output']>;
  key: Scalars['String']['output'];
  name: Scalars['String']['output'];
  required: Scalars['Boolean']['output'];
  type: MetafieldDefinitionType;
  validations: Array<MetafieldDefinitionValidation>;
};

export type MetaobjectFieldDefinitionCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  type: Scalars['String']['input'];
  validations?: InputMaybe<Array<MetafieldDefinitionValidationInput>>;
};

export type MetaobjectFieldDefinitionDeleteInput = {
  key: Scalars['String']['input'];
};

export type MetaobjectFieldDefinitionOperationInput = {
  create?: InputMaybe<MetaobjectFieldDefinitionCreateInput>;
  delete?: InputMaybe<MetaobjectFieldDefinitionDeleteInput>;
  update?: InputMaybe<MetaobjectFieldDefinitionUpdateInput>;
};

export type MetaobjectFieldDefinitionUpdateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  required?: InputMaybe<Scalars['Boolean']['input']>;
  validations?: InputMaybe<Array<MetafieldDefinitionValidationInput>>;
};

export type MetaobjectFieldInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type MetaobjectHandleInput = {
  handle: Scalars['String']['input'];
  type: Scalars['String']['input'];
};

export const MetaobjectStatus = {
  Active: 'ACTIVE',
  Draft: 'DRAFT'
} as const;

export type MetaobjectStatus = typeof MetaobjectStatus[keyof typeof MetaobjectStatus];
export const MetaobjectStorefrontAccess = {
  None: 'NONE',
  PublicRead: 'PUBLIC_READ'
} as const;

export type MetaobjectStorefrontAccess = typeof MetaobjectStorefrontAccess[keyof typeof MetaobjectStorefrontAccess];
export type MetaobjectThumbnail = {
  file?: Maybe<File>;
  hex?: Maybe<Scalars['String']['output']>;
};

export type MetaobjectUpdateInput = {
  capabilities?: InputMaybe<MetaobjectCapabilityDataInput>;
  fields?: InputMaybe<Array<MetaobjectFieldInput>>;
  handle?: InputMaybe<Scalars['String']['input']>;
  redirectNewHandle?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MetaobjectUpdatePayload = {
  metaobject?: Maybe<Metaobject>;
  userErrors: Array<MetaobjectUserError>;
};

export type MetaobjectUpsertInput = {
  capabilities?: InputMaybe<MetaobjectCapabilityDataInput>;
  fields?: InputMaybe<Array<MetaobjectFieldInput>>;
  handle?: InputMaybe<Scalars['String']['input']>;
};

export type MetaobjectUpsertPayload = {
  metaobject?: Maybe<Metaobject>;
  userErrors: Array<MetaobjectUserError>;
};

export type MetaobjectUserError = DisplayableError & {
  code?: Maybe<MetaobjectUserErrorCode>;
  elementIndex?: Maybe<Scalars['Int']['output']>;
  elementKey?: Maybe<Scalars['String']['output']>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MetaobjectUserErrorCode = {
  AdminAccessInputNotAllowed: 'ADMIN_ACCESS_INPUT_NOT_ALLOWED',
  Blank: 'BLANK',
  CapabilityNotEnabled: 'CAPABILITY_NOT_ENABLED',
  DisplayNameConflict: 'DISPLAY_NAME_CONFLICT',
  DuplicateFieldInput: 'DUPLICATE_FIELD_INPUT',
  FieldTypeInvalid: 'FIELD_TYPE_INVALID',
  Immutable: 'IMMUTABLE',
  Inclusion: 'INCLUSION',
  InternalError: 'INTERNAL_ERROR',
  Invalid: 'INVALID',
  InvalidOption: 'INVALID_OPTION',
  InvalidType: 'INVALID_TYPE',
  InvalidValue: 'INVALID_VALUE',
  MaxDefinitionsExceeded: 'MAX_DEFINITIONS_EXCEEDED',
  MaxObjectsExceeded: 'MAX_OBJECTS_EXCEEDED',
  MissingRequiredKeys: 'MISSING_REQUIRED_KEYS',
  NotAuthorized: 'NOT_AUTHORIZED',
  ObjectFieldRequired: 'OBJECT_FIELD_REQUIRED',
  ObjectFieldTaken: 'OBJECT_FIELD_TAKEN',
  Present: 'PRESENT',
  RecordNotFound: 'RECORD_NOT_FOUND',
  ReservedName: 'RESERVED_NAME',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  TooShort: 'TOO_SHORT',
  UndefinedObjectField: 'UNDEFINED_OBJECT_FIELD',
  UndefinedObjectType: 'UNDEFINED_OBJECT_TYPE',
  UrlHandleBlank: 'URL_HANDLE_BLANK',
  UrlHandleInvalid: 'URL_HANDLE_INVALID',
  UrlHandleTaken: 'URL_HANDLE_TAKEN'
} as const;

export type MetaobjectUserErrorCode = typeof MetaobjectUserErrorCode[keyof typeof MetaobjectUserErrorCode];
export const MethodDefinitionSortKeys = {
  Id: 'ID',
  RateProviderType: 'RATE_PROVIDER_TYPE',
  Relevance: 'RELEVANCE'
} as const;

export type MethodDefinitionSortKeys = typeof MethodDefinitionSortKeys[keyof typeof MethodDefinitionSortKeys];
export type MobilePlatformApplication = AndroidApplication | AppleApplication;

export type MobilePlatformApplicationConnection = {
  edges: Array<MobilePlatformApplicationEdge>;
  nodes: Array<MobilePlatformApplication>;
  pageInfo: PageInfo;
};

export type MobilePlatformApplicationCreateAndroidInput = {
  appLinksEnabled: Scalars['Boolean']['input'];
  applicationId?: InputMaybe<Scalars['String']['input']>;
  sha256CertFingerprints: Array<Scalars['String']['input']>;
};

export type MobilePlatformApplicationCreateAppleInput = {
  appClipApplicationId?: InputMaybe<Scalars['String']['input']>;
  appClipsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  appId?: InputMaybe<Scalars['String']['input']>;
  sharedWebCredentialsEnabled: Scalars['Boolean']['input'];
  universalLinksEnabled: Scalars['Boolean']['input'];
};

export type MobilePlatformApplicationCreateInput = {
  android?: InputMaybe<MobilePlatformApplicationCreateAndroidInput>;
  apple?: InputMaybe<MobilePlatformApplicationCreateAppleInput>;
};

export type MobilePlatformApplicationCreatePayload = {
  mobilePlatformApplication?: Maybe<MobilePlatformApplication>;
  userErrors: Array<MobilePlatformApplicationUserError>;
};

export type MobilePlatformApplicationDeletePayload = {
  deletedMobilePlatformApplicationId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<MobilePlatformApplicationUserError>;
};

export type MobilePlatformApplicationEdge = {
  cursor: Scalars['String']['output'];
  node: MobilePlatformApplication;
};

export type MobilePlatformApplicationUpdateAndroidInput = {
  appLinksEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  applicationId?: InputMaybe<Scalars['String']['input']>;
  sha256CertFingerprints?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type MobilePlatformApplicationUpdateAppleInput = {
  appClipApplicationId?: InputMaybe<Scalars['String']['input']>;
  appClipsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  appId?: InputMaybe<Scalars['String']['input']>;
  sharedWebCredentialsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  universalLinksEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MobilePlatformApplicationUpdateInput = {
  android?: InputMaybe<MobilePlatformApplicationUpdateAndroidInput>;
  apple?: InputMaybe<MobilePlatformApplicationUpdateAppleInput>;
};

export type MobilePlatformApplicationUpdatePayload = {
  mobilePlatformApplication?: Maybe<MobilePlatformApplication>;
  userErrors: Array<MobilePlatformApplicationUserError>;
};

export type MobilePlatformApplicationUserError = DisplayableError & {
  code?: Maybe<MobilePlatformApplicationUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const MobilePlatformApplicationUserErrorCode = {
  Invalid: 'INVALID',
  NotFound: 'NOT_FOUND',
  TooLong: 'TOO_LONG'
} as const;

export type MobilePlatformApplicationUserErrorCode = typeof MobilePlatformApplicationUserErrorCode[keyof typeof MobilePlatformApplicationUserErrorCode];
export type Model3d = File & Media & Node & {
  alt?: Maybe<Scalars['String']['output']>;
  boundingBox?: Maybe<Model3dBoundingBox>;
  createdAt: Scalars['DateTime']['output'];
  fileErrors: Array<FileError>;
  fileStatus: FileStatus;
  filename: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  mediaContentType: MediaContentType;
  mediaErrors: Array<MediaError>;
  mediaWarnings: Array<MediaWarning>;
  originalSource?: Maybe<Model3dSource>;
  preview?: Maybe<MediaPreviewImage>;
  sources: Array<Model3dSource>;
  status: MediaStatus;
  updatedAt: Scalars['DateTime']['output'];
};

export type Model3dBoundingBox = {
  size: Vector3;
};

export type Model3dSource = {
  filesize: Scalars['Int']['output'];
  format: Scalars['String']['output'];
  mimeType: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type MoneyBag = {
  presentmentMoney: MoneyV2;
  shopMoney: MoneyV2;
};

export type MoneyBagInput = {
  presentmentMoney?: InputMaybe<MoneyInput>;
  shopMoney: MoneyInput;
};

export type MoneyInput = {
  amount: Scalars['Decimal']['input'];
  currencyCode: CurrencyCode;
};

export type MoneyV2 = {
  amount: Scalars['Decimal']['output'];
  currencyCode: CurrencyCode;
};

export type MoveInput = {
  id: Scalars['ID']['input'];
  newPosition: Scalars['UnsignedInt64']['input'];
};

export type Mutation = {
  /** @deprecated Use `abandonmentUpdateActivitiesDeliveryStatuses` instead. */
  abandonmentEmailStateUpdate?: Maybe<AbandonmentEmailStateUpdatePayload>;
  abandonmentUpdateActivitiesDeliveryStatuses?: Maybe<AbandonmentUpdateActivitiesDeliveryStatusesPayload>;
  appPurchaseOneTimeCreate?: Maybe<AppPurchaseOneTimeCreatePayload>;
  appRevokeAccessScopes?: Maybe<AppRevokeAccessScopesPayload>;
  appSubscriptionCancel?: Maybe<AppSubscriptionCancelPayload>;
  appSubscriptionCreate?: Maybe<AppSubscriptionCreatePayload>;
  appSubscriptionLineItemUpdate?: Maybe<AppSubscriptionLineItemUpdatePayload>;
  appSubscriptionTrialExtend?: Maybe<AppSubscriptionTrialExtendPayload>;
  appUsageRecordCreate?: Maybe<AppUsageRecordCreatePayload>;
  articleCreate?: Maybe<ArticleCreatePayload>;
  articleDelete?: Maybe<ArticleDeletePayload>;
  articleUpdate?: Maybe<ArticleUpdatePayload>;
  blogCreate?: Maybe<BlogCreatePayload>;
  blogDelete?: Maybe<BlogDeletePayload>;
  blogUpdate?: Maybe<BlogUpdatePayload>;
  bulkOperationCancel?: Maybe<BulkOperationCancelPayload>;
  bulkOperationRunMutation?: Maybe<BulkOperationRunMutationPayload>;
  bulkOperationRunQuery?: Maybe<BulkOperationRunQueryPayload>;
  bulkProductResourceFeedbackCreate?: Maybe<BulkProductResourceFeedbackCreatePayload>;
  carrierServiceCreate?: Maybe<CarrierServiceCreatePayload>;
  carrierServiceDelete?: Maybe<CarrierServiceDeletePayload>;
  carrierServiceUpdate?: Maybe<CarrierServiceUpdatePayload>;
  cartTransformCreate?: Maybe<CartTransformCreatePayload>;
  cartTransformDelete?: Maybe<CartTransformDeletePayload>;
  catalogContextUpdate?: Maybe<CatalogContextUpdatePayload>;
  catalogCreate?: Maybe<CatalogCreatePayload>;
  catalogDelete?: Maybe<CatalogDeletePayload>;
  catalogUpdate?: Maybe<CatalogUpdatePayload>;
  checkoutBrandingUpsert?: Maybe<CheckoutBrandingUpsertPayload>;
  collectionAddProducts?: Maybe<CollectionAddProductsPayload>;
  collectionAddProductsV2?: Maybe<CollectionAddProductsV2Payload>;
  collectionCreate?: Maybe<CollectionCreatePayload>;
  collectionDelete?: Maybe<CollectionDeletePayload>;
  /** @deprecated Use `publishablePublish` instead. */
  collectionPublish?: Maybe<CollectionPublishPayload>;
  collectionRemoveProducts?: Maybe<CollectionRemoveProductsPayload>;
  collectionReorderProducts?: Maybe<CollectionReorderProductsPayload>;
  /** @deprecated Use `publishableUnpublish` instead. */
  collectionUnpublish?: Maybe<CollectionUnpublishPayload>;
  collectionUpdate?: Maybe<CollectionUpdatePayload>;
  combinedListingUpdate?: Maybe<CombinedListingUpdatePayload>;
  commentApprove?: Maybe<CommentApprovePayload>;
  commentDelete?: Maybe<CommentDeletePayload>;
  commentNotSpam?: Maybe<CommentNotSpamPayload>;
  commentSpam?: Maybe<CommentSpamPayload>;
  companiesDelete?: Maybe<CompaniesDeletePayload>;
  companyAddressDelete?: Maybe<CompanyAddressDeletePayload>;
  companyAssignCustomerAsContact?: Maybe<CompanyAssignCustomerAsContactPayload>;
  companyAssignMainContact?: Maybe<CompanyAssignMainContactPayload>;
  companyContactAssignRole?: Maybe<CompanyContactAssignRolePayload>;
  companyContactAssignRoles?: Maybe<CompanyContactAssignRolesPayload>;
  companyContactCreate?: Maybe<CompanyContactCreatePayload>;
  companyContactDelete?: Maybe<CompanyContactDeletePayload>;
  companyContactRemoveFromCompany?: Maybe<CompanyContactRemoveFromCompanyPayload>;
  companyContactRevokeRole?: Maybe<CompanyContactRevokeRolePayload>;
  companyContactRevokeRoles?: Maybe<CompanyContactRevokeRolesPayload>;
  companyContactSendWelcomeEmail?: Maybe<CompanyContactSendWelcomeEmailPayload>;
  companyContactUpdate?: Maybe<CompanyContactUpdatePayload>;
  companyContactsDelete?: Maybe<CompanyContactsDeletePayload>;
  companyCreate?: Maybe<CompanyCreatePayload>;
  companyDelete?: Maybe<CompanyDeletePayload>;
  companyLocationAssignAddress?: Maybe<CompanyLocationAssignAddressPayload>;
  companyLocationAssignRoles?: Maybe<CompanyLocationAssignRolesPayload>;
  companyLocationAssignStaffMembers?: Maybe<CompanyLocationAssignStaffMembersPayload>;
  /** @deprecated Use `companyLocationTaxSettingsUpdate` instead. */
  companyLocationAssignTaxExemptions?: Maybe<CompanyLocationAssignTaxExemptionsPayload>;
  companyLocationCreate?: Maybe<CompanyLocationCreatePayload>;
  /** @deprecated Use `companyLocationTaxSettingsUpdate` instead. */
  companyLocationCreateTaxRegistration?: Maybe<CompanyLocationCreateTaxRegistrationPayload>;
  companyLocationDelete?: Maybe<CompanyLocationDeletePayload>;
  companyLocationRemoveStaffMembers?: Maybe<CompanyLocationRemoveStaffMembersPayload>;
  companyLocationRevokeRoles?: Maybe<CompanyLocationRevokeRolesPayload>;
  /** @deprecated Use `companyLocationTaxSettingsUpdate` instead. */
  companyLocationRevokeTaxExemptions?: Maybe<CompanyLocationRevokeTaxExemptionsPayload>;
  /** @deprecated Use `companyLocationTaxSettingsUpdate` instead. */
  companyLocationRevokeTaxRegistration?: Maybe<CompanyLocationRevokeTaxRegistrationPayload>;
  companyLocationTaxSettingsUpdate?: Maybe<CompanyLocationTaxSettingsUpdatePayload>;
  companyLocationUpdate?: Maybe<CompanyLocationUpdatePayload>;
  companyLocationsDelete?: Maybe<CompanyLocationsDeletePayload>;
  companyRevokeMainContact?: Maybe<CompanyRevokeMainContactPayload>;
  companyUpdate?: Maybe<CompanyUpdatePayload>;
  customerAddTaxExemptions?: Maybe<CustomerAddTaxExemptionsPayload>;
  customerCancelDataErasure?: Maybe<CustomerCancelDataErasurePayload>;
  customerCreate?: Maybe<CustomerCreatePayload>;
  customerDelete?: Maybe<CustomerDeletePayload>;
  customerEmailMarketingConsentUpdate?: Maybe<CustomerEmailMarketingConsentUpdatePayload>;
  customerGenerateAccountActivationUrl?: Maybe<CustomerGenerateAccountActivationUrlPayload>;
  customerMerge?: Maybe<CustomerMergePayload>;
  customerPaymentMethodCreateFromDuplicationData?: Maybe<CustomerPaymentMethodCreateFromDuplicationDataPayload>;
  customerPaymentMethodCreditCardCreate?: Maybe<CustomerPaymentMethodCreditCardCreatePayload>;
  customerPaymentMethodCreditCardUpdate?: Maybe<CustomerPaymentMethodCreditCardUpdatePayload>;
  customerPaymentMethodGetDuplicationData?: Maybe<CustomerPaymentMethodGetDuplicationDataPayload>;
  customerPaymentMethodGetUpdateUrl?: Maybe<CustomerPaymentMethodGetUpdateUrlPayload>;
  customerPaymentMethodPaypalBillingAgreementCreate?: Maybe<CustomerPaymentMethodPaypalBillingAgreementCreatePayload>;
  customerPaymentMethodPaypalBillingAgreementUpdate?: Maybe<CustomerPaymentMethodPaypalBillingAgreementUpdatePayload>;
  customerPaymentMethodRemoteCreate?: Maybe<CustomerPaymentMethodRemoteCreatePayload>;
  customerPaymentMethodRevoke?: Maybe<CustomerPaymentMethodRevokePayload>;
  customerPaymentMethodSendUpdateEmail?: Maybe<CustomerPaymentMethodSendUpdateEmailPayload>;
  customerRemoveTaxExemptions?: Maybe<CustomerRemoveTaxExemptionsPayload>;
  customerReplaceTaxExemptions?: Maybe<CustomerReplaceTaxExemptionsPayload>;
  customerRequestDataErasure?: Maybe<CustomerRequestDataErasurePayload>;
  customerSegmentMembersQueryCreate?: Maybe<CustomerSegmentMembersQueryCreatePayload>;
  customerSendAccountInviteEmail?: Maybe<CustomerSendAccountInviteEmailPayload>;
  customerSmsMarketingConsentUpdate?: Maybe<CustomerSmsMarketingConsentUpdatePayload>;
  customerUpdate?: Maybe<CustomerUpdatePayload>;
  customerUpdateDefaultAddress?: Maybe<CustomerUpdateDefaultAddressPayload>;
  dataSaleOptOut?: Maybe<DataSaleOptOutPayload>;
  delegateAccessTokenCreate?: Maybe<DelegateAccessTokenCreatePayload>;
  delegateAccessTokenDestroy?: Maybe<DelegateAccessTokenDestroyPayload>;
  deliveryCustomizationActivation?: Maybe<DeliveryCustomizationActivationPayload>;
  deliveryCustomizationCreate?: Maybe<DeliveryCustomizationCreatePayload>;
  deliveryCustomizationDelete?: Maybe<DeliveryCustomizationDeletePayload>;
  deliveryCustomizationUpdate?: Maybe<DeliveryCustomizationUpdatePayload>;
  deliveryProfileCreate?: Maybe<DeliveryProfileCreatePayload>;
  deliveryProfileRemove?: Maybe<DeliveryProfileRemovePayload>;
  deliveryProfileUpdate?: Maybe<DeliveryProfileUpdatePayload>;
  deliveryPromiseParticipantsUpdate?: Maybe<DeliveryPromiseParticipantsUpdatePayload>;
  deliveryPromiseProviderUpsert?: Maybe<DeliveryPromiseProviderUpsertPayload>;
  deliverySettingUpdate?: Maybe<DeliverySettingUpdatePayload>;
  deliveryShippingOriginAssign?: Maybe<DeliveryShippingOriginAssignPayload>;
  discountAutomaticActivate?: Maybe<DiscountAutomaticActivatePayload>;
  discountAutomaticAppCreate?: Maybe<DiscountAutomaticAppCreatePayload>;
  discountAutomaticAppUpdate?: Maybe<DiscountAutomaticAppUpdatePayload>;
  discountAutomaticBasicCreate?: Maybe<DiscountAutomaticBasicCreatePayload>;
  discountAutomaticBasicUpdate?: Maybe<DiscountAutomaticBasicUpdatePayload>;
  discountAutomaticBulkDelete?: Maybe<DiscountAutomaticBulkDeletePayload>;
  discountAutomaticBxgyCreate?: Maybe<DiscountAutomaticBxgyCreatePayload>;
  discountAutomaticBxgyUpdate?: Maybe<DiscountAutomaticBxgyUpdatePayload>;
  discountAutomaticDeactivate?: Maybe<DiscountAutomaticDeactivatePayload>;
  discountAutomaticDelete?: Maybe<DiscountAutomaticDeletePayload>;
  discountAutomaticFreeShippingCreate?: Maybe<DiscountAutomaticFreeShippingCreatePayload>;
  discountAutomaticFreeShippingUpdate?: Maybe<DiscountAutomaticFreeShippingUpdatePayload>;
  discountCodeActivate?: Maybe<DiscountCodeActivatePayload>;
  discountCodeAppCreate?: Maybe<DiscountCodeAppCreatePayload>;
  discountCodeAppUpdate?: Maybe<DiscountCodeAppUpdatePayload>;
  discountCodeBasicCreate?: Maybe<DiscountCodeBasicCreatePayload>;
  discountCodeBasicUpdate?: Maybe<DiscountCodeBasicUpdatePayload>;
  discountCodeBulkActivate?: Maybe<DiscountCodeBulkActivatePayload>;
  discountCodeBulkDeactivate?: Maybe<DiscountCodeBulkDeactivatePayload>;
  discountCodeBulkDelete?: Maybe<DiscountCodeBulkDeletePayload>;
  discountCodeBxgyCreate?: Maybe<DiscountCodeBxgyCreatePayload>;
  discountCodeBxgyUpdate?: Maybe<DiscountCodeBxgyUpdatePayload>;
  discountCodeDeactivate?: Maybe<DiscountCodeDeactivatePayload>;
  discountCodeDelete?: Maybe<DiscountCodeDeletePayload>;
  discountCodeFreeShippingCreate?: Maybe<DiscountCodeFreeShippingCreatePayload>;
  discountCodeFreeShippingUpdate?: Maybe<DiscountCodeFreeShippingUpdatePayload>;
  discountCodeRedeemCodeBulkDelete?: Maybe<DiscountCodeRedeemCodeBulkDeletePayload>;
  discountRedeemCodeBulkAdd?: Maybe<DiscountRedeemCodeBulkAddPayload>;
  disputeEvidenceUpdate?: Maybe<DisputeEvidenceUpdatePayload>;
  draftOrderBulkAddTags?: Maybe<DraftOrderBulkAddTagsPayload>;
  draftOrderBulkDelete?: Maybe<DraftOrderBulkDeletePayload>;
  draftOrderBulkRemoveTags?: Maybe<DraftOrderBulkRemoveTagsPayload>;
  draftOrderCalculate?: Maybe<DraftOrderCalculatePayload>;
  draftOrderComplete?: Maybe<DraftOrderCompletePayload>;
  draftOrderCreate?: Maybe<DraftOrderCreatePayload>;
  draftOrderCreateFromOrder?: Maybe<DraftOrderCreateFromOrderPayload>;
  draftOrderCreateMerchantCheckout?: Maybe<DraftOrderCreateMerchantCheckoutPayload>;
  draftOrderDelete?: Maybe<DraftOrderDeletePayload>;
  draftOrderDuplicate?: Maybe<DraftOrderDuplicatePayload>;
  draftOrderInvoicePreview?: Maybe<DraftOrderInvoicePreviewPayload>;
  draftOrderInvoiceSend?: Maybe<DraftOrderInvoiceSendPayload>;
  draftOrderUpdate?: Maybe<DraftOrderUpdatePayload>;
  eventBridgeServerPixelUpdate?: Maybe<EventBridgeServerPixelUpdatePayload>;
  eventBridgeWebhookSubscriptionCreate?: Maybe<EventBridgeWebhookSubscriptionCreatePayload>;
  eventBridgeWebhookSubscriptionUpdate?: Maybe<EventBridgeWebhookSubscriptionUpdatePayload>;
  fileAcknowledgeUpdateFailed?: Maybe<FileAcknowledgeUpdateFailedPayload>;
  fileCreate?: Maybe<FileCreatePayload>;
  fileDelete?: Maybe<FileDeletePayload>;
  fileUpdate?: Maybe<FileUpdatePayload>;
  flowGenerateSignature?: Maybe<FlowGenerateSignaturePayload>;
  flowTriggerReceive?: Maybe<FlowTriggerReceivePayload>;
  fulfillmentCancel?: Maybe<FulfillmentCancelPayload>;
  fulfillmentConstraintRuleCreate?: Maybe<FulfillmentConstraintRuleCreatePayload>;
  fulfillmentConstraintRuleDelete?: Maybe<FulfillmentConstraintRuleDeletePayload>;
  fulfillmentConstraintRuleUpdate?: Maybe<FulfillmentConstraintRuleUpdatePayload>;
  fulfillmentCreate?: Maybe<FulfillmentCreatePayload>;
  /** @deprecated Use `fulfillmentCreate` instead. */
  fulfillmentCreateV2?: Maybe<FulfillmentCreateV2Payload>;
  fulfillmentEventCreate?: Maybe<FulfillmentEventCreatePayload>;
  fulfillmentOrderAcceptCancellationRequest?: Maybe<FulfillmentOrderAcceptCancellationRequestPayload>;
  fulfillmentOrderAcceptFulfillmentRequest?: Maybe<FulfillmentOrderAcceptFulfillmentRequestPayload>;
  fulfillmentOrderCancel?: Maybe<FulfillmentOrderCancelPayload>;
  fulfillmentOrderClose?: Maybe<FulfillmentOrderClosePayload>;
  fulfillmentOrderHold?: Maybe<FulfillmentOrderHoldPayload>;
  fulfillmentOrderLineItemsPreparedForPickup?: Maybe<FulfillmentOrderLineItemsPreparedForPickupPayload>;
  fulfillmentOrderMerge?: Maybe<FulfillmentOrderMergePayload>;
  fulfillmentOrderMove?: Maybe<FulfillmentOrderMovePayload>;
  fulfillmentOrderOpen?: Maybe<FulfillmentOrderOpenPayload>;
  fulfillmentOrderRejectCancellationRequest?: Maybe<FulfillmentOrderRejectCancellationRequestPayload>;
  fulfillmentOrderRejectFulfillmentRequest?: Maybe<FulfillmentOrderRejectFulfillmentRequestPayload>;
  fulfillmentOrderReleaseHold?: Maybe<FulfillmentOrderReleaseHoldPayload>;
  fulfillmentOrderReschedule?: Maybe<FulfillmentOrderReschedulePayload>;
  fulfillmentOrderSplit?: Maybe<FulfillmentOrderSplitPayload>;
  fulfillmentOrderSubmitCancellationRequest?: Maybe<FulfillmentOrderSubmitCancellationRequestPayload>;
  fulfillmentOrderSubmitFulfillmentRequest?: Maybe<FulfillmentOrderSubmitFulfillmentRequestPayload>;
  fulfillmentOrdersSetFulfillmentDeadline?: Maybe<FulfillmentOrdersSetFulfillmentDeadlinePayload>;
  fulfillmentServiceCreate?: Maybe<FulfillmentServiceCreatePayload>;
  fulfillmentServiceDelete?: Maybe<FulfillmentServiceDeletePayload>;
  fulfillmentServiceUpdate?: Maybe<FulfillmentServiceUpdatePayload>;
  fulfillmentTrackingInfoUpdate?: Maybe<FulfillmentTrackingInfoUpdatePayload>;
  /** @deprecated Use `fulfillmentTrackingInfoUpdate` instead. */
  fulfillmentTrackingInfoUpdateV2?: Maybe<FulfillmentTrackingInfoUpdateV2Payload>;
  giftCardCreate?: Maybe<GiftCardCreatePayload>;
  giftCardCredit?: Maybe<GiftCardCreditPayload>;
  giftCardDeactivate?: Maybe<GiftCardDeactivatePayload>;
  giftCardDebit?: Maybe<GiftCardDebitPayload>;
  giftCardSendNotificationToCustomer?: Maybe<GiftCardSendNotificationToCustomerPayload>;
  giftCardSendNotificationToRecipient?: Maybe<GiftCardSendNotificationToRecipientPayload>;
  giftCardUpdate?: Maybe<GiftCardUpdatePayload>;
  inventoryActivate?: Maybe<InventoryActivatePayload>;
  inventoryAdjustQuantities?: Maybe<InventoryAdjustQuantitiesPayload>;
  inventoryBulkToggleActivation?: Maybe<InventoryBulkToggleActivationPayload>;
  inventoryDeactivate?: Maybe<InventoryDeactivatePayload>;
  inventoryItemUpdate?: Maybe<InventoryItemUpdatePayload>;
  inventoryMoveQuantities?: Maybe<InventoryMoveQuantitiesPayload>;
  /** @deprecated Use `inventorySetQuantities` to set on_hand or available quantites instead. */
  inventorySetOnHandQuantities?: Maybe<InventorySetOnHandQuantitiesPayload>;
  inventorySetQuantities?: Maybe<InventorySetQuantitiesPayload>;
  inventorySetScheduledChanges?: Maybe<InventorySetScheduledChangesPayload>;
  locationActivate?: Maybe<LocationActivatePayload>;
  locationAdd?: Maybe<LocationAddPayload>;
  locationDeactivate?: Maybe<LocationDeactivatePayload>;
  locationDelete?: Maybe<LocationDeletePayload>;
  locationEdit?: Maybe<LocationEditPayload>;
  locationLocalPickupDisable?: Maybe<LocationLocalPickupDisablePayload>;
  locationLocalPickupEnable?: Maybe<LocationLocalPickupEnablePayload>;
  marketCreate?: Maybe<MarketCreatePayload>;
  marketCurrencySettingsUpdate?: Maybe<MarketCurrencySettingsUpdatePayload>;
  marketDelete?: Maybe<MarketDeletePayload>;
  marketLocalizationsRegister?: Maybe<MarketLocalizationsRegisterPayload>;
  marketLocalizationsRemove?: Maybe<MarketLocalizationsRemovePayload>;
  /** @deprecated Use `marketUpdate` instead. */
  marketRegionDelete?: Maybe<MarketRegionDeletePayload>;
  /** @deprecated This mutation is deprecated and will be removed in the future. Use `marketCreate` or `marketUpdate` instead. */
  marketRegionsCreate?: Maybe<MarketRegionsCreatePayload>;
  /** @deprecated Use `marketUpdate` instead. */
  marketRegionsDelete?: Maybe<MarketRegionsDeletePayload>;
  marketUpdate?: Maybe<MarketUpdatePayload>;
  /** @deprecated Use `webPresenceCreate` instead. */
  marketWebPresenceCreate?: Maybe<MarketWebPresenceCreatePayload>;
  /** @deprecated Use `webPresenceDelete` instead. */
  marketWebPresenceDelete?: Maybe<MarketWebPresenceDeletePayload>;
  /** @deprecated Use `webPresenceUpdate` instead. */
  marketWebPresenceUpdate?: Maybe<MarketWebPresenceUpdatePayload>;
  marketingActivitiesDeleteAllExternal?: Maybe<MarketingActivitiesDeleteAllExternalPayload>;
  marketingActivityCreate?: Maybe<MarketingActivityCreatePayload>;
  marketingActivityCreateExternal?: Maybe<MarketingActivityCreateExternalPayload>;
  marketingActivityDeleteExternal?: Maybe<MarketingActivityDeleteExternalPayload>;
  marketingActivityUpdate?: Maybe<MarketingActivityUpdatePayload>;
  marketingActivityUpdateExternal?: Maybe<MarketingActivityUpdateExternalPayload>;
  marketingActivityUpsertExternal?: Maybe<MarketingActivityUpsertExternalPayload>;
  marketingEngagementCreate?: Maybe<MarketingEngagementCreatePayload>;
  marketingEngagementsDelete?: Maybe<MarketingEngagementsDeletePayload>;
  menuCreate?: Maybe<MenuCreatePayload>;
  menuDelete?: Maybe<MenuDeletePayload>;
  menuUpdate?: Maybe<MenuUpdatePayload>;
  metafieldDefinitionCreate?: Maybe<MetafieldDefinitionCreatePayload>;
  metafieldDefinitionDelete?: Maybe<MetafieldDefinitionDeletePayload>;
  metafieldDefinitionPin?: Maybe<MetafieldDefinitionPinPayload>;
  metafieldDefinitionUnpin?: Maybe<MetafieldDefinitionUnpinPayload>;
  metafieldDefinitionUpdate?: Maybe<MetafieldDefinitionUpdatePayload>;
  metafieldsDelete?: Maybe<MetafieldsDeletePayload>;
  metafieldsSet?: Maybe<MetafieldsSetPayload>;
  metaobjectBulkDelete?: Maybe<MetaobjectBulkDeletePayload>;
  metaobjectCreate?: Maybe<MetaobjectCreatePayload>;
  metaobjectDefinitionCreate?: Maybe<MetaobjectDefinitionCreatePayload>;
  metaobjectDefinitionDelete?: Maybe<MetaobjectDefinitionDeletePayload>;
  metaobjectDefinitionUpdate?: Maybe<MetaobjectDefinitionUpdatePayload>;
  metaobjectDelete?: Maybe<MetaobjectDeletePayload>;
  metaobjectUpdate?: Maybe<MetaobjectUpdatePayload>;
  metaobjectUpsert?: Maybe<MetaobjectUpsertPayload>;
  mobilePlatformApplicationCreate?: Maybe<MobilePlatformApplicationCreatePayload>;
  mobilePlatformApplicationDelete?: Maybe<MobilePlatformApplicationDeletePayload>;
  mobilePlatformApplicationUpdate?: Maybe<MobilePlatformApplicationUpdatePayload>;
  orderCancel?: Maybe<OrderCancelPayload>;
  orderCapture?: Maybe<OrderCapturePayload>;
  orderClose?: Maybe<OrderClosePayload>;
  orderCreate?: Maybe<OrderCreatePayload>;
  orderCreateMandatePayment?: Maybe<OrderCreateMandatePaymentPayload>;
  orderDelete?: Maybe<OrderDeletePayload>;
  orderEditAddCustomItem?: Maybe<OrderEditAddCustomItemPayload>;
  orderEditAddLineItemDiscount?: Maybe<OrderEditAddLineItemDiscountPayload>;
  orderEditAddShippingLine?: Maybe<OrderEditAddShippingLinePayload>;
  orderEditAddVariant?: Maybe<OrderEditAddVariantPayload>;
  orderEditBegin?: Maybe<OrderEditBeginPayload>;
  orderEditCommit?: Maybe<OrderEditCommitPayload>;
  orderEditRemoveDiscount?: Maybe<OrderEditRemoveDiscountPayload>;
  /** @deprecated Use `orderEditRemoveDiscount` instead. */
  orderEditRemoveLineItemDiscount?: Maybe<OrderEditRemoveLineItemDiscountPayload>;
  orderEditRemoveShippingLine?: Maybe<OrderEditRemoveShippingLinePayload>;
  orderEditSetQuantity?: Maybe<OrderEditSetQuantityPayload>;
  orderEditUpdateDiscount?: Maybe<OrderEditUpdateDiscountPayload>;
  orderEditUpdateShippingLine?: Maybe<OrderEditUpdateShippingLinePayload>;
  orderInvoiceSend?: Maybe<OrderInvoiceSendPayload>;
  orderMarkAsPaid?: Maybe<OrderMarkAsPaidPayload>;
  orderOpen?: Maybe<OrderOpenPayload>;
  orderRiskAssessmentCreate?: Maybe<OrderRiskAssessmentCreatePayload>;
  orderUpdate?: Maybe<OrderUpdatePayload>;
  pageCreate?: Maybe<PageCreatePayload>;
  pageDelete?: Maybe<PageDeletePayload>;
  pageUpdate?: Maybe<PageUpdatePayload>;
  paymentCustomizationActivation?: Maybe<PaymentCustomizationActivationPayload>;
  paymentCustomizationCreate?: Maybe<PaymentCustomizationCreatePayload>;
  paymentCustomizationDelete?: Maybe<PaymentCustomizationDeletePayload>;
  paymentCustomizationUpdate?: Maybe<PaymentCustomizationUpdatePayload>;
  paymentReminderSend?: Maybe<PaymentReminderSendPayload>;
  paymentTermsCreate?: Maybe<PaymentTermsCreatePayload>;
  paymentTermsDelete?: Maybe<PaymentTermsDeletePayload>;
  paymentTermsUpdate?: Maybe<PaymentTermsUpdatePayload>;
  priceListCreate?: Maybe<PriceListCreatePayload>;
  priceListDelete?: Maybe<PriceListDeletePayload>;
  priceListFixedPricesAdd?: Maybe<PriceListFixedPricesAddPayload>;
  priceListFixedPricesByProductUpdate?: Maybe<PriceListFixedPricesByProductUpdatePayload>;
  priceListFixedPricesDelete?: Maybe<PriceListFixedPricesDeletePayload>;
  priceListFixedPricesUpdate?: Maybe<PriceListFixedPricesUpdatePayload>;
  priceListUpdate?: Maybe<PriceListUpdatePayload>;
  productBundleCreate?: Maybe<ProductBundleCreatePayload>;
  productBundleUpdate?: Maybe<ProductBundleUpdatePayload>;
  /** @deprecated Use `productUpdate` instead. */
  productChangeStatus?: Maybe<ProductChangeStatusPayload>;
  productCreate?: Maybe<ProductCreatePayload>;
  /** @deprecated Use `productUpdate` or `productSet` instead. */
  productCreateMedia?: Maybe<ProductCreateMediaPayload>;
  productDelete?: Maybe<ProductDeletePayload>;
  /** @deprecated Use `fileUpdate` instead. */
  productDeleteMedia?: Maybe<ProductDeleteMediaPayload>;
  productDuplicate?: Maybe<ProductDuplicatePayload>;
  productFeedCreate?: Maybe<ProductFeedCreatePayload>;
  productFeedDelete?: Maybe<ProductFeedDeletePayload>;
  productFullSync?: Maybe<ProductFullSyncPayload>;
  productJoinSellingPlanGroups?: Maybe<ProductJoinSellingPlanGroupsPayload>;
  productLeaveSellingPlanGroups?: Maybe<ProductLeaveSellingPlanGroupsPayload>;
  productOptionUpdate?: Maybe<ProductOptionUpdatePayload>;
  productOptionsCreate?: Maybe<ProductOptionsCreatePayload>;
  productOptionsDelete?: Maybe<ProductOptionsDeletePayload>;
  productOptionsReorder?: Maybe<ProductOptionsReorderPayload>;
  /** @deprecated Use `publishablePublish` instead. */
  productPublish?: Maybe<ProductPublishPayload>;
  productReorderMedia?: Maybe<ProductReorderMediaPayload>;
  productSet?: Maybe<ProductSetPayload>;
  /** @deprecated Use `publishableUnpublish` instead. */
  productUnpublish?: Maybe<ProductUnpublishPayload>;
  productUpdate?: Maybe<ProductUpdatePayload>;
  /** @deprecated Use `fileUpdate` instead. */
  productUpdateMedia?: Maybe<ProductUpdateMediaPayload>;
  productVariantAppendMedia?: Maybe<ProductVariantAppendMediaPayload>;
  productVariantDetachMedia?: Maybe<ProductVariantDetachMediaPayload>;
  productVariantJoinSellingPlanGroups?: Maybe<ProductVariantJoinSellingPlanGroupsPayload>;
  productVariantLeaveSellingPlanGroups?: Maybe<ProductVariantLeaveSellingPlanGroupsPayload>;
  productVariantRelationshipBulkUpdate?: Maybe<ProductVariantRelationshipBulkUpdatePayload>;
  productVariantsBulkCreate?: Maybe<ProductVariantsBulkCreatePayload>;
  productVariantsBulkDelete?: Maybe<ProductVariantsBulkDeletePayload>;
  productVariantsBulkReorder?: Maybe<ProductVariantsBulkReorderPayload>;
  productVariantsBulkUpdate?: Maybe<ProductVariantsBulkUpdatePayload>;
  pubSubServerPixelUpdate?: Maybe<PubSubServerPixelUpdatePayload>;
  pubSubWebhookSubscriptionCreate?: Maybe<PubSubWebhookSubscriptionCreatePayload>;
  pubSubWebhookSubscriptionUpdate?: Maybe<PubSubWebhookSubscriptionUpdatePayload>;
  publicationCreate?: Maybe<PublicationCreatePayload>;
  publicationDelete?: Maybe<PublicationDeletePayload>;
  publicationUpdate?: Maybe<PublicationUpdatePayload>;
  publishablePublish?: Maybe<PublishablePublishPayload>;
  publishablePublishToCurrentChannel?: Maybe<PublishablePublishToCurrentChannelPayload>;
  publishableUnpublish?: Maybe<PublishableUnpublishPayload>;
  publishableUnpublishToCurrentChannel?: Maybe<PublishableUnpublishToCurrentChannelPayload>;
  quantityPricingByVariantUpdate?: Maybe<QuantityPricingByVariantUpdatePayload>;
  quantityRulesAdd?: Maybe<QuantityRulesAddPayload>;
  quantityRulesDelete?: Maybe<QuantityRulesDeletePayload>;
  refundCreate?: Maybe<RefundCreatePayload>;
  returnApproveRequest?: Maybe<ReturnApproveRequestPayload>;
  returnCancel?: Maybe<ReturnCancelPayload>;
  returnClose?: Maybe<ReturnClosePayload>;
  returnCreate?: Maybe<ReturnCreatePayload>;
  returnDeclineRequest?: Maybe<ReturnDeclineRequestPayload>;
  returnLineItemRemoveFromReturn?: Maybe<ReturnLineItemRemoveFromReturnPayload>;
  returnRefund?: Maybe<ReturnRefundPayload>;
  returnReopen?: Maybe<ReturnReopenPayload>;
  returnRequest?: Maybe<ReturnRequestPayload>;
  reverseDeliveryCreateWithShipping?: Maybe<ReverseDeliveryCreateWithShippingPayload>;
  reverseDeliveryShippingUpdate?: Maybe<ReverseDeliveryShippingUpdatePayload>;
  reverseFulfillmentOrderDispose?: Maybe<ReverseFulfillmentOrderDisposePayload>;
  savedSearchCreate?: Maybe<SavedSearchCreatePayload>;
  savedSearchDelete?: Maybe<SavedSearchDeletePayload>;
  savedSearchUpdate?: Maybe<SavedSearchUpdatePayload>;
  scriptTagCreate?: Maybe<ScriptTagCreatePayload>;
  scriptTagDelete?: Maybe<ScriptTagDeletePayload>;
  scriptTagUpdate?: Maybe<ScriptTagUpdatePayload>;
  segmentCreate?: Maybe<SegmentCreatePayload>;
  segmentDelete?: Maybe<SegmentDeletePayload>;
  segmentUpdate?: Maybe<SegmentUpdatePayload>;
  sellingPlanGroupAddProductVariants?: Maybe<SellingPlanGroupAddProductVariantsPayload>;
  sellingPlanGroupAddProducts?: Maybe<SellingPlanGroupAddProductsPayload>;
  sellingPlanGroupCreate?: Maybe<SellingPlanGroupCreatePayload>;
  sellingPlanGroupDelete?: Maybe<SellingPlanGroupDeletePayload>;
  sellingPlanGroupRemoveProductVariants?: Maybe<SellingPlanGroupRemoveProductVariantsPayload>;
  sellingPlanGroupRemoveProducts?: Maybe<SellingPlanGroupRemoveProductsPayload>;
  sellingPlanGroupUpdate?: Maybe<SellingPlanGroupUpdatePayload>;
  serverPixelCreate?: Maybe<ServerPixelCreatePayload>;
  serverPixelDelete?: Maybe<ServerPixelDeletePayload>;
  shippingPackageDelete?: Maybe<ShippingPackageDeletePayload>;
  shippingPackageMakeDefault?: Maybe<ShippingPackageMakeDefaultPayload>;
  shippingPackageUpdate?: Maybe<ShippingPackageUpdatePayload>;
  shopLocaleDisable?: Maybe<ShopLocaleDisablePayload>;
  shopLocaleEnable?: Maybe<ShopLocaleEnablePayload>;
  shopLocaleUpdate?: Maybe<ShopLocaleUpdatePayload>;
  shopPolicyUpdate?: Maybe<ShopPolicyUpdatePayload>;
  shopResourceFeedbackCreate?: Maybe<ShopResourceFeedbackCreatePayload>;
  shopifyPaymentsPayoutAlternateCurrencyCreate?: Maybe<ShopifyPaymentsPayoutAlternateCurrencyCreatePayload>;
  /** @deprecated Use `stagedUploadsCreate` instead. */
  stagedUploadTargetGenerate?: Maybe<StagedUploadTargetGeneratePayload>;
  /** @deprecated Use `stagedUploadsCreate` instead. */
  stagedUploadTargetsGenerate?: Maybe<StagedUploadTargetsGeneratePayload>;
  stagedUploadsCreate?: Maybe<StagedUploadsCreatePayload>;
  standardMetafieldDefinitionEnable?: Maybe<StandardMetafieldDefinitionEnablePayload>;
  standardMetaobjectDefinitionEnable?: Maybe<StandardMetaobjectDefinitionEnablePayload>;
  storeCreditAccountCredit?: Maybe<StoreCreditAccountCreditPayload>;
  storeCreditAccountDebit?: Maybe<StoreCreditAccountDebitPayload>;
  storefrontAccessTokenCreate?: Maybe<StorefrontAccessTokenCreatePayload>;
  storefrontAccessTokenDelete?: Maybe<StorefrontAccessTokenDeletePayload>;
  subscriptionBillingAttemptCreate?: Maybe<SubscriptionBillingAttemptCreatePayload>;
  subscriptionBillingCycleBulkCharge?: Maybe<SubscriptionBillingCycleBulkChargePayload>;
  subscriptionBillingCycleBulkSearch?: Maybe<SubscriptionBillingCycleBulkSearchPayload>;
  subscriptionBillingCycleCharge?: Maybe<SubscriptionBillingCycleChargePayload>;
  subscriptionBillingCycleContractDraftCommit?: Maybe<SubscriptionBillingCycleContractDraftCommitPayload>;
  subscriptionBillingCycleContractDraftConcatenate?: Maybe<SubscriptionBillingCycleContractDraftConcatenatePayload>;
  subscriptionBillingCycleContractEdit?: Maybe<SubscriptionBillingCycleContractEditPayload>;
  subscriptionBillingCycleEditDelete?: Maybe<SubscriptionBillingCycleEditDeletePayload>;
  subscriptionBillingCycleEditsDelete?: Maybe<SubscriptionBillingCycleEditsDeletePayload>;
  subscriptionBillingCycleScheduleEdit?: Maybe<SubscriptionBillingCycleScheduleEditPayload>;
  subscriptionBillingCycleSkip?: Maybe<SubscriptionBillingCycleSkipPayload>;
  subscriptionBillingCycleUnskip?: Maybe<SubscriptionBillingCycleUnskipPayload>;
  subscriptionContractActivate?: Maybe<SubscriptionContractActivatePayload>;
  subscriptionContractAtomicCreate?: Maybe<SubscriptionContractAtomicCreatePayload>;
  subscriptionContractCancel?: Maybe<SubscriptionContractCancelPayload>;
  subscriptionContractCreate?: Maybe<SubscriptionContractCreatePayload>;
  subscriptionContractExpire?: Maybe<SubscriptionContractExpirePayload>;
  subscriptionContractFail?: Maybe<SubscriptionContractFailPayload>;
  subscriptionContractPause?: Maybe<SubscriptionContractPausePayload>;
  subscriptionContractProductChange?: Maybe<SubscriptionContractProductChangePayload>;
  subscriptionContractSetNextBillingDate?: Maybe<SubscriptionContractSetNextBillingDatePayload>;
  subscriptionContractUpdate?: Maybe<SubscriptionContractUpdatePayload>;
  subscriptionDraftCommit?: Maybe<SubscriptionDraftCommitPayload>;
  subscriptionDraftDiscountAdd?: Maybe<SubscriptionDraftDiscountAddPayload>;
  subscriptionDraftDiscountCodeApply?: Maybe<SubscriptionDraftDiscountCodeApplyPayload>;
  subscriptionDraftDiscountRemove?: Maybe<SubscriptionDraftDiscountRemovePayload>;
  subscriptionDraftDiscountUpdate?: Maybe<SubscriptionDraftDiscountUpdatePayload>;
  subscriptionDraftFreeShippingDiscountAdd?: Maybe<SubscriptionDraftFreeShippingDiscountAddPayload>;
  subscriptionDraftFreeShippingDiscountUpdate?: Maybe<SubscriptionDraftFreeShippingDiscountUpdatePayload>;
  subscriptionDraftLineAdd?: Maybe<SubscriptionDraftLineAddPayload>;
  subscriptionDraftLineRemove?: Maybe<SubscriptionDraftLineRemovePayload>;
  subscriptionDraftLineUpdate?: Maybe<SubscriptionDraftLineUpdatePayload>;
  subscriptionDraftUpdate?: Maybe<SubscriptionDraftUpdatePayload>;
  tagsAdd?: Maybe<TagsAddPayload>;
  tagsRemove?: Maybe<TagsRemovePayload>;
  taxAppConfigure?: Maybe<TaxAppConfigurePayload>;
  themeCreate?: Maybe<ThemeCreatePayload>;
  themeDelete?: Maybe<ThemeDeletePayload>;
  themeFilesCopy?: Maybe<ThemeFilesCopyPayload>;
  themeFilesDelete?: Maybe<ThemeFilesDeletePayload>;
  themeFilesUpsert?: Maybe<ThemeFilesUpsertPayload>;
  themePublish?: Maybe<ThemePublishPayload>;
  themeUpdate?: Maybe<ThemeUpdatePayload>;
  transactionVoid?: Maybe<TransactionVoidPayload>;
  translationsRegister?: Maybe<TranslationsRegisterPayload>;
  translationsRemove?: Maybe<TranslationsRemovePayload>;
  urlRedirectBulkDeleteAll?: Maybe<UrlRedirectBulkDeleteAllPayload>;
  urlRedirectBulkDeleteByIds?: Maybe<UrlRedirectBulkDeleteByIdsPayload>;
  urlRedirectBulkDeleteBySavedSearch?: Maybe<UrlRedirectBulkDeleteBySavedSearchPayload>;
  urlRedirectBulkDeleteBySearch?: Maybe<UrlRedirectBulkDeleteBySearchPayload>;
  urlRedirectCreate?: Maybe<UrlRedirectCreatePayload>;
  urlRedirectDelete?: Maybe<UrlRedirectDeletePayload>;
  urlRedirectImportCreate?: Maybe<UrlRedirectImportCreatePayload>;
  urlRedirectImportSubmit?: Maybe<UrlRedirectImportSubmitPayload>;
  urlRedirectUpdate?: Maybe<UrlRedirectUpdatePayload>;
  validationCreate?: Maybe<ValidationCreatePayload>;
  validationDelete?: Maybe<ValidationDeletePayload>;
  validationUpdate?: Maybe<ValidationUpdatePayload>;
  webPixelCreate?: Maybe<WebPixelCreatePayload>;
  webPixelDelete?: Maybe<WebPixelDeletePayload>;
  webPixelUpdate?: Maybe<WebPixelUpdatePayload>;
  webhookSubscriptionCreate?: Maybe<WebhookSubscriptionCreatePayload>;
  webhookSubscriptionDelete?: Maybe<WebhookSubscriptionDeletePayload>;
  webhookSubscriptionUpdate?: Maybe<WebhookSubscriptionUpdatePayload>;
};


export type MutationAbandonmentEmailStateUpdateArgs = {
  emailSentAt?: InputMaybe<Scalars['DateTime']['input']>;
  emailState: AbandonmentEmailState;
  emailStateChangeReason?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};


export type MutationAbandonmentUpdateActivitiesDeliveryStatusesArgs = {
  abandonmentId: Scalars['ID']['input'];
  deliveredAt?: InputMaybe<Scalars['DateTime']['input']>;
  deliveryStatus: AbandonmentDeliveryState;
  deliveryStatusChangeReason?: InputMaybe<Scalars['String']['input']>;
  marketingActivityId: Scalars['ID']['input'];
};


export type MutationAppPurchaseOneTimeCreateArgs = {
  name: Scalars['String']['input'];
  price: MoneyInput;
  returnUrl: Scalars['URL']['input'];
  test?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationAppRevokeAccessScopesArgs = {
  scopes: Array<Scalars['String']['input']>;
};


export type MutationAppSubscriptionCancelArgs = {
  id: Scalars['ID']['input'];
  prorate?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationAppSubscriptionCreateArgs = {
  lineItems: Array<AppSubscriptionLineItemInput>;
  name: Scalars['String']['input'];
  replacementBehavior?: InputMaybe<AppSubscriptionReplacementBehavior>;
  returnUrl: Scalars['URL']['input'];
  test?: InputMaybe<Scalars['Boolean']['input']>;
  trialDays?: InputMaybe<Scalars['Int']['input']>;
};


export type MutationAppSubscriptionLineItemUpdateArgs = {
  cappedAmount: MoneyInput;
  id: Scalars['ID']['input'];
};


export type MutationAppSubscriptionTrialExtendArgs = {
  days: Scalars['Int']['input'];
  id: Scalars['ID']['input'];
};


export type MutationAppUsageRecordCreateArgs = {
  description: Scalars['String']['input'];
  idempotencyKey?: InputMaybe<Scalars['String']['input']>;
  price: MoneyInput;
  subscriptionLineItemId: Scalars['ID']['input'];
};


export type MutationArticleCreateArgs = {
  article: ArticleCreateInput;
  blog?: InputMaybe<ArticleBlogInput>;
};


export type MutationArticleDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationArticleUpdateArgs = {
  article: ArticleUpdateInput;
  blog?: InputMaybe<ArticleBlogInput>;
  id: Scalars['ID']['input'];
};


export type MutationBlogCreateArgs = {
  blog: BlogCreateInput;
};


export type MutationBlogDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationBlogUpdateArgs = {
  blog: BlogUpdateInput;
  id: Scalars['ID']['input'];
};


export type MutationBulkOperationCancelArgs = {
  id: Scalars['ID']['input'];
};


export type MutationBulkOperationRunMutationArgs = {
  clientIdentifier?: InputMaybe<Scalars['String']['input']>;
  mutation: Scalars['String']['input'];
  stagedUploadPath: Scalars['String']['input'];
};


export type MutationBulkOperationRunQueryArgs = {
  query: Scalars['String']['input'];
};


export type MutationBulkProductResourceFeedbackCreateArgs = {
  feedbackInput: Array<ProductResourceFeedbackInput>;
};


export type MutationCarrierServiceCreateArgs = {
  input: DeliveryCarrierServiceCreateInput;
};


export type MutationCarrierServiceDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationCarrierServiceUpdateArgs = {
  input: DeliveryCarrierServiceUpdateInput;
};


export type MutationCartTransformCreateArgs = {
  blockOnFailure?: InputMaybe<Scalars['Boolean']['input']>;
  functionId: Scalars['String']['input'];
  metafields?: InputMaybe<Array<MetafieldInput>>;
};


export type MutationCartTransformDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationCatalogContextUpdateArgs = {
  catalogId: Scalars['ID']['input'];
  contextsToAdd?: InputMaybe<CatalogContextInput>;
  contextsToRemove?: InputMaybe<CatalogContextInput>;
};


export type MutationCatalogCreateArgs = {
  input: CatalogCreateInput;
};


export type MutationCatalogDeleteArgs = {
  deleteDependentResources?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
};


export type MutationCatalogUpdateArgs = {
  id: Scalars['ID']['input'];
  input: CatalogUpdateInput;
};


export type MutationCheckoutBrandingUpsertArgs = {
  checkoutBrandingInput?: InputMaybe<CheckoutBrandingInput>;
  checkoutProfileId: Scalars['ID']['input'];
};


export type MutationCollectionAddProductsArgs = {
  id: Scalars['ID']['input'];
  productIds: Array<Scalars['ID']['input']>;
};


export type MutationCollectionAddProductsV2Args = {
  id: Scalars['ID']['input'];
  productIds: Array<Scalars['ID']['input']>;
};


export type MutationCollectionCreateArgs = {
  input: CollectionInput;
};


export type MutationCollectionDeleteArgs = {
  input: CollectionDeleteInput;
};


export type MutationCollectionPublishArgs = {
  input: CollectionPublishInput;
};


export type MutationCollectionRemoveProductsArgs = {
  id: Scalars['ID']['input'];
  productIds: Array<Scalars['ID']['input']>;
};


export type MutationCollectionReorderProductsArgs = {
  id: Scalars['ID']['input'];
  moves: Array<MoveInput>;
};


export type MutationCollectionUnpublishArgs = {
  input: CollectionUnpublishInput;
};


export type MutationCollectionUpdateArgs = {
  input: CollectionInput;
};


export type MutationCombinedListingUpdateArgs = {
  optionsAndValues?: InputMaybe<Array<OptionAndValueInput>>;
  parentProductId: Scalars['ID']['input'];
  productsAdded?: InputMaybe<Array<ChildProductRelationInput>>;
  productsEdited?: InputMaybe<Array<ChildProductRelationInput>>;
  productsRemovedIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  title?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCommentApproveArgs = {
  id: Scalars['ID']['input'];
};


export type MutationCommentDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationCommentNotSpamArgs = {
  id: Scalars['ID']['input'];
};


export type MutationCommentSpamArgs = {
  id: Scalars['ID']['input'];
};


export type MutationCompaniesDeleteArgs = {
  companyIds: Array<Scalars['ID']['input']>;
};


export type MutationCompanyAddressDeleteArgs = {
  addressId: Scalars['ID']['input'];
};


export type MutationCompanyAssignCustomerAsContactArgs = {
  companyId: Scalars['ID']['input'];
  customerId: Scalars['ID']['input'];
};


export type MutationCompanyAssignMainContactArgs = {
  companyContactId: Scalars['ID']['input'];
  companyId: Scalars['ID']['input'];
};


export type MutationCompanyContactAssignRoleArgs = {
  companyContactId: Scalars['ID']['input'];
  companyContactRoleId: Scalars['ID']['input'];
  companyLocationId: Scalars['ID']['input'];
};


export type MutationCompanyContactAssignRolesArgs = {
  companyContactId: Scalars['ID']['input'];
  rolesToAssign: Array<CompanyContactRoleAssign>;
};


export type MutationCompanyContactCreateArgs = {
  companyId: Scalars['ID']['input'];
  input: CompanyContactInput;
};


export type MutationCompanyContactDeleteArgs = {
  companyContactId: Scalars['ID']['input'];
};


export type MutationCompanyContactRemoveFromCompanyArgs = {
  companyContactId: Scalars['ID']['input'];
};


export type MutationCompanyContactRevokeRoleArgs = {
  companyContactId: Scalars['ID']['input'];
  companyContactRoleAssignmentId: Scalars['ID']['input'];
};


export type MutationCompanyContactRevokeRolesArgs = {
  companyContactId: Scalars['ID']['input'];
  revokeAll?: InputMaybe<Scalars['Boolean']['input']>;
  roleAssignmentIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type MutationCompanyContactSendWelcomeEmailArgs = {
  companyContactId: Scalars['ID']['input'];
  email?: InputMaybe<EmailInput>;
};


export type MutationCompanyContactUpdateArgs = {
  companyContactId: Scalars['ID']['input'];
  input: CompanyContactInput;
};


export type MutationCompanyContactsDeleteArgs = {
  companyContactIds: Array<Scalars['ID']['input']>;
};


export type MutationCompanyCreateArgs = {
  input: CompanyCreateInput;
};


export type MutationCompanyDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationCompanyLocationAssignAddressArgs = {
  address: CompanyAddressInput;
  addressTypes: Array<CompanyAddressType>;
  locationId: Scalars['ID']['input'];
};


export type MutationCompanyLocationAssignRolesArgs = {
  companyLocationId: Scalars['ID']['input'];
  rolesToAssign: Array<CompanyLocationRoleAssign>;
};


export type MutationCompanyLocationAssignStaffMembersArgs = {
  companyLocationId: Scalars['ID']['input'];
  staffMemberIds: Array<Scalars['ID']['input']>;
};


export type MutationCompanyLocationAssignTaxExemptionsArgs = {
  companyLocationId: Scalars['ID']['input'];
  taxExemptions: Array<TaxExemption>;
};


export type MutationCompanyLocationCreateArgs = {
  companyId: Scalars['ID']['input'];
  input: CompanyLocationInput;
};


export type MutationCompanyLocationCreateTaxRegistrationArgs = {
  locationId: Scalars['ID']['input'];
  taxId: Scalars['String']['input'];
};


export type MutationCompanyLocationDeleteArgs = {
  companyLocationId: Scalars['ID']['input'];
};


export type MutationCompanyLocationRemoveStaffMembersArgs = {
  companyLocationStaffMemberAssignmentIds: Array<Scalars['ID']['input']>;
};


export type MutationCompanyLocationRevokeRolesArgs = {
  companyLocationId: Scalars['ID']['input'];
  rolesToRevoke: Array<Scalars['ID']['input']>;
};


export type MutationCompanyLocationRevokeTaxExemptionsArgs = {
  companyLocationId: Scalars['ID']['input'];
  taxExemptions: Array<TaxExemption>;
};


export type MutationCompanyLocationRevokeTaxRegistrationArgs = {
  companyLocationId: Scalars['ID']['input'];
};


export type MutationCompanyLocationTaxSettingsUpdateArgs = {
  companyLocationId: Scalars['ID']['input'];
  exemptionsToAssign?: InputMaybe<Array<TaxExemption>>;
  exemptionsToRemove?: InputMaybe<Array<TaxExemption>>;
  taxExempt?: InputMaybe<Scalars['Boolean']['input']>;
  taxRegistrationId?: InputMaybe<Scalars['String']['input']>;
};


export type MutationCompanyLocationUpdateArgs = {
  companyLocationId: Scalars['ID']['input'];
  input: CompanyLocationUpdateInput;
};


export type MutationCompanyLocationsDeleteArgs = {
  companyLocationIds: Array<Scalars['ID']['input']>;
};


export type MutationCompanyRevokeMainContactArgs = {
  companyId: Scalars['ID']['input'];
};


export type MutationCompanyUpdateArgs = {
  companyId: Scalars['ID']['input'];
  input: CompanyInput;
};


export type MutationCustomerAddTaxExemptionsArgs = {
  customerId: Scalars['ID']['input'];
  taxExemptions: Array<TaxExemption>;
};


export type MutationCustomerCancelDataErasureArgs = {
  customerId: Scalars['ID']['input'];
};


export type MutationCustomerCreateArgs = {
  input: CustomerInput;
};


export type MutationCustomerDeleteArgs = {
  input: CustomerDeleteInput;
};


export type MutationCustomerEmailMarketingConsentUpdateArgs = {
  input: CustomerEmailMarketingConsentUpdateInput;
};


export type MutationCustomerGenerateAccountActivationUrlArgs = {
  customerId: Scalars['ID']['input'];
};


export type MutationCustomerMergeArgs = {
  customerOneId: Scalars['ID']['input'];
  customerTwoId: Scalars['ID']['input'];
  overrideFields?: InputMaybe<CustomerMergeOverrideFields>;
};


export type MutationCustomerPaymentMethodCreateFromDuplicationDataArgs = {
  billingAddress: MailingAddressInput;
  customerId: Scalars['ID']['input'];
  encryptedDuplicationData: Scalars['String']['input'];
};


export type MutationCustomerPaymentMethodCreditCardCreateArgs = {
  billingAddress: MailingAddressInput;
  customerId: Scalars['ID']['input'];
  sessionId: Scalars['String']['input'];
};


export type MutationCustomerPaymentMethodCreditCardUpdateArgs = {
  billingAddress: MailingAddressInput;
  id: Scalars['ID']['input'];
  sessionId: Scalars['String']['input'];
};


export type MutationCustomerPaymentMethodGetDuplicationDataArgs = {
  customerPaymentMethodId: Scalars['ID']['input'];
  targetCustomerId: Scalars['ID']['input'];
  targetShopId: Scalars['ID']['input'];
};


export type MutationCustomerPaymentMethodGetUpdateUrlArgs = {
  customerPaymentMethodId: Scalars['ID']['input'];
};


export type MutationCustomerPaymentMethodPaypalBillingAgreementCreateArgs = {
  billingAddress?: InputMaybe<MailingAddressInput>;
  billingAgreementId: Scalars['String']['input'];
  customerId: Scalars['ID']['input'];
  inactive?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationCustomerPaymentMethodPaypalBillingAgreementUpdateArgs = {
  billingAddress: MailingAddressInput;
  id: Scalars['ID']['input'];
};


export type MutationCustomerPaymentMethodRemoteCreateArgs = {
  customerId: Scalars['ID']['input'];
  remoteReference: CustomerPaymentMethodRemoteInput;
};


export type MutationCustomerPaymentMethodRevokeArgs = {
  customerPaymentMethodId: Scalars['ID']['input'];
};


export type MutationCustomerPaymentMethodSendUpdateEmailArgs = {
  customerPaymentMethodId: Scalars['ID']['input'];
  email?: InputMaybe<EmailInput>;
};


export type MutationCustomerRemoveTaxExemptionsArgs = {
  customerId: Scalars['ID']['input'];
  taxExemptions: Array<TaxExemption>;
};


export type MutationCustomerReplaceTaxExemptionsArgs = {
  customerId: Scalars['ID']['input'];
  taxExemptions: Array<TaxExemption>;
};


export type MutationCustomerRequestDataErasureArgs = {
  customerId: Scalars['ID']['input'];
};


export type MutationCustomerSegmentMembersQueryCreateArgs = {
  input: CustomerSegmentMembersQueryInput;
};


export type MutationCustomerSendAccountInviteEmailArgs = {
  customerId: Scalars['ID']['input'];
  email?: InputMaybe<EmailInput>;
};


export type MutationCustomerSmsMarketingConsentUpdateArgs = {
  input: CustomerSmsMarketingConsentUpdateInput;
};


export type MutationCustomerUpdateArgs = {
  input: CustomerInput;
};


export type MutationCustomerUpdateDefaultAddressArgs = {
  addressId: Scalars['ID']['input'];
  customerId: Scalars['ID']['input'];
};


export type MutationDataSaleOptOutArgs = {
  email: Scalars['String']['input'];
};


export type MutationDelegateAccessTokenCreateArgs = {
  input: DelegateAccessTokenInput;
};


export type MutationDelegateAccessTokenDestroyArgs = {
  accessToken: Scalars['String']['input'];
};


export type MutationDeliveryCustomizationActivationArgs = {
  enabled: Scalars['Boolean']['input'];
  ids: Array<Scalars['ID']['input']>;
};


export type MutationDeliveryCustomizationCreateArgs = {
  deliveryCustomization: DeliveryCustomizationInput;
};


export type MutationDeliveryCustomizationDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeliveryCustomizationUpdateArgs = {
  deliveryCustomization: DeliveryCustomizationInput;
  id: Scalars['ID']['input'];
};


export type MutationDeliveryProfileCreateArgs = {
  profile: DeliveryProfileInput;
};


export type MutationDeliveryProfileRemoveArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeliveryProfileUpdateArgs = {
  id: Scalars['ID']['input'];
  leaveLegacyModeProfiles?: InputMaybe<Scalars['Boolean']['input']>;
  profile: DeliveryProfileInput;
};


export type MutationDeliveryPromiseParticipantsUpdateArgs = {
  brandedPromiseHandle: Scalars['String']['input'];
  ownersToAdd?: InputMaybe<Array<Scalars['ID']['input']>>;
  ownersToRemove?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type MutationDeliveryPromiseProviderUpsertArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  fulfillmentDelay?: InputMaybe<Scalars['Int']['input']>;
  locationId: Scalars['ID']['input'];
  timeZone?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDeliverySettingUpdateArgs = {
  setting: DeliverySettingInput;
};


export type MutationDeliveryShippingOriginAssignArgs = {
  locationId: Scalars['ID']['input'];
};


export type MutationDiscountAutomaticActivateArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDiscountAutomaticAppCreateArgs = {
  automaticAppDiscount: DiscountAutomaticAppInput;
};


export type MutationDiscountAutomaticAppUpdateArgs = {
  automaticAppDiscount: DiscountAutomaticAppInput;
  id: Scalars['ID']['input'];
};


export type MutationDiscountAutomaticBasicCreateArgs = {
  automaticBasicDiscount: DiscountAutomaticBasicInput;
};


export type MutationDiscountAutomaticBasicUpdateArgs = {
  automaticBasicDiscount: DiscountAutomaticBasicInput;
  id: Scalars['ID']['input'];
};


export type MutationDiscountAutomaticBulkDeleteArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDiscountAutomaticBxgyCreateArgs = {
  automaticBxgyDiscount: DiscountAutomaticBxgyInput;
};


export type MutationDiscountAutomaticBxgyUpdateArgs = {
  automaticBxgyDiscount: DiscountAutomaticBxgyInput;
  id: Scalars['ID']['input'];
};


export type MutationDiscountAutomaticDeactivateArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDiscountAutomaticDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDiscountAutomaticFreeShippingCreateArgs = {
  freeShippingAutomaticDiscount: DiscountAutomaticFreeShippingInput;
};


export type MutationDiscountAutomaticFreeShippingUpdateArgs = {
  freeShippingAutomaticDiscount: DiscountAutomaticFreeShippingInput;
  id: Scalars['ID']['input'];
};


export type MutationDiscountCodeActivateArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDiscountCodeAppCreateArgs = {
  codeAppDiscount: DiscountCodeAppInput;
};


export type MutationDiscountCodeAppUpdateArgs = {
  codeAppDiscount: DiscountCodeAppInput;
  id: Scalars['ID']['input'];
};


export type MutationDiscountCodeBasicCreateArgs = {
  basicCodeDiscount: DiscountCodeBasicInput;
};


export type MutationDiscountCodeBasicUpdateArgs = {
  basicCodeDiscount: DiscountCodeBasicInput;
  id: Scalars['ID']['input'];
};


export type MutationDiscountCodeBulkActivateArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDiscountCodeBulkDeactivateArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDiscountCodeBulkDeleteArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDiscountCodeBxgyCreateArgs = {
  bxgyCodeDiscount: DiscountCodeBxgyInput;
};


export type MutationDiscountCodeBxgyUpdateArgs = {
  bxgyCodeDiscount: DiscountCodeBxgyInput;
  id: Scalars['ID']['input'];
};


export type MutationDiscountCodeDeactivateArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDiscountCodeDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDiscountCodeFreeShippingCreateArgs = {
  freeShippingCodeDiscount: DiscountCodeFreeShippingInput;
};


export type MutationDiscountCodeFreeShippingUpdateArgs = {
  freeShippingCodeDiscount: DiscountCodeFreeShippingInput;
  id: Scalars['ID']['input'];
};


export type MutationDiscountCodeRedeemCodeBulkDeleteArgs = {
  discountId: Scalars['ID']['input'];
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDiscountRedeemCodeBulkAddArgs = {
  codes: Array<DiscountRedeemCodeInput>;
  discountId: Scalars['ID']['input'];
};


export type MutationDisputeEvidenceUpdateArgs = {
  id: Scalars['ID']['input'];
  input: ShopifyPaymentsDisputeEvidenceUpdateInput;
};


export type MutationDraftOrderBulkAddTagsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  tags: Array<Scalars['String']['input']>;
};


export type MutationDraftOrderBulkDeleteArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDraftOrderBulkRemoveTagsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  tags: Array<Scalars['String']['input']>;
};


export type MutationDraftOrderCalculateArgs = {
  input: DraftOrderInput;
};


export type MutationDraftOrderCompleteArgs = {
  id: Scalars['ID']['input'];
  paymentGatewayId?: InputMaybe<Scalars['ID']['input']>;
  sourceName?: InputMaybe<Scalars['String']['input']>;
};


export type MutationDraftOrderCreateArgs = {
  input: DraftOrderInput;
};


export type MutationDraftOrderCreateFromOrderArgs = {
  orderId: Scalars['ID']['input'];
};


export type MutationDraftOrderCreateMerchantCheckoutArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDraftOrderDeleteArgs = {
  input: DraftOrderDeleteInput;
};


export type MutationDraftOrderDuplicateArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationDraftOrderInvoicePreviewArgs = {
  email?: InputMaybe<EmailInput>;
  id: Scalars['ID']['input'];
};


export type MutationDraftOrderInvoiceSendArgs = {
  email?: InputMaybe<EmailInput>;
  id: Scalars['ID']['input'];
};


export type MutationDraftOrderUpdateArgs = {
  id: Scalars['ID']['input'];
  input: DraftOrderInput;
};


export type MutationEventBridgeServerPixelUpdateArgs = {
  arn: Scalars['ARN']['input'];
};


export type MutationEventBridgeWebhookSubscriptionCreateArgs = {
  topic: WebhookSubscriptionTopic;
  webhookSubscription: EventBridgeWebhookSubscriptionInput;
};


export type MutationEventBridgeWebhookSubscriptionUpdateArgs = {
  id: Scalars['ID']['input'];
  webhookSubscription: EventBridgeWebhookSubscriptionInput;
};


export type MutationFileAcknowledgeUpdateFailedArgs = {
  fileIds: Array<Scalars['ID']['input']>;
};


export type MutationFileCreateArgs = {
  files: Array<FileCreateInput>;
};


export type MutationFileDeleteArgs = {
  fileIds: Array<Scalars['ID']['input']>;
};


export type MutationFileUpdateArgs = {
  files: Array<FileUpdateInput>;
};


export type MutationFlowGenerateSignatureArgs = {
  id: Scalars['ID']['input'];
  payload: Scalars['String']['input'];
};


export type MutationFlowTriggerReceiveArgs = {
  handle?: InputMaybe<Scalars['String']['input']>;
  payload?: InputMaybe<Scalars['JSON']['input']>;
};


export type MutationFulfillmentCancelArgs = {
  id: Scalars['ID']['input'];
};


export type MutationFulfillmentConstraintRuleCreateArgs = {
  deliveryMethodTypes: Array<DeliveryMethodType>;
  functionId: Scalars['String']['input'];
  metafields?: InputMaybe<Array<MetafieldInput>>;
};


export type MutationFulfillmentConstraintRuleDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationFulfillmentConstraintRuleUpdateArgs = {
  deliveryMethodTypes: Array<DeliveryMethodType>;
  id: Scalars['ID']['input'];
};


export type MutationFulfillmentCreateArgs = {
  fulfillment: FulfillmentInput;
  message?: InputMaybe<Scalars['String']['input']>;
};


export type MutationFulfillmentCreateV2Args = {
  fulfillment: FulfillmentV2Input;
  message?: InputMaybe<Scalars['String']['input']>;
};


export type MutationFulfillmentEventCreateArgs = {
  fulfillmentEvent: FulfillmentEventInput;
};


export type MutationFulfillmentOrderAcceptCancellationRequestArgs = {
  id: Scalars['ID']['input'];
  message?: InputMaybe<Scalars['String']['input']>;
};


export type MutationFulfillmentOrderAcceptFulfillmentRequestArgs = {
  id: Scalars['ID']['input'];
  message?: InputMaybe<Scalars['String']['input']>;
};


export type MutationFulfillmentOrderCancelArgs = {
  id: Scalars['ID']['input'];
};


export type MutationFulfillmentOrderCloseArgs = {
  id: Scalars['ID']['input'];
  message?: InputMaybe<Scalars['String']['input']>;
};


export type MutationFulfillmentOrderHoldArgs = {
  fulfillmentHold: FulfillmentOrderHoldInput;
  id: Scalars['ID']['input'];
};


export type MutationFulfillmentOrderLineItemsPreparedForPickupArgs = {
  input: FulfillmentOrderLineItemsPreparedForPickupInput;
};


export type MutationFulfillmentOrderMergeArgs = {
  fulfillmentOrderMergeInputs: Array<FulfillmentOrderMergeInput>;
};


export type MutationFulfillmentOrderMoveArgs = {
  fulfillmentOrderLineItems?: InputMaybe<Array<FulfillmentOrderLineItemInput>>;
  id: Scalars['ID']['input'];
  newLocationId: Scalars['ID']['input'];
};


export type MutationFulfillmentOrderOpenArgs = {
  id: Scalars['ID']['input'];
};


export type MutationFulfillmentOrderRejectCancellationRequestArgs = {
  id: Scalars['ID']['input'];
  message?: InputMaybe<Scalars['String']['input']>;
};


export type MutationFulfillmentOrderRejectFulfillmentRequestArgs = {
  id: Scalars['ID']['input'];
  lineItems?: InputMaybe<Array<IncomingRequestLineItemInput>>;
  message?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<FulfillmentOrderRejectionReason>;
};


export type MutationFulfillmentOrderReleaseHoldArgs = {
  externalId?: InputMaybe<Scalars['String']['input']>;
  holdIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  id: Scalars['ID']['input'];
};


export type MutationFulfillmentOrderRescheduleArgs = {
  fulfillAt: Scalars['DateTime']['input'];
  id: Scalars['ID']['input'];
};


export type MutationFulfillmentOrderSplitArgs = {
  fulfillmentOrderSplits: Array<FulfillmentOrderSplitInput>;
};


export type MutationFulfillmentOrderSubmitCancellationRequestArgs = {
  id: Scalars['ID']['input'];
  message?: InputMaybe<Scalars['String']['input']>;
};


export type MutationFulfillmentOrderSubmitFulfillmentRequestArgs = {
  fulfillmentOrderLineItems?: InputMaybe<Array<FulfillmentOrderLineItemInput>>;
  id: Scalars['ID']['input'];
  message?: InputMaybe<Scalars['String']['input']>;
  notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationFulfillmentOrdersSetFulfillmentDeadlineArgs = {
  fulfillmentDeadline: Scalars['DateTime']['input'];
  fulfillmentOrderIds: Array<Scalars['ID']['input']>;
};


export type MutationFulfillmentServiceCreateArgs = {
  callbackUrl: Scalars['URL']['input'];
  inventoryManagement?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  trackingSupport?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationFulfillmentServiceDeleteArgs = {
  destinationLocationId?: InputMaybe<Scalars['ID']['input']>;
  id: Scalars['ID']['input'];
  inventoryAction?: InputMaybe<FulfillmentServiceDeleteInventoryAction>;
};


export type MutationFulfillmentServiceUpdateArgs = {
  callbackUrl?: InputMaybe<Scalars['URL']['input']>;
  id: Scalars['ID']['input'];
  inventoryManagement?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  trackingSupport?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationFulfillmentTrackingInfoUpdateArgs = {
  fulfillmentId: Scalars['ID']['input'];
  notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  trackingInfoInput: FulfillmentTrackingInput;
};


export type MutationFulfillmentTrackingInfoUpdateV2Args = {
  fulfillmentId: Scalars['ID']['input'];
  notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  trackingInfoInput: FulfillmentTrackingInput;
};


export type MutationGiftCardCreateArgs = {
  input: GiftCardCreateInput;
};


export type MutationGiftCardCreditArgs = {
  creditInput: GiftCardCreditInput;
  id: Scalars['ID']['input'];
};


export type MutationGiftCardDeactivateArgs = {
  id: Scalars['ID']['input'];
};


export type MutationGiftCardDebitArgs = {
  debitInput: GiftCardDebitInput;
  id: Scalars['ID']['input'];
};


export type MutationGiftCardSendNotificationToCustomerArgs = {
  id: Scalars['ID']['input'];
};


export type MutationGiftCardSendNotificationToRecipientArgs = {
  id: Scalars['ID']['input'];
};


export type MutationGiftCardUpdateArgs = {
  id: Scalars['ID']['input'];
  input: GiftCardUpdateInput;
};


export type MutationInventoryActivateArgs = {
  available?: InputMaybe<Scalars['Int']['input']>;
  inventoryItemId: Scalars['ID']['input'];
  locationId: Scalars['ID']['input'];
  onHand?: InputMaybe<Scalars['Int']['input']>;
  stockAtLegacyLocation?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationInventoryAdjustQuantitiesArgs = {
  input: InventoryAdjustQuantitiesInput;
};


export type MutationInventoryBulkToggleActivationArgs = {
  inventoryItemId: Scalars['ID']['input'];
  inventoryItemUpdates: Array<InventoryBulkToggleActivationInput>;
};


export type MutationInventoryDeactivateArgs = {
  inventoryLevelId: Scalars['ID']['input'];
};


export type MutationInventoryItemUpdateArgs = {
  id: Scalars['ID']['input'];
  input: InventoryItemInput;
};


export type MutationInventoryMoveQuantitiesArgs = {
  input: InventoryMoveQuantitiesInput;
};


export type MutationInventorySetOnHandQuantitiesArgs = {
  input: InventorySetOnHandQuantitiesInput;
};


export type MutationInventorySetQuantitiesArgs = {
  input: InventorySetQuantitiesInput;
};


export type MutationInventorySetScheduledChangesArgs = {
  input: InventorySetScheduledChangesInput;
};


export type MutationLocationActivateArgs = {
  locationId: Scalars['ID']['input'];
};


export type MutationLocationAddArgs = {
  input: LocationAddInput;
};


export type MutationLocationDeactivateArgs = {
  destinationLocationId?: InputMaybe<Scalars['ID']['input']>;
  locationId: Scalars['ID']['input'];
};


export type MutationLocationDeleteArgs = {
  locationId: Scalars['ID']['input'];
};


export type MutationLocationEditArgs = {
  id: Scalars['ID']['input'];
  input: LocationEditInput;
};


export type MutationLocationLocalPickupDisableArgs = {
  locationId: Scalars['ID']['input'];
};


export type MutationLocationLocalPickupEnableArgs = {
  localPickupSettings: DeliveryLocationLocalPickupEnableInput;
};


export type MutationMarketCreateArgs = {
  input: MarketCreateInput;
};


export type MutationMarketCurrencySettingsUpdateArgs = {
  input: MarketCurrencySettingsUpdateInput;
  marketId: Scalars['ID']['input'];
};


export type MutationMarketDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationMarketLocalizationsRegisterArgs = {
  marketLocalizations: Array<MarketLocalizationRegisterInput>;
  resourceId: Scalars['ID']['input'];
};


export type MutationMarketLocalizationsRemoveArgs = {
  marketIds: Array<Scalars['ID']['input']>;
  marketLocalizationKeys: Array<Scalars['String']['input']>;
  resourceId: Scalars['ID']['input'];
};


export type MutationMarketRegionDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationMarketRegionsCreateArgs = {
  marketId: Scalars['ID']['input'];
  regions: Array<MarketRegionCreateInput>;
};


export type MutationMarketRegionsDeleteArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type MutationMarketUpdateArgs = {
  id: Scalars['ID']['input'];
  input: MarketUpdateInput;
};


export type MutationMarketWebPresenceCreateArgs = {
  marketId: Scalars['ID']['input'];
  webPresence: MarketWebPresenceCreateInput;
};


export type MutationMarketWebPresenceDeleteArgs = {
  webPresenceId: Scalars['ID']['input'];
};


export type MutationMarketWebPresenceUpdateArgs = {
  webPresence: MarketWebPresenceUpdateInput;
  webPresenceId: Scalars['ID']['input'];
};


export type MutationMarketingActivityCreateArgs = {
  input: MarketingActivityCreateInput;
};


export type MutationMarketingActivityCreateExternalArgs = {
  input: MarketingActivityCreateExternalInput;
};


export type MutationMarketingActivityDeleteExternalArgs = {
  marketingActivityId?: InputMaybe<Scalars['ID']['input']>;
  remoteId?: InputMaybe<Scalars['String']['input']>;
};


export type MutationMarketingActivityUpdateArgs = {
  input: MarketingActivityUpdateInput;
};


export type MutationMarketingActivityUpdateExternalArgs = {
  input: MarketingActivityUpdateExternalInput;
  marketingActivityId?: InputMaybe<Scalars['ID']['input']>;
  remoteId?: InputMaybe<Scalars['String']['input']>;
  utm?: InputMaybe<UtmInput>;
};


export type MutationMarketingActivityUpsertExternalArgs = {
  input: MarketingActivityUpsertExternalInput;
};


export type MutationMarketingEngagementCreateArgs = {
  channelHandle?: InputMaybe<Scalars['String']['input']>;
  marketingActivityId?: InputMaybe<Scalars['ID']['input']>;
  marketingEngagement: MarketingEngagementInput;
  remoteId?: InputMaybe<Scalars['String']['input']>;
};


export type MutationMarketingEngagementsDeleteArgs = {
  channelHandle?: InputMaybe<Scalars['String']['input']>;
  deleteEngagementsForAllChannels?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationMenuCreateArgs = {
  handle: Scalars['String']['input'];
  items: Array<MenuItemCreateInput>;
  title: Scalars['String']['input'];
};


export type MutationMenuDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationMenuUpdateArgs = {
  handle?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  items: Array<MenuItemUpdateInput>;
  title: Scalars['String']['input'];
};


export type MutationMetafieldDefinitionCreateArgs = {
  definition: MetafieldDefinitionInput;
};


export type MutationMetafieldDefinitionDeleteArgs = {
  deleteAllAssociatedMetafields?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
};


export type MutationMetafieldDefinitionPinArgs = {
  definitionId: Scalars['ID']['input'];
};


export type MutationMetafieldDefinitionUnpinArgs = {
  definitionId: Scalars['ID']['input'];
};


export type MutationMetafieldDefinitionUpdateArgs = {
  definition: MetafieldDefinitionUpdateInput;
};


export type MutationMetafieldsDeleteArgs = {
  metafields: Array<MetafieldIdentifierInput>;
};


export type MutationMetafieldsSetArgs = {
  metafields: Array<MetafieldsSetInput>;
};


export type MutationMetaobjectBulkDeleteArgs = {
  where: MetaobjectBulkDeleteWhereCondition;
};


export type MutationMetaobjectCreateArgs = {
  metaobject: MetaobjectCreateInput;
};


export type MutationMetaobjectDefinitionCreateArgs = {
  definition: MetaobjectDefinitionCreateInput;
};


export type MutationMetaobjectDefinitionDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationMetaobjectDefinitionUpdateArgs = {
  definition: MetaobjectDefinitionUpdateInput;
  id: Scalars['ID']['input'];
};


export type MutationMetaobjectDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationMetaobjectUpdateArgs = {
  id: Scalars['ID']['input'];
  metaobject: MetaobjectUpdateInput;
};


export type MutationMetaobjectUpsertArgs = {
  handle: MetaobjectHandleInput;
  metaobject: MetaobjectUpsertInput;
};


export type MutationMobilePlatformApplicationCreateArgs = {
  input: MobilePlatformApplicationCreateInput;
};


export type MutationMobilePlatformApplicationDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationMobilePlatformApplicationUpdateArgs = {
  id: Scalars['ID']['input'];
  input: MobilePlatformApplicationUpdateInput;
};


export type MutationOrderCancelArgs = {
  notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  orderId: Scalars['ID']['input'];
  reason: OrderCancelReason;
  refund: Scalars['Boolean']['input'];
  restock: Scalars['Boolean']['input'];
  staffNote?: InputMaybe<Scalars['String']['input']>;
};


export type MutationOrderCaptureArgs = {
  input: OrderCaptureInput;
};


export type MutationOrderCloseArgs = {
  input: OrderCloseInput;
};


export type MutationOrderCreateArgs = {
  options?: InputMaybe<OrderCreateOptionsInput>;
  order: OrderCreateOrderInput;
};


export type MutationOrderCreateMandatePaymentArgs = {
  amount?: InputMaybe<MoneyInput>;
  autoCapture?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
  idempotencyKey: Scalars['String']['input'];
  mandateId: Scalars['ID']['input'];
  paymentScheduleId?: InputMaybe<Scalars['ID']['input']>;
};


export type MutationOrderDeleteArgs = {
  orderId: Scalars['ID']['input'];
};


export type MutationOrderEditAddCustomItemArgs = {
  id: Scalars['ID']['input'];
  locationId?: InputMaybe<Scalars['ID']['input']>;
  price: MoneyInput;
  quantity: Scalars['Int']['input'];
  requiresShipping?: InputMaybe<Scalars['Boolean']['input']>;
  taxable?: InputMaybe<Scalars['Boolean']['input']>;
  title: Scalars['String']['input'];
};


export type MutationOrderEditAddLineItemDiscountArgs = {
  discount: OrderEditAppliedDiscountInput;
  id: Scalars['ID']['input'];
  lineItemId: Scalars['ID']['input'];
};


export type MutationOrderEditAddShippingLineArgs = {
  id: Scalars['ID']['input'];
  shippingLine: OrderEditAddShippingLineInput;
};


export type MutationOrderEditAddVariantArgs = {
  allowDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
  locationId?: InputMaybe<Scalars['ID']['input']>;
  quantity: Scalars['Int']['input'];
  variantId: Scalars['ID']['input'];
};


export type MutationOrderEditBeginArgs = {
  id: Scalars['ID']['input'];
};


export type MutationOrderEditCommitArgs = {
  id: Scalars['ID']['input'];
  notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  staffNote?: InputMaybe<Scalars['String']['input']>;
};


export type MutationOrderEditRemoveDiscountArgs = {
  discountApplicationId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};


export type MutationOrderEditRemoveLineItemDiscountArgs = {
  discountApplicationId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};


export type MutationOrderEditRemoveShippingLineArgs = {
  id: Scalars['ID']['input'];
  shippingLineId: Scalars['ID']['input'];
};


export type MutationOrderEditSetQuantityArgs = {
  id: Scalars['ID']['input'];
  lineItemId: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
  restock?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationOrderEditUpdateDiscountArgs = {
  discount: OrderEditAppliedDiscountInput;
  discountApplicationId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};


export type MutationOrderEditUpdateShippingLineArgs = {
  id: Scalars['ID']['input'];
  shippingLine: OrderEditUpdateShippingLineInput;
  shippingLineId: Scalars['ID']['input'];
};


export type MutationOrderInvoiceSendArgs = {
  email?: InputMaybe<EmailInput>;
  id: Scalars['ID']['input'];
};


export type MutationOrderMarkAsPaidArgs = {
  input: OrderMarkAsPaidInput;
};


export type MutationOrderOpenArgs = {
  input: OrderOpenInput;
};


export type MutationOrderRiskAssessmentCreateArgs = {
  orderRiskAssessmentInput: OrderRiskAssessmentCreateInput;
};


export type MutationOrderUpdateArgs = {
  input: OrderInput;
};


export type MutationPageCreateArgs = {
  page: PageCreateInput;
};


export type MutationPageDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationPageUpdateArgs = {
  id: Scalars['ID']['input'];
  page: PageUpdateInput;
};


export type MutationPaymentCustomizationActivationArgs = {
  enabled: Scalars['Boolean']['input'];
  ids: Array<Scalars['ID']['input']>;
};


export type MutationPaymentCustomizationCreateArgs = {
  paymentCustomization: PaymentCustomizationInput;
};


export type MutationPaymentCustomizationDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationPaymentCustomizationUpdateArgs = {
  id: Scalars['ID']['input'];
  paymentCustomization: PaymentCustomizationInput;
};


export type MutationPaymentReminderSendArgs = {
  paymentScheduleId: Scalars['ID']['input'];
};


export type MutationPaymentTermsCreateArgs = {
  paymentTermsAttributes: PaymentTermsCreateInput;
  referenceId: Scalars['ID']['input'];
};


export type MutationPaymentTermsDeleteArgs = {
  input: PaymentTermsDeleteInput;
};


export type MutationPaymentTermsUpdateArgs = {
  input: PaymentTermsUpdateInput;
};


export type MutationPriceListCreateArgs = {
  input: PriceListCreateInput;
};


export type MutationPriceListDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationPriceListFixedPricesAddArgs = {
  priceListId: Scalars['ID']['input'];
  prices: Array<PriceListPriceInput>;
};


export type MutationPriceListFixedPricesByProductUpdateArgs = {
  priceListId: Scalars['ID']['input'];
  pricesToAdd?: InputMaybe<Array<PriceListProductPriceInput>>;
  pricesToDeleteByProductIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type MutationPriceListFixedPricesDeleteArgs = {
  priceListId: Scalars['ID']['input'];
  variantIds: Array<Scalars['ID']['input']>;
};


export type MutationPriceListFixedPricesUpdateArgs = {
  priceListId: Scalars['ID']['input'];
  pricesToAdd: Array<PriceListPriceInput>;
  variantIdsToDelete: Array<Scalars['ID']['input']>;
};


export type MutationPriceListUpdateArgs = {
  id: Scalars['ID']['input'];
  input: PriceListUpdateInput;
};


export type MutationProductBundleCreateArgs = {
  input: ProductBundleCreateInput;
};


export type MutationProductBundleUpdateArgs = {
  input: ProductBundleUpdateInput;
};


export type MutationProductChangeStatusArgs = {
  productId: Scalars['ID']['input'];
  status: ProductStatus;
};


export type MutationProductCreateArgs = {
  media?: InputMaybe<Array<CreateMediaInput>>;
  product?: InputMaybe<ProductCreateInput>;
};


export type MutationProductCreateMediaArgs = {
  media: Array<CreateMediaInput>;
  productId: Scalars['ID']['input'];
};


export type MutationProductDeleteArgs = {
  input: ProductDeleteInput;
  synchronous?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationProductDeleteMediaArgs = {
  mediaIds: Array<Scalars['ID']['input']>;
  productId: Scalars['ID']['input'];
};


export type MutationProductDuplicateArgs = {
  includeImages?: InputMaybe<Scalars['Boolean']['input']>;
  includeTranslations?: InputMaybe<Scalars['Boolean']['input']>;
  newStatus?: InputMaybe<ProductStatus>;
  newTitle: Scalars['String']['input'];
  productId: Scalars['ID']['input'];
  synchronous?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationProductFeedCreateArgs = {
  input?: InputMaybe<ProductFeedInput>;
};


export type MutationProductFeedDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationProductFullSyncArgs = {
  beforeUpdatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  id: Scalars['ID']['input'];
  updatedAtSince?: InputMaybe<Scalars['DateTime']['input']>;
};


export type MutationProductJoinSellingPlanGroupsArgs = {
  id: Scalars['ID']['input'];
  sellingPlanGroupIds: Array<Scalars['ID']['input']>;
};


export type MutationProductLeaveSellingPlanGroupsArgs = {
  id: Scalars['ID']['input'];
  sellingPlanGroupIds: Array<Scalars['ID']['input']>;
};


export type MutationProductOptionUpdateArgs = {
  option: OptionUpdateInput;
  optionValuesToAdd?: InputMaybe<Array<OptionValueCreateInput>>;
  optionValuesToDelete?: InputMaybe<Array<Scalars['ID']['input']>>;
  optionValuesToUpdate?: InputMaybe<Array<OptionValueUpdateInput>>;
  productId: Scalars['ID']['input'];
  variantStrategy?: InputMaybe<ProductOptionUpdateVariantStrategy>;
};


export type MutationProductOptionsCreateArgs = {
  options: Array<OptionCreateInput>;
  productId: Scalars['ID']['input'];
  variantStrategy?: InputMaybe<ProductOptionCreateVariantStrategy>;
};


export type MutationProductOptionsDeleteArgs = {
  options: Array<Scalars['ID']['input']>;
  productId: Scalars['ID']['input'];
  strategy?: InputMaybe<ProductOptionDeleteStrategy>;
};


export type MutationProductOptionsReorderArgs = {
  options: Array<OptionReorderInput>;
  productId: Scalars['ID']['input'];
};


export type MutationProductPublishArgs = {
  input: ProductPublishInput;
};


export type MutationProductReorderMediaArgs = {
  id: Scalars['ID']['input'];
  moves: Array<MoveInput>;
};


export type MutationProductSetArgs = {
  input: ProductSetInput;
  synchronous?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationProductUnpublishArgs = {
  input: ProductUnpublishInput;
};


export type MutationProductUpdateArgs = {
  media?: InputMaybe<Array<CreateMediaInput>>;
  product?: InputMaybe<ProductUpdateInput>;
};


export type MutationProductUpdateMediaArgs = {
  media: Array<UpdateMediaInput>;
  productId: Scalars['ID']['input'];
};


export type MutationProductVariantAppendMediaArgs = {
  productId: Scalars['ID']['input'];
  variantMedia: Array<ProductVariantAppendMediaInput>;
};


export type MutationProductVariantDetachMediaArgs = {
  productId: Scalars['ID']['input'];
  variantMedia: Array<ProductVariantDetachMediaInput>;
};


export type MutationProductVariantJoinSellingPlanGroupsArgs = {
  id: Scalars['ID']['input'];
  sellingPlanGroupIds: Array<Scalars['ID']['input']>;
};


export type MutationProductVariantLeaveSellingPlanGroupsArgs = {
  id: Scalars['ID']['input'];
  sellingPlanGroupIds: Array<Scalars['ID']['input']>;
};


export type MutationProductVariantRelationshipBulkUpdateArgs = {
  input: Array<ProductVariantRelationshipUpdateInput>;
};


export type MutationProductVariantsBulkCreateArgs = {
  media?: InputMaybe<Array<CreateMediaInput>>;
  productId: Scalars['ID']['input'];
  strategy?: InputMaybe<ProductVariantsBulkCreateStrategy>;
  variants: Array<ProductVariantsBulkInput>;
};


export type MutationProductVariantsBulkDeleteArgs = {
  productId: Scalars['ID']['input'];
  variantsIds: Array<Scalars['ID']['input']>;
};


export type MutationProductVariantsBulkReorderArgs = {
  positions: Array<ProductVariantPositionInput>;
  productId: Scalars['ID']['input'];
};


export type MutationProductVariantsBulkUpdateArgs = {
  allowPartialUpdates?: InputMaybe<Scalars['Boolean']['input']>;
  media?: InputMaybe<Array<CreateMediaInput>>;
  productId: Scalars['ID']['input'];
  variants: Array<ProductVariantsBulkInput>;
};


export type MutationPubSubServerPixelUpdateArgs = {
  pubSubProject: Scalars['String']['input'];
  pubSubTopic: Scalars['String']['input'];
};


export type MutationPubSubWebhookSubscriptionCreateArgs = {
  topic: WebhookSubscriptionTopic;
  webhookSubscription: PubSubWebhookSubscriptionInput;
};


export type MutationPubSubWebhookSubscriptionUpdateArgs = {
  id: Scalars['ID']['input'];
  webhookSubscription?: InputMaybe<PubSubWebhookSubscriptionInput>;
};


export type MutationPublicationCreateArgs = {
  input: PublicationCreateInput;
};


export type MutationPublicationDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationPublicationUpdateArgs = {
  id: Scalars['ID']['input'];
  input: PublicationUpdateInput;
};


export type MutationPublishablePublishArgs = {
  id: Scalars['ID']['input'];
  input: Array<PublicationInput>;
};


export type MutationPublishablePublishToCurrentChannelArgs = {
  id: Scalars['ID']['input'];
};


export type MutationPublishableUnpublishArgs = {
  id: Scalars['ID']['input'];
  input: Array<PublicationInput>;
};


export type MutationPublishableUnpublishToCurrentChannelArgs = {
  id: Scalars['ID']['input'];
};


export type MutationQuantityPricingByVariantUpdateArgs = {
  input: QuantityPricingByVariantUpdateInput;
  priceListId: Scalars['ID']['input'];
};


export type MutationQuantityRulesAddArgs = {
  priceListId: Scalars['ID']['input'];
  quantityRules: Array<QuantityRuleInput>;
};


export type MutationQuantityRulesDeleteArgs = {
  priceListId: Scalars['ID']['input'];
  variantIds: Array<Scalars['ID']['input']>;
};


export type MutationRefundCreateArgs = {
  input: RefundInput;
};


export type MutationReturnApproveRequestArgs = {
  input: ReturnApproveRequestInput;
};


export type MutationReturnCancelArgs = {
  id: Scalars['ID']['input'];
};


export type MutationReturnCloseArgs = {
  id: Scalars['ID']['input'];
};


export type MutationReturnCreateArgs = {
  returnInput: ReturnInput;
};


export type MutationReturnDeclineRequestArgs = {
  input: ReturnDeclineRequestInput;
};


export type MutationReturnLineItemRemoveFromReturnArgs = {
  returnId: Scalars['ID']['input'];
  returnLineItems: Array<ReturnLineItemRemoveFromReturnInput>;
};


export type MutationReturnRefundArgs = {
  returnRefundInput: ReturnRefundInput;
};


export type MutationReturnReopenArgs = {
  id: Scalars['ID']['input'];
};


export type MutationReturnRequestArgs = {
  input: ReturnRequestInput;
};


export type MutationReverseDeliveryCreateWithShippingArgs = {
  labelInput?: InputMaybe<ReverseDeliveryLabelInput>;
  notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  reverseDeliveryLineItems: Array<ReverseDeliveryLineItemInput>;
  reverseFulfillmentOrderId: Scalars['ID']['input'];
  trackingInput?: InputMaybe<ReverseDeliveryTrackingInput>;
};


export type MutationReverseDeliveryShippingUpdateArgs = {
  labelInput?: InputMaybe<ReverseDeliveryLabelInput>;
  notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  reverseDeliveryId: Scalars['ID']['input'];
  trackingInput?: InputMaybe<ReverseDeliveryTrackingInput>;
};


export type MutationReverseFulfillmentOrderDisposeArgs = {
  dispositionInputs: Array<ReverseFulfillmentOrderDisposeInput>;
};


export type MutationSavedSearchCreateArgs = {
  input: SavedSearchCreateInput;
};


export type MutationSavedSearchDeleteArgs = {
  input: SavedSearchDeleteInput;
};


export type MutationSavedSearchUpdateArgs = {
  input: SavedSearchUpdateInput;
};


export type MutationScriptTagCreateArgs = {
  input: ScriptTagInput;
};


export type MutationScriptTagDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationScriptTagUpdateArgs = {
  id: Scalars['ID']['input'];
  input: ScriptTagInput;
};


export type MutationSegmentCreateArgs = {
  name: Scalars['String']['input'];
  query: Scalars['String']['input'];
};


export type MutationSegmentDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationSegmentUpdateArgs = {
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};


export type MutationSellingPlanGroupAddProductVariantsArgs = {
  id: Scalars['ID']['input'];
  productVariantIds: Array<Scalars['ID']['input']>;
};


export type MutationSellingPlanGroupAddProductsArgs = {
  id: Scalars['ID']['input'];
  productIds: Array<Scalars['ID']['input']>;
};


export type MutationSellingPlanGroupCreateArgs = {
  input: SellingPlanGroupInput;
  resources?: InputMaybe<SellingPlanGroupResourceInput>;
};


export type MutationSellingPlanGroupDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationSellingPlanGroupRemoveProductVariantsArgs = {
  id: Scalars['ID']['input'];
  productVariantIds: Array<Scalars['ID']['input']>;
};


export type MutationSellingPlanGroupRemoveProductsArgs = {
  id: Scalars['ID']['input'];
  productIds: Array<Scalars['ID']['input']>;
};


export type MutationSellingPlanGroupUpdateArgs = {
  id: Scalars['ID']['input'];
  input: SellingPlanGroupInput;
};


export type MutationShippingPackageDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationShippingPackageMakeDefaultArgs = {
  id: Scalars['ID']['input'];
};


export type MutationShippingPackageUpdateArgs = {
  id: Scalars['ID']['input'];
  shippingPackage: CustomShippingPackageInput;
};


export type MutationShopLocaleDisableArgs = {
  locale: Scalars['String']['input'];
};


export type MutationShopLocaleEnableArgs = {
  locale: Scalars['String']['input'];
  marketWebPresenceIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type MutationShopLocaleUpdateArgs = {
  locale: Scalars['String']['input'];
  shopLocale: ShopLocaleInput;
};


export type MutationShopPolicyUpdateArgs = {
  shopPolicy: ShopPolicyInput;
};


export type MutationShopResourceFeedbackCreateArgs = {
  input: ResourceFeedbackCreateInput;
};


export type MutationShopifyPaymentsPayoutAlternateCurrencyCreateArgs = {
  accountId?: InputMaybe<Scalars['ID']['input']>;
  currency: CurrencyCode;
};


export type MutationStagedUploadTargetGenerateArgs = {
  input: StagedUploadTargetGenerateInput;
};


export type MutationStagedUploadTargetsGenerateArgs = {
  input: Array<StageImageInput>;
};


export type MutationStagedUploadsCreateArgs = {
  input: Array<StagedUploadInput>;
};


export type MutationStandardMetafieldDefinitionEnableArgs = {
  access?: InputMaybe<StandardMetafieldDefinitionAccessInput>;
  capabilities?: InputMaybe<MetafieldCapabilityCreateInput>;
  id?: InputMaybe<Scalars['ID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  ownerType: MetafieldOwnerType;
  pin?: Scalars['Boolean']['input'];
  useAsCollectionCondition?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationStandardMetaobjectDefinitionEnableArgs = {
  type: Scalars['String']['input'];
};


export type MutationStoreCreditAccountCreditArgs = {
  creditInput: StoreCreditAccountCreditInput;
  id: Scalars['ID']['input'];
};


export type MutationStoreCreditAccountDebitArgs = {
  debitInput: StoreCreditAccountDebitInput;
  id: Scalars['ID']['input'];
};


export type MutationStorefrontAccessTokenCreateArgs = {
  input: StorefrontAccessTokenInput;
};


export type MutationStorefrontAccessTokenDeleteArgs = {
  input: StorefrontAccessTokenDeleteInput;
};


export type MutationSubscriptionBillingAttemptCreateArgs = {
  subscriptionBillingAttemptInput: SubscriptionBillingAttemptInput;
  subscriptionContractId: Scalars['ID']['input'];
};


export type MutationSubscriptionBillingCycleBulkChargeArgs = {
  billingAttemptExpectedDateRange: SubscriptionBillingCyclesDateRangeSelector;
  filters?: InputMaybe<SubscriptionBillingCycleBulkFilters>;
  inventoryPolicy?: InputMaybe<SubscriptionBillingAttemptInventoryPolicy>;
};


export type MutationSubscriptionBillingCycleBulkSearchArgs = {
  billingAttemptExpectedDateRange: SubscriptionBillingCyclesDateRangeSelector;
  filters?: InputMaybe<SubscriptionBillingCycleBulkFilters>;
};


export type MutationSubscriptionBillingCycleChargeArgs = {
  billingCycleSelector: SubscriptionBillingCycleSelector;
  inventoryPolicy?: InputMaybe<SubscriptionBillingAttemptInventoryPolicy>;
  subscriptionContractId: Scalars['ID']['input'];
};


export type MutationSubscriptionBillingCycleContractDraftCommitArgs = {
  draftId: Scalars['ID']['input'];
};


export type MutationSubscriptionBillingCycleContractDraftConcatenateArgs = {
  concatenatedBillingCycleContracts: Array<SubscriptionBillingCycleInput>;
  draftId: Scalars['ID']['input'];
};


export type MutationSubscriptionBillingCycleContractEditArgs = {
  billingCycleInput: SubscriptionBillingCycleInput;
};


export type MutationSubscriptionBillingCycleEditDeleteArgs = {
  billingCycleInput: SubscriptionBillingCycleInput;
};


export type MutationSubscriptionBillingCycleEditsDeleteArgs = {
  contractId: Scalars['ID']['input'];
  targetSelection: SubscriptionBillingCyclesTargetSelection;
};


export type MutationSubscriptionBillingCycleScheduleEditArgs = {
  billingCycleInput: SubscriptionBillingCycleInput;
  input: SubscriptionBillingCycleScheduleEditInput;
};


export type MutationSubscriptionBillingCycleSkipArgs = {
  billingCycleInput: SubscriptionBillingCycleInput;
};


export type MutationSubscriptionBillingCycleUnskipArgs = {
  billingCycleInput: SubscriptionBillingCycleInput;
};


export type MutationSubscriptionContractActivateArgs = {
  subscriptionContractId: Scalars['ID']['input'];
};


export type MutationSubscriptionContractAtomicCreateArgs = {
  input: SubscriptionContractAtomicCreateInput;
};


export type MutationSubscriptionContractCancelArgs = {
  subscriptionContractId: Scalars['ID']['input'];
};


export type MutationSubscriptionContractCreateArgs = {
  input: SubscriptionContractCreateInput;
};


export type MutationSubscriptionContractExpireArgs = {
  subscriptionContractId: Scalars['ID']['input'];
};


export type MutationSubscriptionContractFailArgs = {
  subscriptionContractId: Scalars['ID']['input'];
};


export type MutationSubscriptionContractPauseArgs = {
  subscriptionContractId: Scalars['ID']['input'];
};


export type MutationSubscriptionContractProductChangeArgs = {
  input: SubscriptionContractProductChangeInput;
  lineId: Scalars['ID']['input'];
  subscriptionContractId: Scalars['ID']['input'];
};


export type MutationSubscriptionContractSetNextBillingDateArgs = {
  contractId: Scalars['ID']['input'];
  date: Scalars['DateTime']['input'];
};


export type MutationSubscriptionContractUpdateArgs = {
  contractId: Scalars['ID']['input'];
};


export type MutationSubscriptionDraftCommitArgs = {
  draftId: Scalars['ID']['input'];
};


export type MutationSubscriptionDraftDiscountAddArgs = {
  draftId: Scalars['ID']['input'];
  input: SubscriptionManualDiscountInput;
};


export type MutationSubscriptionDraftDiscountCodeApplyArgs = {
  draftId: Scalars['ID']['input'];
  redeemCode: Scalars['String']['input'];
};


export type MutationSubscriptionDraftDiscountRemoveArgs = {
  discountId: Scalars['ID']['input'];
  draftId: Scalars['ID']['input'];
};


export type MutationSubscriptionDraftDiscountUpdateArgs = {
  discountId: Scalars['ID']['input'];
  draftId: Scalars['ID']['input'];
  input: SubscriptionManualDiscountInput;
};


export type MutationSubscriptionDraftFreeShippingDiscountAddArgs = {
  draftId: Scalars['ID']['input'];
  input: SubscriptionFreeShippingDiscountInput;
};


export type MutationSubscriptionDraftFreeShippingDiscountUpdateArgs = {
  discountId: Scalars['ID']['input'];
  draftId: Scalars['ID']['input'];
  input: SubscriptionFreeShippingDiscountInput;
};


export type MutationSubscriptionDraftLineAddArgs = {
  draftId: Scalars['ID']['input'];
  input: SubscriptionLineInput;
};


export type MutationSubscriptionDraftLineRemoveArgs = {
  draftId: Scalars['ID']['input'];
  lineId: Scalars['ID']['input'];
};


export type MutationSubscriptionDraftLineUpdateArgs = {
  draftId: Scalars['ID']['input'];
  input: SubscriptionLineUpdateInput;
  lineId: Scalars['ID']['input'];
};


export type MutationSubscriptionDraftUpdateArgs = {
  draftId: Scalars['ID']['input'];
  input: SubscriptionDraftInput;
};


export type MutationTagsAddArgs = {
  id: Scalars['ID']['input'];
  tags: Array<Scalars['String']['input']>;
};


export type MutationTagsRemoveArgs = {
  id: Scalars['ID']['input'];
  tags: Array<Scalars['String']['input']>;
};


export type MutationTaxAppConfigureArgs = {
  ready: Scalars['Boolean']['input'];
};


export type MutationThemeCreateArgs = {
  name?: InputMaybe<Scalars['String']['input']>;
  source: Scalars['URL']['input'];
};


export type MutationThemeDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationThemeFilesCopyArgs = {
  files: Array<ThemeFilesCopyFileInput>;
  themeId: Scalars['ID']['input'];
};


export type MutationThemeFilesDeleteArgs = {
  files: Array<Scalars['String']['input']>;
  themeId: Scalars['ID']['input'];
};


export type MutationThemeFilesUpsertArgs = {
  files: Array<OnlineStoreThemeFilesUpsertFileInput>;
  themeId: Scalars['ID']['input'];
};


export type MutationThemePublishArgs = {
  id: Scalars['ID']['input'];
};


export type MutationThemeUpdateArgs = {
  id: Scalars['ID']['input'];
  input: OnlineStoreThemeInput;
};


export type MutationTransactionVoidArgs = {
  parentTransactionId: Scalars['ID']['input'];
};


export type MutationTranslationsRegisterArgs = {
  resourceId: Scalars['ID']['input'];
  translations: Array<TranslationInput>;
};


export type MutationTranslationsRemoveArgs = {
  locales: Array<Scalars['String']['input']>;
  marketIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  resourceId: Scalars['ID']['input'];
  translationKeys: Array<Scalars['String']['input']>;
};


export type MutationUrlRedirectBulkDeleteByIdsArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type MutationUrlRedirectBulkDeleteBySavedSearchArgs = {
  savedSearchId: Scalars['ID']['input'];
};


export type MutationUrlRedirectBulkDeleteBySearchArgs = {
  search: Scalars['String']['input'];
};


export type MutationUrlRedirectCreateArgs = {
  urlRedirect: UrlRedirectInput;
};


export type MutationUrlRedirectDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationUrlRedirectImportCreateArgs = {
  url: Scalars['URL']['input'];
};


export type MutationUrlRedirectImportSubmitArgs = {
  id: Scalars['ID']['input'];
};


export type MutationUrlRedirectUpdateArgs = {
  id: Scalars['ID']['input'];
  urlRedirect: UrlRedirectInput;
};


export type MutationValidationCreateArgs = {
  validation: ValidationCreateInput;
};


export type MutationValidationDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationValidationUpdateArgs = {
  id: Scalars['ID']['input'];
  validation: ValidationUpdateInput;
};


export type MutationWebPixelCreateArgs = {
  webPixel: WebPixelInput;
};


export type MutationWebPixelDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationWebPixelUpdateArgs = {
  id: Scalars['ID']['input'];
  webPixel: WebPixelInput;
};


export type MutationWebhookSubscriptionCreateArgs = {
  topic: WebhookSubscriptionTopic;
  webhookSubscription: WebhookSubscriptionInput;
};


export type MutationWebhookSubscriptionDeleteArgs = {
  id: Scalars['ID']['input'];
};


export type MutationWebhookSubscriptionUpdateArgs = {
  id: Scalars['ID']['input'];
  webhookSubscription: WebhookSubscriptionInput;
};

export type MutationsStagedUploadTargetGenerateUploadParameter = {
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type Navigable = {
  defaultCursor: Scalars['String']['output'];
};

export type NavigationItem = {
  id: Scalars['String']['output'];
  title: Scalars['String']['output'];
  url: Scalars['URL']['output'];
};

export type Node = {
  id: Scalars['ID']['output'];
};

export type ObjectDimensionsInput = {
  height: Scalars['Float']['input'];
  length: Scalars['Float']['input'];
  unit: LengthUnit;
  width: Scalars['Float']['input'];
};

export type OnlineStore = {
  passwordProtection: OnlineStorePasswordProtection;
};

export type OnlineStorePasswordProtection = {
  enabled: Scalars['Boolean']['output'];
};

export type OnlineStorePreviewable = {
  onlineStorePreviewUrl?: Maybe<Scalars['URL']['output']>;
};

export type OnlineStoreTheme = HasPublishedTranslations & Node & {
  createdAt: Scalars['DateTime']['output'];
  files?: Maybe<OnlineStoreThemeFileConnection>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  prefix: Scalars['String']['output'];
  processing: Scalars['Boolean']['output'];
  processingFailed: Scalars['Boolean']['output'];
  role: ThemeRole;
  themeStoreId?: Maybe<Scalars['Int']['output']>;
  translations: Array<Translation>;
  updatedAt: Scalars['DateTime']['output'];
};


export type OnlineStoreThemeFilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  filenames?: InputMaybe<Array<Scalars['String']['input']>>;
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type OnlineStoreThemeTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export type OnlineStoreThemeConnection = {
  edges: Array<OnlineStoreThemeEdge>;
  nodes: Array<OnlineStoreTheme>;
  pageInfo: PageInfo;
};

export type OnlineStoreThemeEdge = {
  cursor: Scalars['String']['output'];
  node: OnlineStoreTheme;
};

export type OnlineStoreThemeFile = {
  body: OnlineStoreThemeFileBody;
  checksumMd5?: Maybe<Scalars['String']['output']>;
  contentType: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  filename: Scalars['String']['output'];
  size: Scalars['UnsignedInt64']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type OnlineStoreThemeFileBody = OnlineStoreThemeFileBodyBase64 | OnlineStoreThemeFileBodyText | OnlineStoreThemeFileBodyUrl;

export type OnlineStoreThemeFileBodyBase64 = {
  contentBase64: Scalars['String']['output'];
};

export type OnlineStoreThemeFileBodyInput = {
  type: OnlineStoreThemeFileBodyInputType;
  value: Scalars['String']['input'];
};

export const OnlineStoreThemeFileBodyInputType = {
  Base64: 'BASE64',
  Text: 'TEXT',
  Url: 'URL'
} as const;

export type OnlineStoreThemeFileBodyInputType = typeof OnlineStoreThemeFileBodyInputType[keyof typeof OnlineStoreThemeFileBodyInputType];
export type OnlineStoreThemeFileBodyText = {
  content: Scalars['String']['output'];
};

export type OnlineStoreThemeFileBodyUrl = {
  url: Scalars['URL']['output'];
};

export type OnlineStoreThemeFileConnection = {
  edges: Array<OnlineStoreThemeFileEdge>;
  nodes: Array<OnlineStoreThemeFile>;
  pageInfo: PageInfo;
  userErrors: Array<OnlineStoreThemeFileReadResult>;
};

export type OnlineStoreThemeFileEdge = {
  cursor: Scalars['String']['output'];
  node: OnlineStoreThemeFile;
};

export type OnlineStoreThemeFileOperationResult = {
  filename: Scalars['String']['output'];
};

export type OnlineStoreThemeFileReadResult = {
  code: OnlineStoreThemeFileResultType;
  filename: Scalars['String']['output'];
};

export const OnlineStoreThemeFileResultType = {
  BadRequest: 'BAD_REQUEST',
  Conflict: 'CONFLICT',
  Error: 'ERROR',
  NotFound: 'NOT_FOUND',
  Success: 'SUCCESS',
  Timeout: 'TIMEOUT',
  UnprocessableEntity: 'UNPROCESSABLE_ENTITY'
} as const;

export type OnlineStoreThemeFileResultType = typeof OnlineStoreThemeFileResultType[keyof typeof OnlineStoreThemeFileResultType];
export type OnlineStoreThemeFilesUpsertFileInput = {
  body: OnlineStoreThemeFileBodyInput;
  filename: Scalars['String']['input'];
};

export type OnlineStoreThemeFilesUserErrors = DisplayableError & {
  code?: Maybe<OnlineStoreThemeFilesUserErrorsCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  filename?: Maybe<Scalars['String']['output']>;
  message: Scalars['String']['output'];
};

export const OnlineStoreThemeFilesUserErrorsCode = {
  AccessDenied: 'ACCESS_DENIED',
  DuplicateFileInput: 'DUPLICATE_FILE_INPUT',
  Error: 'ERROR',
  FileValidationError: 'FILE_VALIDATION_ERROR',
  LessThanOrEqualTo: 'LESS_THAN_OR_EQUAL_TO',
  NotFound: 'NOT_FOUND',
  ThemeFilesConflict: 'THEME_FILES_CONFLICT',
  ThemeLimitedPlan: 'THEME_LIMITED_PLAN',
  Throttled: 'THROTTLED'
} as const;

export type OnlineStoreThemeFilesUserErrorsCode = typeof OnlineStoreThemeFilesUserErrorsCode[keyof typeof OnlineStoreThemeFilesUserErrorsCode];
export type OnlineStoreThemeInput = {
  name?: InputMaybe<Scalars['String']['input']>;
};

export type OptionAndValueInput = {
  linkedMetafield?: InputMaybe<LinkedMetafieldInput>;
  name: Scalars['String']['input'];
  optionId?: InputMaybe<Scalars['ID']['input']>;
  values: Array<Scalars['String']['input']>;
};

export type OptionCreateInput = {
  linkedMetafield?: InputMaybe<LinkedMetafieldCreateInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  values?: InputMaybe<Array<OptionValueCreateInput>>;
};

export type OptionReorderInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  values?: InputMaybe<Array<OptionValueReorderInput>>;
};

export type OptionSetInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  linkedMetafield?: InputMaybe<LinkedMetafieldCreateInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  values?: InputMaybe<Array<OptionValueSetInput>>;
};

export type OptionUpdateInput = {
  id: Scalars['ID']['input'];
  linkedMetafield?: InputMaybe<LinkedMetafieldUpdateInput>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

export type OptionValueCreateInput = {
  linkedMetafieldValue?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type OptionValueReorderInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type OptionValueSetInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type OptionValueUpdateInput = {
  id: Scalars['ID']['input'];
  linkedMetafieldValue?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type Order = CommentEventSubject & HasEvents & HasLocalizationExtensions & HasLocalizedFields & HasMetafieldDefinitions & HasMetafields & LegacyInteroperability & Node & {
  additionalFees: Array<AdditionalFee>;
  agreements: SalesAgreementConnection;
  alerts: Array<ResourceAlert>;
  app?: Maybe<OrderApp>;
  billingAddress?: Maybe<MailingAddress>;
  billingAddressMatchesShippingAddress: Scalars['Boolean']['output'];
  canMarkAsPaid: Scalars['Boolean']['output'];
  canNotifyCustomer: Scalars['Boolean']['output'];
  cancelReason?: Maybe<OrderCancelReason>;
  cancellation?: Maybe<OrderCancellation>;
  cancelledAt?: Maybe<Scalars['DateTime']['output']>;
  capturable: Scalars['Boolean']['output'];
  /** @deprecated Use `cartDiscountAmountSet` instead. */
  cartDiscountAmount?: Maybe<Scalars['Money']['output']>;
  cartDiscountAmountSet?: Maybe<MoneyBag>;
  /** @deprecated Use `publication` instead. */
  channel?: Maybe<Channel>;
  channelInformation?: Maybe<ChannelInformation>;
  clientIp?: Maybe<Scalars['String']['output']>;
  closed: Scalars['Boolean']['output'];
  closedAt?: Maybe<Scalars['DateTime']['output']>;
  confirmationNumber?: Maybe<Scalars['String']['output']>;
  confirmed: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  currencyCode: CurrencyCode;
  currentCartDiscountAmountSet: MoneyBag;
  currentShippingPriceSet: MoneyBag;
  currentSubtotalLineItemsQuantity: Scalars['Int']['output'];
  currentSubtotalPriceSet: MoneyBag;
  currentTaxLines: Array<TaxLine>;
  currentTotalAdditionalFeesSet?: Maybe<MoneyBag>;
  currentTotalDiscountsSet: MoneyBag;
  currentTotalDutiesSet?: Maybe<MoneyBag>;
  currentTotalPriceSet: MoneyBag;
  currentTotalTaxSet: MoneyBag;
  currentTotalWeight: Scalars['UnsignedInt64']['output'];
  customAttributes: Array<Attribute>;
  customer?: Maybe<Customer>;
  customerAcceptsMarketing: Scalars['Boolean']['output'];
  /** @deprecated Use `customerJourneySummary` instead. */
  customerJourney?: Maybe<CustomerJourney>;
  customerJourneySummary?: Maybe<CustomerJourneySummary>;
  customerLocale?: Maybe<Scalars['String']['output']>;
  discountApplications: DiscountApplicationConnection;
  discountCode?: Maybe<Scalars['String']['output']>;
  discountCodes: Array<Scalars['String']['output']>;
  displayAddress?: Maybe<MailingAddress>;
  displayFinancialStatus?: Maybe<OrderDisplayFinancialStatus>;
  displayFulfillmentStatus: OrderDisplayFulfillmentStatus;
  disputes: Array<OrderDisputeSummary>;
  dutiesIncluded: Scalars['Boolean']['output'];
  edited: Scalars['Boolean']['output'];
  email?: Maybe<Scalars['String']['output']>;
  estimatedTaxes: Scalars['Boolean']['output'];
  events: EventConnection;
  exchangeV2s: ExchangeV2Connection;
  fulfillable: Scalars['Boolean']['output'];
  fulfillmentOrders: FulfillmentOrderConnection;
  fulfillments: Array<Fulfillment>;
  fulfillmentsCount?: Maybe<Count>;
  fullyPaid: Scalars['Boolean']['output'];
  hasTimelineComment: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** @deprecated Use `customerJourneySummary.lastVisit.landingPageHtml` instead */
  landingPageDisplayText?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use `customerJourneySummary.lastVisit.landingPage` instead */
  landingPageUrl?: Maybe<Scalars['URL']['output']>;
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  lineItems: LineItemConnection;
  /** @deprecated This connection will be removed in a future version. Use `localizedFields` instead. */
  localizationExtensions: LocalizationExtensionConnection;
  localizedFields: LocalizedFieldConnection;
  merchantBusinessEntity: BusinessEntity;
  merchantEditable: Scalars['Boolean']['output'];
  merchantEditableErrors: Array<Scalars['String']['output']>;
  merchantOfRecordApp?: Maybe<OrderApp>;
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  name: Scalars['String']['output'];
  /** @deprecated Use `netPaymentSet` instead. */
  netPayment: Scalars['Money']['output'];
  netPaymentSet: MoneyBag;
  nonFulfillableLineItems: LineItemConnection;
  note?: Maybe<Scalars['String']['output']>;
  originalTotalAdditionalFeesSet?: Maybe<MoneyBag>;
  originalTotalDutiesSet?: Maybe<MoneyBag>;
  originalTotalPriceSet: MoneyBag;
  paymentCollectionDetails: OrderPaymentCollectionDetails;
  paymentGatewayNames: Array<Scalars['String']['output']>;
  paymentTerms?: Maybe<PaymentTerms>;
  phone?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use `fulfillmentOrders` to get the fulfillment location for the order */
  physicalLocation?: Maybe<Location>;
  poNumber?: Maybe<Scalars['String']['output']>;
  presentmentCurrencyCode: CurrencyCode;
  processedAt: Scalars['DateTime']['output'];
  publication?: Maybe<Publication>;
  purchasingEntity?: Maybe<PurchasingEntity>;
  /** @deprecated Use `customerJourneySummary.lastVisit.referralCode` instead */
  referralCode?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use `customerJourneySummary.lastVisit.referralInfoHtml` instead */
  referrerDisplayText?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use `customerJourneySummary.lastVisit.referrerUrl` instead */
  referrerUrl?: Maybe<Scalars['URL']['output']>;
  refundDiscrepancySet: MoneyBag;
  refundable: Scalars['Boolean']['output'];
  refunds: Array<Refund>;
  registeredSourceUrl?: Maybe<Scalars['URL']['output']>;
  requiresShipping: Scalars['Boolean']['output'];
  restockable: Scalars['Boolean']['output'];
  retailLocation?: Maybe<Location>;
  returnStatus: OrderReturnStatus;
  returns: ReturnConnection;
  risk: OrderRiskSummary;
  /** @deprecated This field is deprecated in version 2024-04. Please use OrderRiskAssessment.riskLevel */
  riskLevel: OrderRiskLevel;
  /** @deprecated This field is deprecated in version 2024-04. Please use OrderRiskAssessment */
  risks: Array<OrderRisk>;
  shippingAddress?: Maybe<MailingAddress>;
  shippingLine?: Maybe<ShippingLine>;
  shippingLines: ShippingLineConnection;
  shopifyProtect?: Maybe<ShopifyProtectOrderSummary>;
  sourceIdentifier?: Maybe<Scalars['String']['output']>;
  sourceName?: Maybe<Scalars['String']['output']>;
  staffMember?: Maybe<StaffMember>;
  statusPageUrl: Scalars['URL']['output'];
  subtotalLineItemsQuantity: Scalars['Int']['output'];
  /** @deprecated Use `subtotalPriceSet` instead. */
  subtotalPrice?: Maybe<Scalars['Money']['output']>;
  subtotalPriceSet?: Maybe<MoneyBag>;
  suggestedRefund?: Maybe<SuggestedRefund>;
  tags: Array<Scalars['String']['output']>;
  taxExempt: Scalars['Boolean']['output'];
  taxLines: Array<TaxLine>;
  taxesIncluded: Scalars['Boolean']['output'];
  test: Scalars['Boolean']['output'];
  /** @deprecated Use `totalCapturableSet` instead. */
  totalCapturable: Scalars['Money']['output'];
  totalCapturableSet: MoneyBag;
  totalCashRoundingAdjustment: CashRoundingAdjustment;
  /** @deprecated Use `totalDiscountsSet` instead. */
  totalDiscounts?: Maybe<Scalars['Money']['output']>;
  totalDiscountsSet?: Maybe<MoneyBag>;
  totalOutstandingSet: MoneyBag;
  /** @deprecated Use `totalPriceSet` instead. */
  totalPrice: Scalars['Money']['output'];
  totalPriceSet: MoneyBag;
  /** @deprecated Use `totalReceivedSet` instead. */
  totalReceived: Scalars['Money']['output'];
  totalReceivedSet: MoneyBag;
  /** @deprecated Use `totalRefundedSet` instead. */
  totalRefunded: Scalars['Money']['output'];
  totalRefundedSet: MoneyBag;
  totalRefundedShippingSet: MoneyBag;
  /** @deprecated Use `totalShippingPriceSet` instead. */
  totalShippingPrice: Scalars['Money']['output'];
  totalShippingPriceSet: MoneyBag;
  /** @deprecated Use `totalTaxSet` instead. */
  totalTax?: Maybe<Scalars['Money']['output']>;
  totalTaxSet?: Maybe<MoneyBag>;
  /** @deprecated Use `totalTipReceivedSet` instead. */
  totalTipReceived: MoneyV2;
  totalTipReceivedSet: MoneyBag;
  totalWeight?: Maybe<Scalars['UnsignedInt64']['output']>;
  transactions: Array<OrderTransaction>;
  transactionsCount?: Maybe<Count>;
  unpaid: Scalars['Boolean']['output'];
  updatedAt: Scalars['DateTime']['output'];
};


export type OrderAgreementsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrderDiscountApplicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrderEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type OrderExchangeV2sArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrderFulfillmentOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  displayable?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrderFulfillmentsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type OrderLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrderLocalizationExtensionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  countryCodes?: InputMaybe<Array<CountryCode>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  purposes?: InputMaybe<Array<LocalizationExtensionPurpose>>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrderLocalizedFieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  countryCodes?: InputMaybe<Array<CountryCode>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  purposes?: InputMaybe<Array<LocalizedFieldPurpose>>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrderMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type OrderMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type OrderMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrderNonFulfillableLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrderRefundsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type OrderReturnsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrderRisksArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type OrderShippingLinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeRemovals?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrderSuggestedRefundArgs = {
  refundDuties?: InputMaybe<Array<RefundDutyInput>>;
  refundLineItems?: InputMaybe<Array<RefundLineItemInput>>;
  refundShipping?: InputMaybe<Scalars['Boolean']['input']>;
  shippingAmount?: InputMaybe<Scalars['Money']['input']>;
  suggestFullRefund?: InputMaybe<Scalars['Boolean']['input']>;
};


export type OrderTransactionsArgs = {
  capturable?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  manuallyResolvable?: InputMaybe<Scalars['Boolean']['input']>;
};

export const OrderActionType = {
  Order: 'ORDER',
  OrderEdit: 'ORDER_EDIT',
  Refund: 'REFUND',
  Return: 'RETURN',
  Unknown: 'UNKNOWN'
} as const;

export type OrderActionType = typeof OrderActionType[keyof typeof OrderActionType];
export type OrderAdjustment = Node & {
  amountSet: MoneyBag;
  id: Scalars['ID']['output'];
  reason?: Maybe<OrderAdjustmentDiscrepancyReason>;
  taxAmountSet: MoneyBag;
};

export type OrderAdjustmentConnection = {
  edges: Array<OrderAdjustmentEdge>;
  nodes: Array<OrderAdjustment>;
  pageInfo: PageInfo;
};

export const OrderAdjustmentDiscrepancyReason = {
  Customer: 'CUSTOMER',
  Damage: 'DAMAGE',
  FullReturnBalancingAdjustment: 'FULL_RETURN_BALANCING_ADJUSTMENT',
  PendingRefundDiscrepancy: 'PENDING_REFUND_DISCREPANCY',
  RefundDiscrepancy: 'REFUND_DISCREPANCY',
  Restock: 'RESTOCK'
} as const;

export type OrderAdjustmentDiscrepancyReason = typeof OrderAdjustmentDiscrepancyReason[keyof typeof OrderAdjustmentDiscrepancyReason];
export type OrderAdjustmentEdge = {
  cursor: Scalars['String']['output'];
  node: OrderAdjustment;
};

export const OrderAdjustmentInputDiscrepancyReason = {
  Customer: 'CUSTOMER',
  Damage: 'DAMAGE',
  Other: 'OTHER',
  Restock: 'RESTOCK'
} as const;

export type OrderAdjustmentInputDiscrepancyReason = typeof OrderAdjustmentInputDiscrepancyReason[keyof typeof OrderAdjustmentInputDiscrepancyReason];
export type OrderAgreement = SalesAgreement & {
  app?: Maybe<App>;
  happenedAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  order: Order;
  reason: OrderActionType;
  sales: SaleConnection;
  user?: Maybe<StaffMember>;
};


export type OrderAgreementSalesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type OrderApp = {
  icon: Image;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type OrderCancelPayload = {
  job?: Maybe<Job>;
  orderCancelUserErrors: Array<OrderCancelUserError>;
  /** @deprecated Use `orderCancelUserErrors` instead. */
  userErrors: Array<UserError>;
};

export const OrderCancelReason = {
  Customer: 'CUSTOMER',
  Declined: 'DECLINED',
  Fraud: 'FRAUD',
  Inventory: 'INVENTORY',
  Other: 'OTHER',
  Staff: 'STAFF'
} as const;

export type OrderCancelReason = typeof OrderCancelReason[keyof typeof OrderCancelReason];
export type OrderCancelUserError = DisplayableError & {
  code?: Maybe<OrderCancelUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const OrderCancelUserErrorCode = {
  Invalid: 'INVALID',
  NotFound: 'NOT_FOUND',
  NoRefundPermission: 'NO_REFUND_PERMISSION'
} as const;

export type OrderCancelUserErrorCode = typeof OrderCancelUserErrorCode[keyof typeof OrderCancelUserErrorCode];
export type OrderCancellation = {
  staffNote?: Maybe<Scalars['String']['output']>;
};

export type OrderCaptureInput = {
  amount: Scalars['Money']['input'];
  currency?: InputMaybe<CurrencyCode>;
  finalCapture?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
  parentTransactionId: Scalars['ID']['input'];
};

export type OrderCapturePayload = {
  transaction?: Maybe<OrderTransaction>;
  userErrors: Array<UserError>;
};

export type OrderCloseInput = {
  id: Scalars['ID']['input'];
};

export type OrderClosePayload = {
  order?: Maybe<Order>;
  userErrors: Array<UserError>;
};

export type OrderConnection = {
  edges: Array<OrderEdge>;
  nodes: Array<Order>;
  pageInfo: PageInfo;
};

export type OrderCreateAssociateCustomerAttributesInput = {
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};

export type OrderCreateCustomAttributeInput = {
  key: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type OrderCreateCustomerAddressInput = {
  address1?: InputMaybe<Scalars['String']['input']>;
  address2?: InputMaybe<Scalars['String']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  company?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  zip?: InputMaybe<Scalars['String']['input']>;
};

export type OrderCreateCustomerInput = {
  toAssociate?: InputMaybe<OrderCreateAssociateCustomerAttributesInput>;
  toUpsert?: InputMaybe<OrderCreateUpsertCustomerAttributesInput>;
};

export type OrderCreateDiscountCodeInput = {
  freeShippingDiscountCode?: InputMaybe<OrderCreateFreeShippingDiscountCodeAttributesInput>;
  itemFixedDiscountCode?: InputMaybe<OrderCreateFixedDiscountCodeAttributesInput>;
  itemPercentageDiscountCode?: InputMaybe<OrderCreatePercentageDiscountCodeAttributesInput>;
};

export const OrderCreateFinancialStatus = {
  Authorized: 'AUTHORIZED',
  Expired: 'EXPIRED',
  Paid: 'PAID',
  PartiallyPaid: 'PARTIALLY_PAID',
  PartiallyRefunded: 'PARTIALLY_REFUNDED',
  Pending: 'PENDING',
  Refunded: 'REFUNDED',
  Voided: 'VOIDED'
} as const;

export type OrderCreateFinancialStatus = typeof OrderCreateFinancialStatus[keyof typeof OrderCreateFinancialStatus];
export type OrderCreateFixedDiscountCodeAttributesInput = {
  amountSet?: InputMaybe<MoneyBagInput>;
  code: Scalars['String']['input'];
};

export type OrderCreateFreeShippingDiscountCodeAttributesInput = {
  code: Scalars['String']['input'];
};

export type OrderCreateFulfillmentInput = {
  locationId: Scalars['ID']['input'];
  notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  originAddress?: InputMaybe<FulfillmentOriginAddressInput>;
  shipmentStatus?: InputMaybe<FulfillmentEventStatus>;
  trackingCompany?: InputMaybe<Scalars['String']['input']>;
  trackingNumber?: InputMaybe<Scalars['String']['input']>;
};

export const OrderCreateFulfillmentStatus = {
  Fulfilled: 'FULFILLED',
  Partial: 'PARTIAL',
  Restocked: 'RESTOCKED'
} as const;

export type OrderCreateFulfillmentStatus = typeof OrderCreateFulfillmentStatus[keyof typeof OrderCreateFulfillmentStatus];
export const OrderCreateInputsInventoryBehavior = {
  Bypass: 'BYPASS',
  DecrementIgnoringPolicy: 'DECREMENT_IGNORING_POLICY',
  DecrementObeyingPolicy: 'DECREMENT_OBEYING_POLICY'
} as const;

export type OrderCreateInputsInventoryBehavior = typeof OrderCreateInputsInventoryBehavior[keyof typeof OrderCreateInputsInventoryBehavior];
export type OrderCreateLineItemInput = {
  fulfillmentService?: InputMaybe<Scalars['String']['input']>;
  giftCard?: InputMaybe<Scalars['Boolean']['input']>;
  priceSet?: InputMaybe<MoneyBagInput>;
  productId?: InputMaybe<Scalars['ID']['input']>;
  properties?: InputMaybe<Array<OrderCreateLineItemPropertyInput>>;
  quantity: Scalars['Int']['input'];
  requiresShipping?: InputMaybe<Scalars['Boolean']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  taxLines?: InputMaybe<Array<OrderCreateTaxLineInput>>;
  taxable?: InputMaybe<Scalars['Boolean']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  variantId?: InputMaybe<Scalars['ID']['input']>;
  variantTitle?: InputMaybe<Scalars['String']['input']>;
  vendor?: InputMaybe<Scalars['String']['input']>;
};

export type OrderCreateLineItemPropertyInput = {
  name: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type OrderCreateMandatePaymentPayload = {
  job?: Maybe<Job>;
  paymentReferenceId?: Maybe<Scalars['String']['output']>;
  userErrors: Array<OrderCreateMandatePaymentUserError>;
};

export type OrderCreateMandatePaymentUserError = DisplayableError & {
  code?: Maybe<OrderCreateMandatePaymentUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const OrderCreateMandatePaymentUserErrorCode = {
  OrderMandatePaymentErrorCode: 'ORDER_MANDATE_PAYMENT_ERROR_CODE'
} as const;

export type OrderCreateMandatePaymentUserErrorCode = typeof OrderCreateMandatePaymentUserErrorCode[keyof typeof OrderCreateMandatePaymentUserErrorCode];
export type OrderCreateOptionsInput = {
  inventoryBehaviour?: InputMaybe<OrderCreateInputsInventoryBehavior>;
  sendFulfillmentReceipt?: InputMaybe<Scalars['Boolean']['input']>;
  sendReceipt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type OrderCreateOrderInput = {
  billingAddress?: InputMaybe<MailingAddressInput>;
  buyerAcceptsMarketing?: InputMaybe<Scalars['Boolean']['input']>;
  closedAt?: InputMaybe<Scalars['DateTime']['input']>;
  companyLocationId?: InputMaybe<Scalars['ID']['input']>;
  currency?: InputMaybe<CurrencyCode>;
  customAttributes?: InputMaybe<Array<OrderCreateCustomAttributeInput>>;
  customer?: InputMaybe<OrderCreateCustomerInput>;
  discountCode?: InputMaybe<OrderCreateDiscountCodeInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  financialStatus?: InputMaybe<OrderCreateFinancialStatus>;
  fulfillment?: InputMaybe<OrderCreateFulfillmentInput>;
  fulfillmentStatus?: InputMaybe<OrderCreateFulfillmentStatus>;
  lineItems?: InputMaybe<Array<OrderCreateLineItemInput>>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  poNumber?: InputMaybe<Scalars['String']['input']>;
  presentmentCurrency?: InputMaybe<CurrencyCode>;
  processedAt?: InputMaybe<Scalars['DateTime']['input']>;
  referringSite?: InputMaybe<Scalars['URL']['input']>;
  shippingAddress?: InputMaybe<MailingAddressInput>;
  shippingLines?: InputMaybe<Array<OrderCreateShippingLineInput>>;
  sourceIdentifier?: InputMaybe<Scalars['String']['input']>;
  sourceName?: InputMaybe<Scalars['String']['input']>;
  sourceUrl?: InputMaybe<Scalars['URL']['input']>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  taxLines?: InputMaybe<Array<OrderCreateTaxLineInput>>;
  taxesIncluded?: InputMaybe<Scalars['Boolean']['input']>;
  test?: InputMaybe<Scalars['Boolean']['input']>;
  transactions?: InputMaybe<Array<OrderCreateOrderTransactionInput>>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type OrderCreateOrderTransactionInput = {
  amountSet: MoneyBagInput;
  authorizationCode?: InputMaybe<Scalars['String']['input']>;
  deviceId?: InputMaybe<Scalars['ID']['input']>;
  gateway?: InputMaybe<Scalars['String']['input']>;
  giftCardId?: InputMaybe<Scalars['ID']['input']>;
  kind?: InputMaybe<OrderTransactionKind>;
  locationId?: InputMaybe<Scalars['ID']['input']>;
  processedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receiptJson?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<OrderTransactionStatus>;
  test?: InputMaybe<Scalars['Boolean']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type OrderCreatePayload = {
  order?: Maybe<Order>;
  userErrors: Array<OrderCreateUserError>;
};

export type OrderCreatePercentageDiscountCodeAttributesInput = {
  code: Scalars['String']['input'];
  percentage?: InputMaybe<Scalars['Float']['input']>;
};

export type OrderCreateShippingLineInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  priceSet: MoneyBagInput;
  source?: InputMaybe<Scalars['String']['input']>;
  taxLines?: InputMaybe<Array<OrderCreateTaxLineInput>>;
  title: Scalars['String']['input'];
};

export type OrderCreateTaxLineInput = {
  channelLiable?: InputMaybe<Scalars['Boolean']['input']>;
  priceSet?: InputMaybe<MoneyBagInput>;
  rate: Scalars['Decimal']['input'];
  title: Scalars['String']['input'];
};

export type OrderCreateUpsertCustomerAttributesInput = {
  addresses?: InputMaybe<Array<OrderCreateCustomerAddressInput>>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  multipassIdentifier?: InputMaybe<Scalars['String']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  taxExempt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type OrderCreateUserError = DisplayableError & {
  code?: Maybe<OrderCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const OrderCreateUserErrorCode = {
  FulfillmentServiceInvalid: 'FULFILLMENT_SERVICE_INVALID',
  Invalid: 'INVALID',
  InventoryClaimFailed: 'INVENTORY_CLAIM_FAILED',
  ProcessedAtInvalid: 'PROCESSED_AT_INVALID',
  RedundantCustomerFields: 'REDUNDANT_CUSTOMER_FIELDS',
  ShopDormant: 'SHOP_DORMANT',
  TaxLineRateMissing: 'TAX_LINE_RATE_MISSING'
} as const;

export type OrderCreateUserErrorCode = typeof OrderCreateUserErrorCode[keyof typeof OrderCreateUserErrorCode];
export type OrderDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<OrderDeleteUserError>;
};

export type OrderDeleteUserError = DisplayableError & {
  code?: Maybe<OrderDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const OrderDeleteUserErrorCode = {
  Invalid: 'INVALID',
  NotFound: 'NOT_FOUND'
} as const;

export type OrderDeleteUserErrorCode = typeof OrderDeleteUserErrorCode[keyof typeof OrderDeleteUserErrorCode];
export const OrderDisplayFinancialStatus = {
  Authorized: 'AUTHORIZED',
  Expired: 'EXPIRED',
  Paid: 'PAID',
  PartiallyPaid: 'PARTIALLY_PAID',
  PartiallyRefunded: 'PARTIALLY_REFUNDED',
  Pending: 'PENDING',
  Refunded: 'REFUNDED',
  Voided: 'VOIDED'
} as const;

export type OrderDisplayFinancialStatus = typeof OrderDisplayFinancialStatus[keyof typeof OrderDisplayFinancialStatus];
export const OrderDisplayFulfillmentStatus = {
  Fulfilled: 'FULFILLED',
  InProgress: 'IN_PROGRESS',
  OnHold: 'ON_HOLD',
  Open: 'OPEN',
  PartiallyFulfilled: 'PARTIALLY_FULFILLED',
  PendingFulfillment: 'PENDING_FULFILLMENT',
  RequestDeclined: 'REQUEST_DECLINED',
  Restocked: 'RESTOCKED',
  Scheduled: 'SCHEDULED',
  Unfulfilled: 'UNFULFILLED'
} as const;

export type OrderDisplayFulfillmentStatus = typeof OrderDisplayFulfillmentStatus[keyof typeof OrderDisplayFulfillmentStatus];
export type OrderDisputeSummary = Node & {
  id: Scalars['ID']['output'];
  initiatedAs: DisputeType;
  status: DisputeStatus;
};

export type OrderEdge = {
  cursor: Scalars['String']['output'];
  node: Order;
};

export type OrderEditAddCustomItemPayload = {
  calculatedLineItem?: Maybe<CalculatedLineItem>;
  calculatedOrder?: Maybe<CalculatedOrder>;
  userErrors: Array<UserError>;
};

export type OrderEditAddLineItemDiscountPayload = {
  addedDiscountStagedChange?: Maybe<OrderStagedChangeAddLineItemDiscount>;
  calculatedLineItem?: Maybe<CalculatedLineItem>;
  calculatedOrder?: Maybe<CalculatedOrder>;
  userErrors: Array<UserError>;
};

export type OrderEditAddShippingLineInput = {
  price: MoneyInput;
  title: Scalars['String']['input'];
};

export type OrderEditAddShippingLinePayload = {
  calculatedOrder?: Maybe<CalculatedOrder>;
  calculatedShippingLine?: Maybe<CalculatedShippingLine>;
  userErrors: Array<OrderEditAddShippingLineUserError>;
};

export type OrderEditAddShippingLineUserError = DisplayableError & {
  code?: Maybe<OrderEditAddShippingLineUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const OrderEditAddShippingLineUserErrorCode = {
  Invalid: 'INVALID'
} as const;

export type OrderEditAddShippingLineUserErrorCode = typeof OrderEditAddShippingLineUserErrorCode[keyof typeof OrderEditAddShippingLineUserErrorCode];
export type OrderEditAddVariantPayload = {
  calculatedLineItem?: Maybe<CalculatedLineItem>;
  calculatedOrder?: Maybe<CalculatedOrder>;
  userErrors: Array<UserError>;
};

export type OrderEditAgreement = SalesAgreement & {
  app?: Maybe<App>;
  happenedAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  reason: OrderActionType;
  sales: SaleConnection;
  user?: Maybe<StaffMember>;
};


export type OrderEditAgreementSalesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type OrderEditAppliedDiscountInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  fixedValue?: InputMaybe<MoneyInput>;
  percentValue?: InputMaybe<Scalars['Float']['input']>;
};

export type OrderEditBeginPayload = {
  calculatedOrder?: Maybe<CalculatedOrder>;
  userErrors: Array<UserError>;
};

export type OrderEditCommitPayload = {
  order?: Maybe<Order>;
  userErrors: Array<UserError>;
};

export type OrderEditRemoveDiscountPayload = {
  calculatedOrder?: Maybe<CalculatedOrder>;
  userErrors: Array<OrderEditRemoveDiscountUserError>;
};

export type OrderEditRemoveDiscountUserError = DisplayableError & {
  code?: Maybe<OrderEditRemoveDiscountUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const OrderEditRemoveDiscountUserErrorCode = {
  Invalid: 'INVALID'
} as const;

export type OrderEditRemoveDiscountUserErrorCode = typeof OrderEditRemoveDiscountUserErrorCode[keyof typeof OrderEditRemoveDiscountUserErrorCode];
export type OrderEditRemoveLineItemDiscountPayload = {
  calculatedLineItem?: Maybe<CalculatedLineItem>;
  calculatedOrder?: Maybe<CalculatedOrder>;
  userErrors: Array<UserError>;
};

export type OrderEditRemoveShippingLinePayload = {
  calculatedOrder?: Maybe<CalculatedOrder>;
  userErrors: Array<OrderEditRemoveShippingLineUserError>;
};

export type OrderEditRemoveShippingLineUserError = DisplayableError & {
  code?: Maybe<OrderEditRemoveShippingLineUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const OrderEditRemoveShippingLineUserErrorCode = {
  Invalid: 'INVALID'
} as const;

export type OrderEditRemoveShippingLineUserErrorCode = typeof OrderEditRemoveShippingLineUserErrorCode[keyof typeof OrderEditRemoveShippingLineUserErrorCode];
export type OrderEditSetQuantityPayload = {
  calculatedLineItem?: Maybe<CalculatedLineItem>;
  calculatedOrder?: Maybe<CalculatedOrder>;
  userErrors: Array<UserError>;
};

export type OrderEditUpdateDiscountPayload = {
  calculatedOrder?: Maybe<CalculatedOrder>;
  userErrors: Array<OrderEditUpdateDiscountUserError>;
};

export type OrderEditUpdateDiscountUserError = DisplayableError & {
  code?: Maybe<OrderEditUpdateDiscountUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const OrderEditUpdateDiscountUserErrorCode = {
  Invalid: 'INVALID'
} as const;

export type OrderEditUpdateDiscountUserErrorCode = typeof OrderEditUpdateDiscountUserErrorCode[keyof typeof OrderEditUpdateDiscountUserErrorCode];
export type OrderEditUpdateShippingLineInput = {
  price?: InputMaybe<MoneyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type OrderEditUpdateShippingLinePayload = {
  calculatedOrder?: Maybe<CalculatedOrder>;
  userErrors: Array<OrderEditUpdateShippingLineUserError>;
};

export type OrderEditUpdateShippingLineUserError = DisplayableError & {
  code?: Maybe<OrderEditUpdateShippingLineUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const OrderEditUpdateShippingLineUserErrorCode = {
  Invalid: 'INVALID'
} as const;

export type OrderEditUpdateShippingLineUserErrorCode = typeof OrderEditUpdateShippingLineUserErrorCode[keyof typeof OrderEditUpdateShippingLineUserErrorCode];
export type OrderInput = {
  customAttributes?: InputMaybe<Array<AttributeInput>>;
  email?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  localizedFields?: InputMaybe<Array<LocalizedFieldInput>>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  note?: InputMaybe<Scalars['String']['input']>;
  poNumber?: InputMaybe<Scalars['String']['input']>;
  shippingAddress?: InputMaybe<MailingAddressInput>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type OrderInvoiceSendPayload = {
  order?: Maybe<Order>;
  userErrors: Array<OrderInvoiceSendUserError>;
};

export type OrderInvoiceSendUserError = DisplayableError & {
  code?: Maybe<OrderInvoiceSendUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const OrderInvoiceSendUserErrorCode = {
  OrderInvoiceSendUnsuccessful: 'ORDER_INVOICE_SEND_UNSUCCESSFUL'
} as const;

export type OrderInvoiceSendUserErrorCode = typeof OrderInvoiceSendUserErrorCode[keyof typeof OrderInvoiceSendUserErrorCode];
export type OrderMarkAsPaidInput = {
  id: Scalars['ID']['input'];
};

export type OrderMarkAsPaidPayload = {
  order?: Maybe<Order>;
  userErrors: Array<UserError>;
};

export type OrderOpenInput = {
  id: Scalars['ID']['input'];
};

export type OrderOpenPayload = {
  order?: Maybe<Order>;
  userErrors: Array<UserError>;
};

export type OrderPaymentCollectionDetails = {
  additionalPaymentCollectionUrl?: Maybe<Scalars['URL']['output']>;
  vaultedPaymentMethods?: Maybe<Array<PaymentMandate>>;
};

export type OrderPaymentStatus = {
  errorMessage?: Maybe<Scalars['String']['output']>;
  paymentReferenceId: Scalars['String']['output'];
  status: OrderPaymentStatusResult;
  transactions: Array<OrderTransaction>;
  translatedErrorMessage?: Maybe<Scalars['String']['output']>;
};

export const OrderPaymentStatusResult = {
  Authorized: 'AUTHORIZED',
  Captured: 'CAPTURED',
  Error: 'ERROR',
  Initiated: 'INITIATED',
  Pending: 'PENDING',
  Processing: 'PROCESSING',
  Purchased: 'PURCHASED',
  RedirectRequired: 'REDIRECT_REQUIRED',
  Refunded: 'REFUNDED',
  Retryable: 'RETRYABLE',
  Success: 'SUCCESS',
  Unknown: 'UNKNOWN',
  Voided: 'VOIDED'
} as const;

export type OrderPaymentStatusResult = typeof OrderPaymentStatusResult[keyof typeof OrderPaymentStatusResult];
export const OrderReturnStatus = {
  InspectionComplete: 'INSPECTION_COMPLETE',
  InProgress: 'IN_PROGRESS',
  NoReturn: 'NO_RETURN',
  Returned: 'RETURNED',
  ReturnFailed: 'RETURN_FAILED',
  ReturnRequested: 'RETURN_REQUESTED'
} as const;

export type OrderReturnStatus = typeof OrderReturnStatus[keyof typeof OrderReturnStatus];
export type OrderRisk = {
  /** @deprecated This field is deprecated in version 2024-04 */
  display: Scalars['Boolean']['output'];
  /** @deprecated This field is deprecated in version 2024-04. Please use OrderRiskAssessment.riskLevel */
  level?: Maybe<OrderRiskLevel>;
  /** @deprecated This field is deprecated in version 2024-04 */
  message?: Maybe<Scalars['String']['output']>;
};

export type OrderRiskAssessment = {
  facts: Array<RiskFact>;
  provider?: Maybe<App>;
  riskLevel: RiskAssessmentResult;
};

export type OrderRiskAssessmentCreateInput = {
  facts: Array<OrderRiskAssessmentFactInput>;
  orderId: Scalars['ID']['input'];
  riskLevel: RiskAssessmentResult;
};

export type OrderRiskAssessmentCreatePayload = {
  orderRiskAssessment?: Maybe<OrderRiskAssessment>;
  userErrors: Array<OrderRiskAssessmentCreateUserError>;
};

export type OrderRiskAssessmentCreateUserError = DisplayableError & {
  code?: Maybe<OrderRiskAssessmentCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const OrderRiskAssessmentCreateUserErrorCode = {
  Invalid: 'INVALID',
  NotFound: 'NOT_FOUND',
  OrderAlreadyFulfilled: 'ORDER_ALREADY_FULFILLED',
  TooManyFacts: 'TOO_MANY_FACTS'
} as const;

export type OrderRiskAssessmentCreateUserErrorCode = typeof OrderRiskAssessmentCreateUserErrorCode[keyof typeof OrderRiskAssessmentCreateUserErrorCode];
export type OrderRiskAssessmentFactInput = {
  description: Scalars['String']['input'];
  sentiment: RiskFactSentiment;
};

export const OrderRiskLevel = {
  High: 'HIGH',
  Low: 'LOW',
  Medium: 'MEDIUM'
} as const;

export type OrderRiskLevel = typeof OrderRiskLevel[keyof typeof OrderRiskLevel];
export const OrderRiskRecommendationResult = {
  Accept: 'ACCEPT',
  Cancel: 'CANCEL',
  Investigate: 'INVESTIGATE',
  None: 'NONE'
} as const;

export type OrderRiskRecommendationResult = typeof OrderRiskRecommendationResult[keyof typeof OrderRiskRecommendationResult];
export type OrderRiskSummary = {
  assessments: Array<OrderRiskAssessment>;
  recommendation: OrderRiskRecommendationResult;
};

export const OrderSortKeys = {
  CreatedAt: 'CREATED_AT',
  CustomerName: 'CUSTOMER_NAME',
  Destination: 'DESTINATION',
  FinancialStatus: 'FINANCIAL_STATUS',
  FulfillmentStatus: 'FULFILLMENT_STATUS',
  Id: 'ID',
  OrderNumber: 'ORDER_NUMBER',
  PoNumber: 'PO_NUMBER',
  ProcessedAt: 'PROCESSED_AT',
  Relevance: 'RELEVANCE',
  TotalItemsQuantity: 'TOTAL_ITEMS_QUANTITY',
  TotalPrice: 'TOTAL_PRICE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type OrderSortKeys = typeof OrderSortKeys[keyof typeof OrderSortKeys];
export type OrderStagedChange = OrderStagedChangeAddCustomItem | OrderStagedChangeAddLineItemDiscount | OrderStagedChangeAddShippingLine | OrderStagedChangeAddVariant | OrderStagedChangeDecrementItem | OrderStagedChangeIncrementItem | OrderStagedChangeRemoveShippingLine;

export type OrderStagedChangeAddCustomItem = {
  originalUnitPrice: MoneyV2;
  quantity: Scalars['Int']['output'];
  title: Scalars['String']['output'];
};

export type OrderStagedChangeAddLineItemDiscount = {
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  value: PricingValue;
};

export type OrderStagedChangeAddShippingLine = {
  phone?: Maybe<Scalars['String']['output']>;
  presentmentTitle?: Maybe<Scalars['String']['output']>;
  price: MoneyV2;
  title?: Maybe<Scalars['String']['output']>;
};

export type OrderStagedChangeAddVariant = {
  quantity: Scalars['Int']['output'];
  variant: ProductVariant;
};

export type OrderStagedChangeConnection = {
  edges: Array<OrderStagedChangeEdge>;
  nodes: Array<OrderStagedChange>;
  pageInfo: PageInfo;
};

export type OrderStagedChangeDecrementItem = {
  delta: Scalars['Int']['output'];
  lineItem: LineItem;
  restock: Scalars['Boolean']['output'];
};

export type OrderStagedChangeEdge = {
  cursor: Scalars['String']['output'];
  node: OrderStagedChange;
};

export type OrderStagedChangeIncrementItem = {
  delta: Scalars['Int']['output'];
  lineItem: LineItem;
};

export type OrderStagedChangeRemoveShippingLine = {
  shippingLine: ShippingLine;
};

export type OrderTransaction = Node & {
  accountNumber?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use `amountSet` instead. */
  amount: Scalars['Money']['output'];
  amountRoundingSet?: Maybe<MoneyBag>;
  amountSet: MoneyBag;
  /** @deprecated Use `amountSet` instead. */
  amountV2: MoneyV2;
  authorizationCode?: Maybe<Scalars['String']['output']>;
  authorizationExpiresAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  errorCode?: Maybe<OrderTransactionErrorCode>;
  fees: Array<TransactionFee>;
  formattedGateway?: Maybe<Scalars['String']['output']>;
  gateway?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  kind: OrderTransactionKind;
  manualPaymentGateway: Scalars['Boolean']['output'];
  manuallyCapturable: Scalars['Boolean']['output'];
  /** @deprecated Use `maximumRefundableV2` instead. */
  maximumRefundable?: Maybe<Scalars['Money']['output']>;
  maximumRefundableV2?: Maybe<MoneyV2>;
  multiCapturable: Scalars['Boolean']['output'];
  order?: Maybe<Order>;
  parentTransaction?: Maybe<OrderTransaction>;
  paymentDetails?: Maybe<PaymentDetails>;
  paymentIcon?: Maybe<Image>;
  paymentId?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use `paymentIcon` instead. */
  paymentMethod?: Maybe<PaymentMethods>;
  processedAt?: Maybe<Scalars['DateTime']['output']>;
  receiptJson?: Maybe<Scalars['JSON']['output']>;
  settlementCurrency?: Maybe<CurrencyCode>;
  settlementCurrencyRate?: Maybe<Scalars['Decimal']['output']>;
  shopifyPaymentsSet?: Maybe<ShopifyPaymentsTransactionSet>;
  status: OrderTransactionStatus;
  test: Scalars['Boolean']['output'];
  /** @deprecated Use `totalUnsettledSet` instead. */
  totalUnsettled?: Maybe<Scalars['Money']['output']>;
  totalUnsettledSet?: Maybe<MoneyBag>;
  /** @deprecated Use `totalUnsettledSet` instead. */
  totalUnsettledV2?: Maybe<MoneyV2>;
  user?: Maybe<StaffMember>;
};

export type OrderTransactionConnection = {
  edges: Array<OrderTransactionEdge>;
  nodes: Array<OrderTransaction>;
  pageInfo: PageInfo;
};

export type OrderTransactionEdge = {
  cursor: Scalars['String']['output'];
  node: OrderTransaction;
};

export const OrderTransactionErrorCode = {
  AmazonPaymentsInvalidPaymentMethod: 'AMAZON_PAYMENTS_INVALID_PAYMENT_METHOD',
  AmazonPaymentsMaxAmountCharged: 'AMAZON_PAYMENTS_MAX_AMOUNT_CHARGED',
  AmazonPaymentsMaxAmountRefunded: 'AMAZON_PAYMENTS_MAX_AMOUNT_REFUNDED',
  AmazonPaymentsMaxAuthorizationsCaptured: 'AMAZON_PAYMENTS_MAX_AUTHORIZATIONS_CAPTURED',
  AmazonPaymentsMaxRefundsProcessed: 'AMAZON_PAYMENTS_MAX_REFUNDS_PROCESSED',
  AmazonPaymentsOrderReferenceCanceled: 'AMAZON_PAYMENTS_ORDER_REFERENCE_CANCELED',
  AmazonPaymentsStale: 'AMAZON_PAYMENTS_STALE',
  CallIssuer: 'CALL_ISSUER',
  CardDeclined: 'CARD_DECLINED',
  ConfigError: 'CONFIG_ERROR',
  ExpiredCard: 'EXPIRED_CARD',
  GenericError: 'GENERIC_ERROR',
  IncorrectAddress: 'INCORRECT_ADDRESS',
  IncorrectCvc: 'INCORRECT_CVC',
  IncorrectNumber: 'INCORRECT_NUMBER',
  IncorrectPin: 'INCORRECT_PIN',
  IncorrectZip: 'INCORRECT_ZIP',
  InvalidAmount: 'INVALID_AMOUNT',
  InvalidCountry: 'INVALID_COUNTRY',
  InvalidCvc: 'INVALID_CVC',
  InvalidExpiryDate: 'INVALID_EXPIRY_DATE',
  InvalidNumber: 'INVALID_NUMBER',
  PaymentMethodUnavailable: 'PAYMENT_METHOD_UNAVAILABLE',
  PickUpCard: 'PICK_UP_CARD',
  ProcessingError: 'PROCESSING_ERROR',
  TestModeLiveCard: 'TEST_MODE_LIVE_CARD',
  UnsupportedFeature: 'UNSUPPORTED_FEATURE'
} as const;

export type OrderTransactionErrorCode = typeof OrderTransactionErrorCode[keyof typeof OrderTransactionErrorCode];
export type OrderTransactionInput = {
  amount: Scalars['Money']['input'];
  gateway: Scalars['String']['input'];
  kind: OrderTransactionKind;
  orderId: Scalars['ID']['input'];
  parentId?: InputMaybe<Scalars['ID']['input']>;
};

export const OrderTransactionKind = {
  Authorization: 'AUTHORIZATION',
  Capture: 'CAPTURE',
  Change: 'CHANGE',
  EmvAuthorization: 'EMV_AUTHORIZATION',
  Refund: 'REFUND',
  Sale: 'SALE',
  SuggestedRefund: 'SUGGESTED_REFUND',
  Void: 'VOID'
} as const;

export type OrderTransactionKind = typeof OrderTransactionKind[keyof typeof OrderTransactionKind];
export const OrderTransactionStatus = {
  AwaitingResponse: 'AWAITING_RESPONSE',
  Error: 'ERROR',
  Failure: 'FAILURE',
  Pending: 'PENDING',
  Success: 'SUCCESS',
  Unknown: 'UNKNOWN'
} as const;

export type OrderTransactionStatus = typeof OrderTransactionStatus[keyof typeof OrderTransactionStatus];
export type OrderUpdatePayload = {
  order?: Maybe<Order>;
  userErrors: Array<UserError>;
};

export type Page = HasEvents & HasMetafieldDefinitions & HasMetafields & HasPublishedTranslations & Navigable & Node & {
  body: Scalars['HTML']['output'];
  bodySummary: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  defaultCursor: Scalars['String']['output'];
  events: EventConnection;
  handle: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isPublished: Scalars['Boolean']['output'];
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  templateSuffix?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  translations: Array<Translation>;
  updatedAt: Scalars['DateTime']['output'];
};


export type PageEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type PageMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type PageMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type PageMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PageTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export type PageConnection = {
  edges: Array<PageEdge>;
  nodes: Array<Page>;
  pageInfo: PageInfo;
};

export type PageCreateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  publishDate?: InputMaybe<Scalars['DateTime']['input']>;
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
  title: Scalars['String']['input'];
};

export type PageCreatePayload = {
  page?: Maybe<Page>;
  userErrors: Array<PageCreateUserError>;
};

export type PageCreateUserError = DisplayableError & {
  code?: Maybe<PageCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PageCreateUserErrorCode = {
  Blank: 'BLANK',
  InvalidPublishDate: 'INVALID_PUBLISH_DATE',
  InvalidType: 'INVALID_TYPE',
  InvalidValue: 'INVALID_VALUE',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG'
} as const;

export type PageCreateUserErrorCode = typeof PageCreateUserErrorCode[keyof typeof PageCreateUserErrorCode];
export type PageDeletePayload = {
  deletedPageId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<PageDeleteUserError>;
};

export type PageDeleteUserError = DisplayableError & {
  code?: Maybe<PageDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PageDeleteUserErrorCode = {
  NotFound: 'NOT_FOUND'
} as const;

export type PageDeleteUserErrorCode = typeof PageDeleteUserErrorCode[keyof typeof PageDeleteUserErrorCode];
export type PageEdge = {
  cursor: Scalars['String']['output'];
  node: Page;
};

export type PageInfo = {
  endCursor?: Maybe<Scalars['String']['output']>;
  hasNextPage: Scalars['Boolean']['output'];
  hasPreviousPage: Scalars['Boolean']['output'];
  startCursor?: Maybe<Scalars['String']['output']>;
};

export type PageUpdateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  publishDate?: InputMaybe<Scalars['DateTime']['input']>;
  redirectNewHandle?: InputMaybe<Scalars['Boolean']['input']>;
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type PageUpdatePayload = {
  page?: Maybe<Page>;
  userErrors: Array<PageUpdateUserError>;
};

export type PageUpdateUserError = DisplayableError & {
  code?: Maybe<PageUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PageUpdateUserErrorCode = {
  Blank: 'BLANK',
  InvalidPublishDate: 'INVALID_PUBLISH_DATE',
  NotFound: 'NOT_FOUND',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG'
} as const;

export type PageUpdateUserErrorCode = typeof PageUpdateUserErrorCode[keyof typeof PageUpdateUserErrorCode];
export type PaymentCustomization = HasMetafieldDefinitions & HasMetafields & Node & {
  enabled: Scalars['Boolean']['output'];
  errorHistory?: Maybe<FunctionsErrorHistory>;
  functionId: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  shopifyFunction: ShopifyFunction;
  title: Scalars['String']['output'];
};


export type PaymentCustomizationMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type PaymentCustomizationMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type PaymentCustomizationMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PaymentCustomizationActivationPayload = {
  ids?: Maybe<Array<Scalars['String']['output']>>;
  userErrors: Array<PaymentCustomizationError>;
};

export type PaymentCustomizationConnection = {
  edges: Array<PaymentCustomizationEdge>;
  nodes: Array<PaymentCustomization>;
  pageInfo: PageInfo;
};

export type PaymentCustomizationCreatePayload = {
  paymentCustomization?: Maybe<PaymentCustomization>;
  userErrors: Array<PaymentCustomizationError>;
};

export type PaymentCustomizationDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<PaymentCustomizationError>;
};

export type PaymentCustomizationEdge = {
  cursor: Scalars['String']['output'];
  node: PaymentCustomization;
};

export type PaymentCustomizationError = DisplayableError & {
  code?: Maybe<PaymentCustomizationErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PaymentCustomizationErrorCode = {
  CustomAppFunctionNotEligible: 'CUSTOM_APP_FUNCTION_NOT_ELIGIBLE',
  FunctionDoesNotImplement: 'FUNCTION_DOES_NOT_IMPLEMENT',
  FunctionIdCannotBeChanged: 'FUNCTION_ID_CANNOT_BE_CHANGED',
  FunctionNotFound: 'FUNCTION_NOT_FOUND',
  FunctionPendingDeletion: 'FUNCTION_PENDING_DELETION',
  Invalid: 'INVALID',
  InvalidMetafields: 'INVALID_METAFIELDS',
  MaximumActivePaymentCustomizations: 'MAXIMUM_ACTIVE_PAYMENT_CUSTOMIZATIONS',
  PaymentCustomizationFunctionNotEligible: 'PAYMENT_CUSTOMIZATION_FUNCTION_NOT_ELIGIBLE',
  PaymentCustomizationNotFound: 'PAYMENT_CUSTOMIZATION_NOT_FOUND',
  RequiredInputField: 'REQUIRED_INPUT_FIELD'
} as const;

export type PaymentCustomizationErrorCode = typeof PaymentCustomizationErrorCode[keyof typeof PaymentCustomizationErrorCode];
export type PaymentCustomizationInput = {
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  functionId?: InputMaybe<Scalars['String']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type PaymentCustomizationUpdatePayload = {
  paymentCustomization?: Maybe<PaymentCustomization>;
  userErrors: Array<PaymentCustomizationError>;
};

export type PaymentDetails = CardPaymentDetails | LocalPaymentMethodsPaymentDetails | ShopPayInstallmentsPaymentDetails;

export type PaymentInstrument = VaultCreditCard | VaultPaypalBillingAgreement;

export type PaymentMandate = Node & {
  id: Scalars['ID']['output'];
  paymentInstrument: PaymentInstrument;
};

export const PaymentMethods = {
  AmericanExpress: 'AMERICAN_EXPRESS',
  Bitcoin: 'BITCOIN',
  Bogus: 'BOGUS',
  Dankort: 'DANKORT',
  DinersClub: 'DINERS_CLUB',
  Discover: 'DISCOVER',
  Dogecoin: 'DOGECOIN',
  Eftpos: 'EFTPOS',
  Elo: 'ELO',
  Forbrugsforeningen: 'FORBRUGSFORENINGEN',
  Interac: 'INTERAC',
  Jcb: 'JCB',
  Litecoin: 'LITECOIN',
  Maestro: 'MAESTRO',
  Mastercard: 'MASTERCARD',
  Paypal: 'PAYPAL',
  Unionpay: 'UNIONPAY',
  Visa: 'VISA'
} as const;

export type PaymentMethods = typeof PaymentMethods[keyof typeof PaymentMethods];
export type PaymentReminderSendPayload = {
  success?: Maybe<Scalars['Boolean']['output']>;
  userErrors: Array<PaymentReminderSendUserError>;
};

export type PaymentReminderSendUserError = DisplayableError & {
  code?: Maybe<PaymentReminderSendUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PaymentReminderSendUserErrorCode = {
  PaymentReminderSendUnsuccessful: 'PAYMENT_REMINDER_SEND_UNSUCCESSFUL'
} as const;

export type PaymentReminderSendUserErrorCode = typeof PaymentReminderSendUserErrorCode[keyof typeof PaymentReminderSendUserErrorCode];
export type PaymentSchedule = Node & {
  /** @deprecated Use `balanceDue`, `totalBalance`, or `Order.totalOutstandingSet` instead. */
  amount: MoneyV2;
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  dueAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  issuedAt?: Maybe<Scalars['DateTime']['output']>;
  paymentTerms: PaymentTerms;
};

export type PaymentScheduleConnection = {
  edges: Array<PaymentScheduleEdge>;
  nodes: Array<PaymentSchedule>;
  pageInfo: PageInfo;
};

export type PaymentScheduleEdge = {
  cursor: Scalars['String']['output'];
  node: PaymentSchedule;
};

export type PaymentScheduleInput = {
  dueAt?: InputMaybe<Scalars['DateTime']['input']>;
  issuedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PaymentSettings = {
  supportedDigitalWallets: Array<DigitalWallet>;
};

export type PaymentTerms = Node & {
  draftOrder?: Maybe<DraftOrder>;
  dueInDays?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  order?: Maybe<Order>;
  overdue: Scalars['Boolean']['output'];
  paymentSchedules: PaymentScheduleConnection;
  paymentTermsName: Scalars['String']['output'];
  paymentTermsType: PaymentTermsType;
  translatedName: Scalars['String']['output'];
};


export type PaymentTermsPaymentSchedulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PaymentTermsCreateInput = {
  paymentSchedules?: InputMaybe<Array<PaymentScheduleInput>>;
  paymentTermsTemplateId: Scalars['ID']['input'];
};

export type PaymentTermsCreatePayload = {
  paymentTerms?: Maybe<PaymentTerms>;
  userErrors: Array<PaymentTermsCreateUserError>;
};

export type PaymentTermsCreateUserError = DisplayableError & {
  code?: Maybe<PaymentTermsCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PaymentTermsCreateUserErrorCode = {
  PaymentTermsCreationUnsuccessful: 'PAYMENT_TERMS_CREATION_UNSUCCESSFUL'
} as const;

export type PaymentTermsCreateUserErrorCode = typeof PaymentTermsCreateUserErrorCode[keyof typeof PaymentTermsCreateUserErrorCode];
export type PaymentTermsDeleteInput = {
  paymentTermsId: Scalars['ID']['input'];
};

export type PaymentTermsDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<PaymentTermsDeleteUserError>;
};

export type PaymentTermsDeleteUserError = DisplayableError & {
  code?: Maybe<PaymentTermsDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PaymentTermsDeleteUserErrorCode = {
  PaymentTermsDeleteUnsuccessful: 'PAYMENT_TERMS_DELETE_UNSUCCESSFUL'
} as const;

export type PaymentTermsDeleteUserErrorCode = typeof PaymentTermsDeleteUserErrorCode[keyof typeof PaymentTermsDeleteUserErrorCode];
export type PaymentTermsInput = {
  paymentSchedules?: InputMaybe<Array<PaymentScheduleInput>>;
  paymentTermsTemplateId?: InputMaybe<Scalars['ID']['input']>;
};

export type PaymentTermsTemplate = Node & {
  description: Scalars['String']['output'];
  dueInDays?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  paymentTermsType: PaymentTermsType;
  translatedName: Scalars['String']['output'];
};

export const PaymentTermsType = {
  Fixed: 'FIXED',
  Fulfillment: 'FULFILLMENT',
  Net: 'NET',
  Receipt: 'RECEIPT',
  Unknown: 'UNKNOWN'
} as const;

export type PaymentTermsType = typeof PaymentTermsType[keyof typeof PaymentTermsType];
export type PaymentTermsUpdateInput = {
  paymentTermsAttributes: PaymentTermsInput;
  paymentTermsId: Scalars['ID']['input'];
};

export type PaymentTermsUpdatePayload = {
  paymentTerms?: Maybe<PaymentTerms>;
  userErrors: Array<PaymentTermsUpdateUserError>;
};

export type PaymentTermsUpdateUserError = DisplayableError & {
  code?: Maybe<PaymentTermsUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PaymentTermsUpdateUserErrorCode = {
  PaymentTermsUpdateUnsuccessful: 'PAYMENT_TERMS_UPDATE_UNSUCCESSFUL'
} as const;

export type PaymentTermsUpdateUserErrorCode = typeof PaymentTermsUpdateUserErrorCode[keyof typeof PaymentTermsUpdateUserErrorCode];
export const PayoutSortKeys = {
  AdjustmentGross: 'ADJUSTMENT_GROSS',
  AdvanceGross: 'ADVANCE_GROSS',
  Amount: 'AMOUNT',
  ChargeGross: 'CHARGE_GROSS',
  DutiesGross: 'DUTIES_GROSS',
  FeeAmount: 'FEE_AMOUNT',
  Id: 'ID',
  IssuedAt: 'ISSUED_AT',
  RefundGross: 'REFUND_GROSS',
  Relevance: 'RELEVANCE',
  ShippingLabelGross: 'SHIPPING_LABEL_GROSS',
  Status: 'STATUS'
} as const;

export type PayoutSortKeys = typeof PayoutSortKeys[keyof typeof PayoutSortKeys];
export const PaypalExpressSubscriptionsGatewayStatus = {
  Disabled: 'DISABLED',
  Enabled: 'ENABLED',
  Pending: 'PENDING'
} as const;

export type PaypalExpressSubscriptionsGatewayStatus = typeof PaypalExpressSubscriptionsGatewayStatus[keyof typeof PaypalExpressSubscriptionsGatewayStatus];
export type PreparedFulfillmentOrderLineItemsInput = {
  fulfillmentOrderId: Scalars['ID']['input'];
};

export const PriceCalculationType = {
  ComponentsSum: 'COMPONENTS_SUM',
  Fixed: 'FIXED',
  None: 'NONE'
} as const;

export type PriceCalculationType = typeof PriceCalculationType[keyof typeof PriceCalculationType];
export type PriceInput = {
  calculation?: InputMaybe<PriceCalculationType>;
  price?: InputMaybe<Scalars['Money']['input']>;
};

export type PriceList = Node & {
  catalog?: Maybe<Catalog>;
  currency: CurrencyCode;
  fixedPricesCount: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  parent?: Maybe<PriceListParent>;
  prices: PriceListPriceConnection;
  quantityRules: QuantityRuleConnection;
};


export type PriceListPricesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  originType?: InputMaybe<PriceListPriceOriginType>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PriceListQuantityRulesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  originType?: InputMaybe<QuantityRuleOriginType>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PriceListAdjustment = {
  type: PriceListAdjustmentType;
  value: Scalars['Float']['output'];
};

export type PriceListAdjustmentInput = {
  type: PriceListAdjustmentType;
  value: Scalars['Float']['input'];
};

export type PriceListAdjustmentSettings = {
  compareAtMode: PriceListCompareAtMode;
};

export type PriceListAdjustmentSettingsInput = {
  compareAtMode?: PriceListCompareAtMode;
};

export const PriceListAdjustmentType = {
  PercentageDecrease: 'PERCENTAGE_DECREASE',
  PercentageIncrease: 'PERCENTAGE_INCREASE'
} as const;

export type PriceListAdjustmentType = typeof PriceListAdjustmentType[keyof typeof PriceListAdjustmentType];
export const PriceListCompareAtMode = {
  Adjusted: 'ADJUSTED',
  Nullify: 'NULLIFY'
} as const;

export type PriceListCompareAtMode = typeof PriceListCompareAtMode[keyof typeof PriceListCompareAtMode];
export type PriceListConnection = {
  edges: Array<PriceListEdge>;
  nodes: Array<PriceList>;
  pageInfo: PageInfo;
};

export type PriceListCreateInput = {
  catalogId?: InputMaybe<Scalars['ID']['input']>;
  currency: CurrencyCode;
  name: Scalars['String']['input'];
  parent: PriceListParentCreateInput;
};

export type PriceListCreatePayload = {
  priceList?: Maybe<PriceList>;
  userErrors: Array<PriceListUserError>;
};

export type PriceListDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<PriceListUserError>;
};

export type PriceListEdge = {
  cursor: Scalars['String']['output'];
  node: PriceList;
};

export type PriceListFixedPricesAddPayload = {
  prices?: Maybe<Array<PriceListPrice>>;
  userErrors: Array<PriceListPriceUserError>;
};

export type PriceListFixedPricesByProductBulkUpdateUserError = DisplayableError & {
  code?: Maybe<PriceListFixedPricesByProductBulkUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PriceListFixedPricesByProductBulkUpdateUserErrorCode = {
  DuplicateIdInInput: 'DUPLICATE_ID_IN_INPUT',
  IdMustBeMutuallyExclusive: 'ID_MUST_BE_MUTUALLY_EXCLUSIVE',
  NoUpdateOperationsSpecified: 'NO_UPDATE_OPERATIONS_SPECIFIED',
  PricesToAddCurrencyMismatch: 'PRICES_TO_ADD_CURRENCY_MISMATCH',
  PriceLimitExceeded: 'PRICE_LIMIT_EXCEEDED',
  PriceListDoesNotExist: 'PRICE_LIST_DOES_NOT_EXIST',
  ProductDoesNotExist: 'PRODUCT_DOES_NOT_EXIST'
} as const;

export type PriceListFixedPricesByProductBulkUpdateUserErrorCode = typeof PriceListFixedPricesByProductBulkUpdateUserErrorCode[keyof typeof PriceListFixedPricesByProductBulkUpdateUserErrorCode];
export type PriceListFixedPricesByProductUpdatePayload = {
  priceList?: Maybe<PriceList>;
  pricesToAddProducts?: Maybe<Array<Product>>;
  pricesToDeleteProducts?: Maybe<Array<Product>>;
  userErrors: Array<PriceListFixedPricesByProductBulkUpdateUserError>;
};

export type PriceListFixedPricesDeletePayload = {
  deletedFixedPriceVariantIds?: Maybe<Array<Scalars['ID']['output']>>;
  userErrors: Array<PriceListPriceUserError>;
};

export type PriceListFixedPricesUpdatePayload = {
  deletedFixedPriceVariantIds?: Maybe<Array<Scalars['ID']['output']>>;
  priceList?: Maybe<PriceList>;
  pricesAdded?: Maybe<Array<PriceListPrice>>;
  userErrors: Array<PriceListPriceUserError>;
};

export type PriceListParent = {
  adjustment: PriceListAdjustment;
  settings: PriceListAdjustmentSettings;
};

export type PriceListParentCreateInput = {
  adjustment: PriceListAdjustmentInput;
  settings?: InputMaybe<PriceListAdjustmentSettingsInput>;
};

export type PriceListParentUpdateInput = {
  adjustment: PriceListAdjustmentInput;
  settings?: InputMaybe<PriceListAdjustmentSettingsInput>;
};

export type PriceListPrice = {
  compareAtPrice?: Maybe<MoneyV2>;
  originType: PriceListPriceOriginType;
  price: MoneyV2;
  quantityPriceBreaks: QuantityPriceBreakConnection;
  variant: ProductVariant;
};


export type PriceListPriceQuantityPriceBreaksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<QuantityPriceBreakSortKeys>;
};

export type PriceListPriceConnection = {
  edges: Array<PriceListPriceEdge>;
  nodes: Array<PriceListPrice>;
  pageInfo: PageInfo;
};

export type PriceListPriceEdge = {
  cursor: Scalars['String']['output'];
  node: PriceListPrice;
};

export type PriceListPriceInput = {
  compareAtPrice?: InputMaybe<MoneyInput>;
  price: MoneyInput;
  variantId: Scalars['ID']['input'];
};

export const PriceListPriceOriginType = {
  Fixed: 'FIXED',
  Relative: 'RELATIVE'
} as const;

export type PriceListPriceOriginType = typeof PriceListPriceOriginType[keyof typeof PriceListPriceOriginType];
export type PriceListPriceUserError = DisplayableError & {
  code?: Maybe<PriceListPriceUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PriceListPriceUserErrorCode = {
  Blank: 'BLANK',
  PriceListCurrencyMismatch: 'PRICE_LIST_CURRENCY_MISMATCH',
  PriceListNotFound: 'PRICE_LIST_NOT_FOUND',
  PriceNotFixed: 'PRICE_NOT_FIXED',
  VariantNotFound: 'VARIANT_NOT_FOUND'
} as const;

export type PriceListPriceUserErrorCode = typeof PriceListPriceUserErrorCode[keyof typeof PriceListPriceUserErrorCode];
export type PriceListProductPriceInput = {
  price: MoneyInput;
  productId: Scalars['ID']['input'];
};

export const PriceListSortKeys = {
  Id: 'ID',
  Name: 'NAME',
  Relevance: 'RELEVANCE'
} as const;

export type PriceListSortKeys = typeof PriceListSortKeys[keyof typeof PriceListSortKeys];
export type PriceListUpdateInput = {
  catalogId?: InputMaybe<Scalars['ID']['input']>;
  currency?: InputMaybe<CurrencyCode>;
  name?: InputMaybe<Scalars['String']['input']>;
  parent?: InputMaybe<PriceListParentUpdateInput>;
};

export type PriceListUpdatePayload = {
  priceList?: Maybe<PriceList>;
  userErrors: Array<PriceListUserError>;
};

export type PriceListUserError = DisplayableError & {
  code?: Maybe<PriceListUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PriceListUserErrorCode = {
  AppCatalogPriceListAssignment: 'APP_CATALOG_PRICE_LIST_ASSIGNMENT',
  Blank: 'BLANK',
  CatalogAssignmentNotAllowed: 'CATALOG_ASSIGNMENT_NOT_ALLOWED',
  CatalogCannotChangeContextType: 'CATALOG_CANNOT_CHANGE_CONTEXT_TYPE',
  CatalogContextDoesNotSupportQuantityPriceBreaks: 'CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_PRICE_BREAKS',
  CatalogContextDoesNotSupportQuantityRules: 'CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_RULES',
  CatalogDoesNotExist: 'CATALOG_DOES_NOT_EXIST',
  CatalogMarketAndPriceListCurrencyMismatch: 'CATALOG_MARKET_AND_PRICE_LIST_CURRENCY_MISMATCH',
  CatalogTaken: 'CATALOG_TAKEN',
  ContextRuleLimitOneOption: 'CONTEXT_RULE_LIMIT_ONE_OPTION',
  CountryPriceListAssignment: 'COUNTRY_PRICE_LIST_ASSIGNMENT',
  CurrencyMarketMismatch: 'CURRENCY_MARKET_MISMATCH',
  CurrencyNotSupported: 'CURRENCY_NOT_SUPPORTED',
  GenericError: 'GENERIC_ERROR',
  Inclusion: 'INCLUSION',
  InvalidAdjustmentMaxValue: 'INVALID_ADJUSTMENT_MAX_VALUE',
  InvalidAdjustmentMinValue: 'INVALID_ADJUSTMENT_MIN_VALUE',
  InvalidAdjustmentValue: 'INVALID_ADJUSTMENT_VALUE',
  PriceListLocked: 'PRICE_LIST_LOCKED',
  PriceListNotAllowedForPrimaryMarket: 'PRICE_LIST_NOT_ALLOWED_FOR_PRIMARY_MARKET',
  PriceListNotFound: 'PRICE_LIST_NOT_FOUND',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG'
} as const;

export type PriceListUserErrorCode = typeof PriceListUserErrorCode[keyof typeof PriceListUserErrorCode];
export type PriceRule = CommentEventSubject & HasEvents & LegacyInteroperability & Node & {
  allocationLimit?: Maybe<Scalars['Int']['output']>;
  allocationMethod: PriceRuleAllocationMethod;
  app?: Maybe<App>;
  combinesWith: DiscountCombinesWith;
  createdAt: Scalars['DateTime']['output'];
  customerSelection: PriceRuleCustomerSelection;
  discountClass: DiscountClass;
  discountCodes: PriceRuleDiscountCodeConnection;
  discountCodesCount?: Maybe<Count>;
  endsAt?: Maybe<Scalars['DateTime']['output']>;
  /** @deprecated Use `prerequisiteToEntitlementQuantityRatio` instead. */
  entitlementToPrerequisiteQuantityRatio?: Maybe<PriceRuleEntitlementToPrerequisiteQuantityRatio>;
  events: EventConnection;
  features: Array<PriceRuleFeature>;
  hasTimelineComment: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  itemEntitlements: PriceRuleItemEntitlements;
  itemPrerequisites: PriceRuleLineItemPrerequisites;
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  oncePerCustomer: Scalars['Boolean']['output'];
  prerequisiteQuantityRange?: Maybe<PriceRuleQuantityRange>;
  prerequisiteShippingPriceRange?: Maybe<PriceRuleMoneyRange>;
  prerequisiteSubtotalRange?: Maybe<PriceRuleMoneyRange>;
  prerequisiteToEntitlementQuantityRatio?: Maybe<PriceRulePrerequisiteToEntitlementQuantityRatio>;
  shareableUrls: Array<PriceRuleShareableUrl>;
  shippingEntitlements: PriceRuleShippingLineEntitlements;
  startsAt: Scalars['DateTime']['output'];
  status: PriceRuleStatus;
  summary?: Maybe<Scalars['String']['output']>;
  target: PriceRuleTarget;
  title: Scalars['String']['output'];
  totalSales?: Maybe<MoneyV2>;
  /** @deprecated Use `features` instead. */
  traits: Array<PriceRuleTrait>;
  usageCount: Scalars['Int']['output'];
  usageLimit?: Maybe<Scalars['Int']['output']>;
  validityPeriod: PriceRuleValidityPeriod;
  /** @deprecated Use `valueV2` instead. */
  value: PriceRuleValue;
  valueV2: PricingValue;
};


export type PriceRuleDiscountCodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<DiscountCodeSortKeys>;
};


export type PriceRuleEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};

export const PriceRuleAllocationMethod = {
  Across: 'ACROSS',
  Each: 'EACH'
} as const;

export type PriceRuleAllocationMethod = typeof PriceRuleAllocationMethod[keyof typeof PriceRuleAllocationMethod];
export type PriceRuleCustomerSelection = {
  customers: CustomerConnection;
  forAllCustomers: Scalars['Boolean']['output'];
  segments: Array<Segment>;
};


export type PriceRuleCustomerSelectionCustomersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<CustomerSortKeys>;
};

export type PriceRuleDiscountCode = Node & {
  app?: Maybe<App>;
  code: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  usageCount: Scalars['Int']['output'];
};

export type PriceRuleDiscountCodeConnection = {
  edges: Array<PriceRuleDiscountCodeEdge>;
  nodes: Array<PriceRuleDiscountCode>;
  pageInfo: PageInfo;
};

export type PriceRuleDiscountCodeEdge = {
  cursor: Scalars['String']['output'];
  node: PriceRuleDiscountCode;
};

export type PriceRuleEntitlementToPrerequisiteQuantityRatio = {
  entitlementQuantity: Scalars['Int']['output'];
  prerequisiteQuantity: Scalars['Int']['output'];
};

export const PriceRuleFeature = {
  Bulk: 'BULK',
  BuyOneGetOne: 'BUY_ONE_GET_ONE',
  BuyOneGetOneWithAllocationLimit: 'BUY_ONE_GET_ONE_WITH_ALLOCATION_LIMIT',
  QuantityDiscounts: 'QUANTITY_DISCOUNTS',
  SpecificCustomers: 'SPECIFIC_CUSTOMERS'
} as const;

export type PriceRuleFeature = typeof PriceRuleFeature[keyof typeof PriceRuleFeature];
export type PriceRuleFixedAmountValue = {
  amount: Scalars['Money']['output'];
};

export type PriceRuleItemEntitlements = {
  collections: CollectionConnection;
  productVariants: ProductVariantConnection;
  products: ProductConnection;
  targetAllLineItems: Scalars['Boolean']['output'];
};


export type PriceRuleItemEntitlementsCollectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PriceRuleItemEntitlementsProductVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PriceRuleItemEntitlementsProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PriceRuleLineItemPrerequisites = {
  collections: CollectionConnection;
  productVariants: ProductVariantConnection;
  products: ProductConnection;
};


export type PriceRuleLineItemPrerequisitesCollectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PriceRuleLineItemPrerequisitesProductVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PriceRuleLineItemPrerequisitesProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PriceRuleMoneyRange = {
  greaterThan?: Maybe<Scalars['Money']['output']>;
  greaterThanOrEqualTo?: Maybe<Scalars['Money']['output']>;
  lessThan?: Maybe<Scalars['Money']['output']>;
  lessThanOrEqualTo?: Maybe<Scalars['Money']['output']>;
};

export type PriceRulePercentValue = {
  percentage: Scalars['Float']['output'];
};

export type PriceRulePrerequisiteToEntitlementQuantityRatio = {
  entitlementQuantity: Scalars['Int']['output'];
  prerequisiteQuantity: Scalars['Int']['output'];
};

export type PriceRuleQuantityRange = {
  greaterThan?: Maybe<Scalars['Int']['output']>;
  greaterThanOrEqualTo?: Maybe<Scalars['Int']['output']>;
  lessThan?: Maybe<Scalars['Int']['output']>;
  lessThanOrEqualTo?: Maybe<Scalars['Int']['output']>;
};

export type PriceRuleShareableUrl = {
  targetItemImage?: Maybe<Image>;
  targetType: PriceRuleShareableUrlTargetType;
  title: Scalars['String']['output'];
  url: Scalars['URL']['output'];
};

export const PriceRuleShareableUrlTargetType = {
  Collection: 'COLLECTION',
  Home: 'HOME',
  Product: 'PRODUCT'
} as const;

export type PriceRuleShareableUrlTargetType = typeof PriceRuleShareableUrlTargetType[keyof typeof PriceRuleShareableUrlTargetType];
export type PriceRuleShippingLineEntitlements = {
  countryCodes: Array<CountryCode>;
  includeRestOfWorld: Scalars['Boolean']['output'];
  targetAllShippingLines: Scalars['Boolean']['output'];
};

export const PriceRuleStatus = {
  Active: 'ACTIVE',
  Expired: 'EXPIRED',
  Scheduled: 'SCHEDULED'
} as const;

export type PriceRuleStatus = typeof PriceRuleStatus[keyof typeof PriceRuleStatus];
export const PriceRuleTarget = {
  LineItem: 'LINE_ITEM',
  ShippingLine: 'SHIPPING_LINE'
} as const;

export type PriceRuleTarget = typeof PriceRuleTarget[keyof typeof PriceRuleTarget];
export const PriceRuleTrait = {
  Bulk: 'BULK',
  BuyOneGetOne: 'BUY_ONE_GET_ONE',
  BuyOneGetOneWithAllocationLimit: 'BUY_ONE_GET_ONE_WITH_ALLOCATION_LIMIT',
  QuantityDiscounts: 'QUANTITY_DISCOUNTS',
  SpecificCustomers: 'SPECIFIC_CUSTOMERS'
} as const;

export type PriceRuleTrait = typeof PriceRuleTrait[keyof typeof PriceRuleTrait];
export type PriceRuleValidityPeriod = {
  end?: Maybe<Scalars['DateTime']['output']>;
  start: Scalars['DateTime']['output'];
};

export type PriceRuleValue = PriceRuleFixedAmountValue | PriceRulePercentValue;

export type PricingPercentageValue = {
  percentage: Scalars['Float']['output'];
};

export type PricingValue = MoneyV2 | PricingPercentageValue;

export type Product = HasEvents & HasMetafieldDefinitions & HasMetafields & HasPublishedTranslations & LegacyInteroperability & Navigable & Node & OnlineStorePreviewable & Publishable & {
  availablePublicationsCount?: Maybe<Count>;
  /** @deprecated Use `descriptionHtml` instead. */
  bodyHtml?: Maybe<Scalars['String']['output']>;
  bundleComponents: ProductBundleComponentConnection;
  category?: Maybe<TaxonomyCategory>;
  collections: CollectionConnection;
  combinedListing?: Maybe<CombinedListing>;
  combinedListingRole?: Maybe<CombinedListingsRole>;
  compareAtPriceRange?: Maybe<ProductCompareAtPriceRange>;
  contextualPricing: ProductContextualPricing;
  createdAt: Scalars['DateTime']['output'];
  /** @deprecated Deprecated in API version 2022-10. Use `productType` instead. */
  customProductType?: Maybe<Scalars['String']['output']>;
  defaultCursor: Scalars['String']['output'];
  description: Scalars['String']['output'];
  descriptionHtml: Scalars['HTML']['output'];
  /** @deprecated Use `description` instead. */
  descriptionPlainSummary: Scalars['String']['output'];
  events: EventConnection;
  /** @deprecated Use `featuredMedia` instead. */
  featuredImage?: Maybe<Image>;
  featuredMedia?: Maybe<Media>;
  feedback?: Maybe<ResourceFeedback>;
  giftCardTemplateSuffix?: Maybe<Scalars['String']['output']>;
  handle: Scalars['String']['output'];
  hasOnlyDefaultVariant: Scalars['Boolean']['output'];
  hasOutOfStockVariants: Scalars['Boolean']['output'];
  hasVariantsThatRequiresComponents: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** @deprecated Use `media` instead. */
  images: ImageConnection;
  inCollection: Scalars['Boolean']['output'];
  isGiftCard: Scalars['Boolean']['output'];
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  media: MediaConnection;
  mediaCount?: Maybe<Count>;
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  onlineStorePreviewUrl?: Maybe<Scalars['URL']['output']>;
  onlineStoreUrl?: Maybe<Scalars['URL']['output']>;
  options: Array<ProductOption>;
  /** @deprecated Deprecated in API version 2020-10. Use `priceRangeV2` instead. */
  priceRange: ProductPriceRange;
  priceRangeV2: ProductPriceRangeV2;
  /** @deprecated Deprecated in API version 2024-04. Use `category` instead. */
  productCategory?: Maybe<ProductCategory>;
  /** @deprecated Use `resourcePublications` instead. */
  productPublications: ProductPublicationConnection;
  productType: Scalars['String']['output'];
  /** @deprecated Use `resourcePublicationsCount` instead. */
  publicationCount: Scalars['Int']['output'];
  /** @deprecated Use `resourcePublications` instead. */
  publications: ProductPublicationConnection;
  publishedAt?: Maybe<Scalars['DateTime']['output']>;
  publishedInContext: Scalars['Boolean']['output'];
  /** @deprecated Use `publishedOnPublication` instead. */
  publishedOnChannel: Scalars['Boolean']['output'];
  /** @deprecated Use `publishedOnCurrentPublication` instead. */
  publishedOnCurrentChannel: Scalars['Boolean']['output'];
  publishedOnCurrentPublication: Scalars['Boolean']['output'];
  publishedOnPublication: Scalars['Boolean']['output'];
  requiresSellingPlan: Scalars['Boolean']['output'];
  resourcePublicationOnCurrentPublication?: Maybe<ResourcePublicationV2>;
  resourcePublications: ResourcePublicationConnection;
  resourcePublicationsCount?: Maybe<Count>;
  resourcePublicationsV2: ResourcePublicationV2Connection;
  restrictedForResource?: Maybe<RestrictedForResource>;
  /** @deprecated Use `sellingPlanGroupsCount` instead. */
  sellingPlanGroupCount: Scalars['Int']['output'];
  sellingPlanGroups: SellingPlanGroupConnection;
  sellingPlanGroupsCount?: Maybe<Count>;
  seo: Seo;
  /** @deprecated Deprecated in API version 2022-10. Use `productCategory` instead. */
  standardizedProductType?: Maybe<StandardizedProductType>;
  status: ProductStatus;
  /** @deprecated Use `id` instead. */
  storefrontId: Scalars['StorefrontID']['output'];
  tags: Array<Scalars['String']['output']>;
  templateSuffix?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  totalInventory: Scalars['Int']['output'];
  /** @deprecated Use `variantsCount` instead. */
  totalVariants: Scalars['Int']['output'];
  tracksInventory: Scalars['Boolean']['output'];
  translations: Array<Translation>;
  /** @deprecated Use `unpublishedPublications` instead. */
  unpublishedChannels: ChannelConnection;
  unpublishedPublications: PublicationConnection;
  updatedAt: Scalars['DateTime']['output'];
  variants: ProductVariantConnection;
  variantsCount?: Maybe<Count>;
  vendor: Scalars['String']['output'];
};


export type ProductBundleComponentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductCollectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CollectionSortKeys>;
};


export type ProductContextualPricingArgs = {
  context: ContextualPricingContext;
};


export type ProductDescriptionArgs = {
  truncateAt?: InputMaybe<Scalars['Int']['input']>;
};


export type ProductEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type ProductImagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<ProductImageSortKeys>;
};


export type ProductInCollectionArgs = {
  id: Scalars['ID']['input'];
};


export type ProductMediaArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<ProductMediaSortKeys>;
};


export type ProductMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type ProductMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type ProductMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductOptionsArgs = {
  first?: InputMaybe<Scalars['Int']['input']>;
};


export type ProductProductPublicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductPublicationCountArgs = {
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductPublicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductPublishedInContextArgs = {
  context: ContextualPublicationContext;
};


export type ProductPublishedOnChannelArgs = {
  channelId: Scalars['ID']['input'];
};


export type ProductPublishedOnPublicationArgs = {
  publicationId: Scalars['ID']['input'];
};


export type ProductResourcePublicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductResourcePublicationsCountArgs = {
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductResourcePublicationsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  catalogType?: InputMaybe<CatalogType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductRestrictedForResourceArgs = {
  calculatedOrderId: Scalars['ID']['input'];
};


export type ProductSellingPlanGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};


export type ProductUnpublishedChannelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductUnpublishedPublicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<ProductVariantSortKeys>;
};

export type ProductBundleComponent = {
  componentProduct: Product;
  componentVariants: ProductVariantConnection;
  componentVariantsCount?: Maybe<Count>;
  optionSelections: Array<ProductBundleComponentOptionSelection>;
  quantity?: Maybe<Scalars['Int']['output']>;
  quantityOption?: Maybe<ProductBundleComponentQuantityOption>;
};


export type ProductBundleComponentComponentVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductBundleComponentConnection = {
  edges: Array<ProductBundleComponentEdge>;
  nodes: Array<ProductBundleComponent>;
  pageInfo: PageInfo;
};

export type ProductBundleComponentEdge = {
  cursor: Scalars['String']['output'];
  node: ProductBundleComponent;
};

export type ProductBundleComponentInput = {
  optionSelections: Array<ProductBundleComponentOptionSelectionInput>;
  productId: Scalars['ID']['input'];
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quantityOption?: InputMaybe<ProductBundleComponentQuantityOptionInput>;
};

export type ProductBundleComponentOptionSelection = {
  componentOption: ProductOption;
  parentOption?: Maybe<ProductOption>;
  values: Array<ProductBundleComponentOptionSelectionValue>;
};

export type ProductBundleComponentOptionSelectionInput = {
  componentOptionId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  values: Array<Scalars['String']['input']>;
};

export const ProductBundleComponentOptionSelectionStatus = {
  Deselected: 'DESELECTED',
  New: 'NEW',
  Selected: 'SELECTED',
  Unavailable: 'UNAVAILABLE'
} as const;

export type ProductBundleComponentOptionSelectionStatus = typeof ProductBundleComponentOptionSelectionStatus[keyof typeof ProductBundleComponentOptionSelectionStatus];
export type ProductBundleComponentOptionSelectionValue = {
  selectionStatus: ProductBundleComponentOptionSelectionStatus;
  value: Scalars['String']['output'];
};

export type ProductBundleComponentQuantityOption = {
  name: Scalars['String']['output'];
  parentOption?: Maybe<ProductOption>;
  values: Array<ProductBundleComponentQuantityOptionValue>;
};

export type ProductBundleComponentQuantityOptionInput = {
  name: Scalars['String']['input'];
  values: Array<ProductBundleComponentQuantityOptionValueInput>;
};

export type ProductBundleComponentQuantityOptionValue = {
  name: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
};

export type ProductBundleComponentQuantityOptionValueInput = {
  name: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
};

export type ProductBundleCreateInput = {
  components: Array<ProductBundleComponentInput>;
  title: Scalars['String']['input'];
};

export type ProductBundleCreatePayload = {
  productBundleOperation?: Maybe<ProductBundleOperation>;
  userErrors: Array<UserError>;
};

export type ProductBundleMutationUserError = DisplayableError & {
  code?: Maybe<ProductBundleMutationUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductBundleMutationUserErrorCode = {
  GenericError: 'GENERIC_ERROR',
  InvalidInput: 'INVALID_INPUT',
  JobError: 'JOB_ERROR',
  ProductDoesNotExist: 'PRODUCT_DOES_NOT_EXIST'
} as const;

export type ProductBundleMutationUserErrorCode = typeof ProductBundleMutationUserErrorCode[keyof typeof ProductBundleMutationUserErrorCode];
export type ProductBundleOperation = Node & ProductOperation & {
  id: Scalars['ID']['output'];
  product?: Maybe<Product>;
  status: ProductOperationStatus;
  userErrors: Array<ProductBundleMutationUserError>;
};

export type ProductBundleUpdateInput = {
  components?: InputMaybe<Array<ProductBundleComponentInput>>;
  productId: Scalars['ID']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ProductBundleUpdatePayload = {
  productBundleOperation?: Maybe<ProductBundleOperation>;
  userErrors: Array<UserError>;
};

export type ProductCategory = {
  productTaxonomyNode?: Maybe<ProductTaxonomyNode>;
};

export type ProductChangeStatusPayload = {
  product?: Maybe<Product>;
  userErrors: Array<ProductChangeStatusUserError>;
};

export type ProductChangeStatusUserError = DisplayableError & {
  code?: Maybe<ProductChangeStatusUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductChangeStatusUserErrorCode = {
  CombinedListingsNotCompatibleWithShop: 'COMBINED_LISTINGS_NOT_COMPATIBLE_WITH_SHOP',
  ProductNotFound: 'PRODUCT_NOT_FOUND'
} as const;

export type ProductChangeStatusUserErrorCode = typeof ProductChangeStatusUserErrorCode[keyof typeof ProductChangeStatusUserErrorCode];
export type ProductClaimOwnershipInput = {
  bundles?: InputMaybe<Scalars['Boolean']['input']>;
};

export const ProductCollectionSortKeys = {
  BestSelling: 'BEST_SELLING',
  CollectionDefault: 'COLLECTION_DEFAULT',
  Created: 'CREATED',
  Id: 'ID',
  Manual: 'MANUAL',
  Price: 'PRICE',
  Relevance: 'RELEVANCE',
  Title: 'TITLE'
} as const;

export type ProductCollectionSortKeys = typeof ProductCollectionSortKeys[keyof typeof ProductCollectionSortKeys];
export type ProductCompareAtPriceRange = {
  maxVariantCompareAtPrice: MoneyV2;
  minVariantCompareAtPrice: MoneyV2;
};

export type ProductConnection = {
  edges: Array<ProductEdge>;
  nodes: Array<Product>;
  pageInfo: PageInfo;
};

export type ProductContextualPricing = {
  fixedQuantityRulesCount: Scalars['Int']['output'];
  maxVariantPricing?: Maybe<ProductVariantContextualPricing>;
  minVariantPricing?: Maybe<ProductVariantContextualPricing>;
  priceRange: ProductPriceRangeV2;
};

export type ProductCreateInput = {
  category?: InputMaybe<Scalars['ID']['input']>;
  claimOwnership?: InputMaybe<ProductClaimOwnershipInput>;
  collectionsToJoin?: InputMaybe<Array<Scalars['ID']['input']>>;
  combinedListingRole?: InputMaybe<CombinedListingsRole>;
  descriptionHtml?: InputMaybe<Scalars['String']['input']>;
  giftCard?: InputMaybe<Scalars['Boolean']['input']>;
  giftCardTemplateSuffix?: InputMaybe<Scalars['String']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  productOptions?: InputMaybe<Array<OptionCreateInput>>;
  productType?: InputMaybe<Scalars['String']['input']>;
  requiresSellingPlan?: InputMaybe<Scalars['Boolean']['input']>;
  seo?: InputMaybe<SeoInput>;
  status?: InputMaybe<ProductStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  vendor?: InputMaybe<Scalars['String']['input']>;
};

export type ProductCreateMediaPayload = {
  media?: Maybe<Array<Media>>;
  mediaUserErrors: Array<MediaUserError>;
  product?: Maybe<Product>;
  /** @deprecated Use `mediaUserErrors` instead. */
  userErrors: Array<UserError>;
};

export type ProductCreatePayload = {
  product?: Maybe<Product>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type ProductDeleteInput = {
  id: Scalars['ID']['input'];
};

export type ProductDeleteMediaPayload = {
  deletedMediaIds?: Maybe<Array<Scalars['ID']['output']>>;
  deletedProductImageIds?: Maybe<Array<Scalars['ID']['output']>>;
  mediaUserErrors: Array<MediaUserError>;
  product?: Maybe<Product>;
  /** @deprecated Use `mediaUserErrors` instead. */
  userErrors: Array<UserError>;
};

export type ProductDeleteOperation = Node & ProductOperation & {
  deletedProductId?: Maybe<Scalars['ID']['output']>;
  id: Scalars['ID']['output'];
  product?: Maybe<Product>;
  status: ProductOperationStatus;
  userErrors: Array<UserError>;
};

export type ProductDeletePayload = {
  deletedProductId?: Maybe<Scalars['ID']['output']>;
  productDeleteOperation?: Maybe<ProductDeleteOperation>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type ProductDuplicateJob = {
  done: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
};

export type ProductDuplicateOperation = Node & ProductOperation & {
  id: Scalars['ID']['output'];
  newProduct?: Maybe<Product>;
  product?: Maybe<Product>;
  status: ProductOperationStatus;
  userErrors: Array<UserError>;
};

export type ProductDuplicatePayload = {
  imageJob?: Maybe<Job>;
  newProduct?: Maybe<Product>;
  productDuplicateOperation?: Maybe<ProductDuplicateOperation>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type ProductEdge = {
  cursor: Scalars['String']['output'];
  node: Product;
};

export type ProductFeed = Node & {
  country?: Maybe<CountryCode>;
  id: Scalars['ID']['output'];
  language?: Maybe<LanguageCode>;
  status: ProductFeedStatus;
};

export type ProductFeedConnection = {
  edges: Array<ProductFeedEdge>;
  nodes: Array<ProductFeed>;
  pageInfo: PageInfo;
};

export type ProductFeedCreatePayload = {
  productFeed?: Maybe<ProductFeed>;
  userErrors: Array<ProductFeedCreateUserError>;
};

export type ProductFeedCreateUserError = DisplayableError & {
  code?: Maybe<ProductFeedCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductFeedCreateUserErrorCode = {
  Invalid: 'INVALID',
  Taken: 'TAKEN'
} as const;

export type ProductFeedCreateUserErrorCode = typeof ProductFeedCreateUserErrorCode[keyof typeof ProductFeedCreateUserErrorCode];
export type ProductFeedDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<ProductFeedDeleteUserError>;
};

export type ProductFeedDeleteUserError = DisplayableError & {
  code?: Maybe<ProductFeedDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductFeedDeleteUserErrorCode = {
  Invalid: 'INVALID'
} as const;

export type ProductFeedDeleteUserErrorCode = typeof ProductFeedDeleteUserErrorCode[keyof typeof ProductFeedDeleteUserErrorCode];
export type ProductFeedEdge = {
  cursor: Scalars['String']['output'];
  node: ProductFeed;
};

export type ProductFeedInput = {
  country: CountryCode;
  language: LanguageCode;
};

export const ProductFeedStatus = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE'
} as const;

export type ProductFeedStatus = typeof ProductFeedStatus[keyof typeof ProductFeedStatus];
export type ProductFullSyncPayload = {
  userErrors: Array<ProductFullSyncUserError>;
};

export type ProductFullSyncUserError = DisplayableError & {
  code?: Maybe<ProductFullSyncUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductFullSyncUserErrorCode = {
  Invalid: 'INVALID'
} as const;

export type ProductFullSyncUserErrorCode = typeof ProductFullSyncUserErrorCode[keyof typeof ProductFullSyncUserErrorCode];
export type ProductIdentifierInput = {
  customId?: InputMaybe<UniqueMetafieldValueInput>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
};

export const ProductImageSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Position: 'POSITION',
  Relevance: 'RELEVANCE'
} as const;

export type ProductImageSortKeys = typeof ProductImageSortKeys[keyof typeof ProductImageSortKeys];
export type ProductInput = {
  category?: InputMaybe<Scalars['ID']['input']>;
  claimOwnership?: InputMaybe<ProductClaimOwnershipInput>;
  collectionsToJoin?: InputMaybe<Array<Scalars['ID']['input']>>;
  collectionsToLeave?: InputMaybe<Array<Scalars['ID']['input']>>;
  combinedListingRole?: InputMaybe<CombinedListingsRole>;
  descriptionHtml?: InputMaybe<Scalars['String']['input']>;
  giftCard?: InputMaybe<Scalars['Boolean']['input']>;
  giftCardTemplateSuffix?: InputMaybe<Scalars['String']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  productOptions?: InputMaybe<Array<OptionCreateInput>>;
  productType?: InputMaybe<Scalars['String']['input']>;
  redirectNewHandle?: InputMaybe<Scalars['Boolean']['input']>;
  requiresSellingPlan?: InputMaybe<Scalars['Boolean']['input']>;
  seo?: InputMaybe<SeoInput>;
  status?: InputMaybe<ProductStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  vendor?: InputMaybe<Scalars['String']['input']>;
};

export type ProductJoinSellingPlanGroupsPayload = {
  product?: Maybe<Product>;
  userErrors: Array<SellingPlanGroupUserError>;
};

export type ProductLeaveSellingPlanGroupsPayload = {
  product?: Maybe<Product>;
  userErrors: Array<SellingPlanGroupUserError>;
};

export const ProductMediaSortKeys = {
  Id: 'ID',
  Position: 'POSITION',
  Relevance: 'RELEVANCE'
} as const;

export type ProductMediaSortKeys = typeof ProductMediaSortKeys[keyof typeof ProductMediaSortKeys];
export type ProductOperation = {
  product?: Maybe<Product>;
  status: ProductOperationStatus;
};

export const ProductOperationStatus = {
  Active: 'ACTIVE',
  Complete: 'COMPLETE',
  Created: 'CREATED'
} as const;

export type ProductOperationStatus = typeof ProductOperationStatus[keyof typeof ProductOperationStatus];
export type ProductOption = HasPublishedTranslations & Node & {
  id: Scalars['ID']['output'];
  linkedMetafield?: Maybe<LinkedMetafield>;
  name: Scalars['String']['output'];
  optionValues: Array<ProductOptionValue>;
  position: Scalars['Int']['output'];
  translations: Array<Translation>;
  values: Array<Scalars['String']['output']>;
};


export type ProductOptionTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export const ProductOptionCreateVariantStrategy = {
  Create: 'CREATE',
  LeaveAsIs: 'LEAVE_AS_IS'
} as const;

export type ProductOptionCreateVariantStrategy = typeof ProductOptionCreateVariantStrategy[keyof typeof ProductOptionCreateVariantStrategy];
export const ProductOptionDeleteStrategy = {
  Default: 'DEFAULT',
  NonDestructive: 'NON_DESTRUCTIVE',
  Position: 'POSITION'
} as const;

export type ProductOptionDeleteStrategy = typeof ProductOptionDeleteStrategy[keyof typeof ProductOptionDeleteStrategy];
export type ProductOptionUpdatePayload = {
  product?: Maybe<Product>;
  userErrors: Array<ProductOptionUpdateUserError>;
};

export type ProductOptionUpdateUserError = DisplayableError & {
  code?: Maybe<ProductOptionUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductOptionUpdateUserErrorCode = {
  CannotCombineLinkedAndNonlinkedOptionValues: 'CANNOT_COMBINE_LINKED_AND_NONLINKED_OPTION_VALUES',
  CannotCreateVariantsAboveLimit: 'CANNOT_CREATE_VARIANTS_ABOVE_LIMIT',
  CannotDeleteAllOptionValuesInOption: 'CANNOT_DELETE_ALL_OPTION_VALUES_IN_OPTION',
  CannotDeleteVariantWithoutPermission: 'CANNOT_DELETE_VARIANT_WITHOUT_PERMISSION',
  CannotLeaveOptionsWithoutVariants: 'CANNOT_LEAVE_OPTIONS_WITHOUT_VARIANTS',
  CannotMakeChangesIfVariantIsMissingRequiredSku: 'CANNOT_MAKE_CHANGES_IF_VARIANT_IS_MISSING_REQUIRED_SKU',
  DuplicatedOptionValue: 'DUPLICATED_OPTION_VALUE',
  DuplicateLinkedOption: 'DUPLICATE_LINKED_OPTION',
  InvalidMetafieldValueForLinkedOption: 'INVALID_METAFIELD_VALUE_FOR_LINKED_OPTION',
  InvalidName: 'INVALID_NAME',
  InvalidPosition: 'INVALID_POSITION',
  KeyMissingInInput: 'KEY_MISSING_IN_INPUT',
  LinkedMetafieldDefinitionNotFound: 'LINKED_METAFIELD_DEFINITION_NOT_FOUND',
  LinkedOptionsNotSupportedForShop: 'LINKED_OPTIONS_NOT_SUPPORTED_FOR_SHOP',
  LinkedOptionUpdateMissingValues: 'LINKED_OPTION_UPDATE_MISSING_VALUES',
  NoKeyOnCreate: 'NO_KEY_ON_CREATE',
  OptionAlreadyExists: 'OPTION_ALREADY_EXISTS',
  OptionDoesNotExist: 'OPTION_DOES_NOT_EXIST',
  OptionLinkedMetafieldAlreadyTaken: 'OPTION_LINKED_METAFIELD_ALREADY_TAKEN',
  OptionNameTooLong: 'OPTION_NAME_TOO_LONG',
  OptionValuesOverLimit: 'OPTION_VALUES_OVER_LIMIT',
  OptionValueAlreadyExists: 'OPTION_VALUE_ALREADY_EXISTS',
  OptionValueConflictingOperation: 'OPTION_VALUE_CONFLICTING_OPERATION',
  OptionValueDoesNotExist: 'OPTION_VALUE_DOES_NOT_EXIST',
  OptionValueHasVariants: 'OPTION_VALUE_HAS_VARIANTS',
  OptionValueNameTooLong: 'OPTION_VALUE_NAME_TOO_LONG',
  ProductDoesNotExist: 'PRODUCT_DOES_NOT_EXIST',
  ProductSuspended: 'PRODUCT_SUSPENDED',
  TooManyVariantsCreated: 'TOO_MANY_VARIANTS_CREATED',
  UnsupportedCombinedListingParentOperation: 'UNSUPPORTED_COMBINED_LISTING_PARENT_OPERATION'
} as const;

export type ProductOptionUpdateUserErrorCode = typeof ProductOptionUpdateUserErrorCode[keyof typeof ProductOptionUpdateUserErrorCode];
export const ProductOptionUpdateVariantStrategy = {
  LeaveAsIs: 'LEAVE_AS_IS',
  Manage: 'MANAGE'
} as const;

export type ProductOptionUpdateVariantStrategy = typeof ProductOptionUpdateVariantStrategy[keyof typeof ProductOptionUpdateVariantStrategy];
export type ProductOptionValue = HasPublishedTranslations & Node & {
  hasVariants: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  linkedMetafieldValue?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  swatch?: Maybe<ProductOptionValueSwatch>;
  translations: Array<Translation>;
};


export type ProductOptionValueTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export type ProductOptionValueSwatch = {
  color?: Maybe<Scalars['Color']['output']>;
  image?: Maybe<MediaImage>;
};

export type ProductOptionsCreatePayload = {
  product?: Maybe<Product>;
  userErrors: Array<ProductOptionsCreateUserError>;
};

export type ProductOptionsCreateUserError = DisplayableError & {
  code?: Maybe<ProductOptionsCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductOptionsCreateUserErrorCode = {
  CannotCombineLinkedMetafieldAndOptionValues: 'CANNOT_COMBINE_LINKED_METAFIELD_AND_OPTION_VALUES',
  CannotMakeChangesIfVariantIsMissingRequiredSku: 'CANNOT_MAKE_CHANGES_IF_VARIANT_IS_MISSING_REQUIRED_SKU',
  DuplicatedOptionName: 'DUPLICATED_OPTION_NAME',
  DuplicatedOptionValue: 'DUPLICATED_OPTION_VALUE',
  DuplicateLinkedOption: 'DUPLICATE_LINKED_OPTION',
  InvalidMetafieldValueForLinkedOption: 'INVALID_METAFIELD_VALUE_FOR_LINKED_OPTION',
  InvalidName: 'INVALID_NAME',
  LinkedMetafieldDefinitionNotFound: 'LINKED_METAFIELD_DEFINITION_NOT_FOUND',
  LinkedMetafieldValueWithoutLinkedOption: 'LINKED_METAFIELD_VALUE_WITHOUT_LINKED_OPTION',
  LinkedOptionsNotSupportedForShop: 'LINKED_OPTIONS_NOT_SUPPORTED_FOR_SHOP',
  MissingMetafieldValuesForLinkedOption: 'MISSING_METAFIELD_VALUES_FOR_LINKED_OPTION',
  NewOptionWithoutValueForExistingVariants: 'NEW_OPTION_WITHOUT_VALUE_FOR_EXISTING_VARIANTS',
  OptionsOverLimit: 'OPTIONS_OVER_LIMIT',
  OptionAlreadyExists: 'OPTION_ALREADY_EXISTS',
  OptionLinkedMetafieldAlreadyTaken: 'OPTION_LINKED_METAFIELD_ALREADY_TAKEN',
  OptionNameMissing: 'OPTION_NAME_MISSING',
  OptionPositionMissing: 'OPTION_POSITION_MISSING',
  OptionValuesMissing: 'OPTION_VALUES_MISSING',
  OptionValuesOverLimit: 'OPTION_VALUES_OVER_LIMIT',
  PositionOutOfBounds: 'POSITION_OUT_OF_BOUNDS',
  ProductDoesNotExist: 'PRODUCT_DOES_NOT_EXIST',
  ProductSuspended: 'PRODUCT_SUSPENDED',
  TooManyVariantsCreated: 'TOO_MANY_VARIANTS_CREATED',
  UnsupportedCombinedListingParentOperation: 'UNSUPPORTED_COMBINED_LISTING_PARENT_OPERATION'
} as const;

export type ProductOptionsCreateUserErrorCode = typeof ProductOptionsCreateUserErrorCode[keyof typeof ProductOptionsCreateUserErrorCode];
export type ProductOptionsDeletePayload = {
  deletedOptionsIds?: Maybe<Array<Scalars['ID']['output']>>;
  product?: Maybe<Product>;
  userErrors: Array<ProductOptionsDeleteUserError>;
};

export type ProductOptionsDeleteUserError = DisplayableError & {
  code?: Maybe<ProductOptionsDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductOptionsDeleteUserErrorCode = {
  CannotDeleteOptionWithMultipleValues: 'CANNOT_DELETE_OPTION_WITH_MULTIPLE_VALUES',
  CannotDeleteVariantWithoutPermission: 'CANNOT_DELETE_VARIANT_WITHOUT_PERMISSION',
  CannotMakeChangesIfVariantIsMissingRequiredSku: 'CANNOT_MAKE_CHANGES_IF_VARIANT_IS_MISSING_REQUIRED_SKU',
  CannotUseNonDestructiveStrategy: 'CANNOT_USE_NON_DESTRUCTIVE_STRATEGY',
  OptionsDoNotBelongToTheSameProduct: 'OPTIONS_DO_NOT_BELONG_TO_THE_SAME_PRODUCT',
  OptionDoesNotExist: 'OPTION_DOES_NOT_EXIST',
  ProductDoesNotExist: 'PRODUCT_DOES_NOT_EXIST',
  ProductSuspended: 'PRODUCT_SUSPENDED',
  UnsupportedCombinedListingParentOperation: 'UNSUPPORTED_COMBINED_LISTING_PARENT_OPERATION'
} as const;

export type ProductOptionsDeleteUserErrorCode = typeof ProductOptionsDeleteUserErrorCode[keyof typeof ProductOptionsDeleteUserErrorCode];
export type ProductOptionsReorderPayload = {
  product?: Maybe<Product>;
  userErrors: Array<ProductOptionsReorderUserError>;
};

export type ProductOptionsReorderUserError = DisplayableError & {
  code?: Maybe<ProductOptionsReorderUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductOptionsReorderUserErrorCode = {
  CannotMakeChangesIfVariantIsMissingRequiredSku: 'CANNOT_MAKE_CHANGES_IF_VARIANT_IS_MISSING_REQUIRED_SKU',
  DuplicatedOptionName: 'DUPLICATED_OPTION_NAME',
  DuplicatedOptionValue: 'DUPLICATED_OPTION_VALUE',
  MissingOptionName: 'MISSING_OPTION_NAME',
  MissingOptionValue: 'MISSING_OPTION_VALUE',
  MixingIdAndNameKeysIsNotAllowed: 'MIXING_ID_AND_NAME_KEYS_IS_NOT_ALLOWED',
  NoKeyOnReorder: 'NO_KEY_ON_REORDER',
  OptionIdDoesNotExist: 'OPTION_ID_DOES_NOT_EXIST',
  OptionNameDoesNotExist: 'OPTION_NAME_DOES_NOT_EXIST',
  OptionValueDoesNotExist: 'OPTION_VALUE_DOES_NOT_EXIST',
  OptionValueIdDoesNotExist: 'OPTION_VALUE_ID_DOES_NOT_EXIST',
  ProductDoesNotExist: 'PRODUCT_DOES_NOT_EXIST'
} as const;

export type ProductOptionsReorderUserErrorCode = typeof ProductOptionsReorderUserErrorCode[keyof typeof ProductOptionsReorderUserErrorCode];
export type ProductPriceRange = {
  maxVariantPrice: MoneyV2;
  minVariantPrice: MoneyV2;
};

export type ProductPriceRangeV2 = {
  maxVariantPrice: MoneyV2;
  minVariantPrice: MoneyV2;
};

export type ProductPublication = {
  channel: Channel;
  isPublished: Scalars['Boolean']['output'];
  product: Product;
  publishDate?: Maybe<Scalars['DateTime']['output']>;
};

export type ProductPublicationConnection = {
  edges: Array<ProductPublicationEdge>;
  nodes: Array<ProductPublication>;
  pageInfo: PageInfo;
};

export type ProductPublicationEdge = {
  cursor: Scalars['String']['output'];
  node: ProductPublication;
};

export type ProductPublicationInput = {
  publicationId?: InputMaybe<Scalars['ID']['input']>;
  publishDate?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductPublishInput = {
  id: Scalars['ID']['input'];
  productPublications: Array<ProductPublicationInput>;
};

export type ProductPublishPayload = {
  product?: Maybe<Product>;
  /** @deprecated Use Product.publications instead. */
  productPublications?: Maybe<Array<ProductPublication>>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type ProductReorderMediaPayload = {
  job?: Maybe<Job>;
  mediaUserErrors: Array<MediaUserError>;
  /** @deprecated Use `mediaUserErrors` instead. */
  userErrors: Array<UserError>;
};

export type ProductResourceFeedback = {
  feedbackGeneratedAt: Scalars['DateTime']['output'];
  messages: Array<Scalars['String']['output']>;
  productId: Scalars['ID']['output'];
  productUpdatedAt: Scalars['DateTime']['output'];
  state: ResourceFeedbackState;
};

export type ProductResourceFeedbackInput = {
  feedbackGeneratedAt: Scalars['DateTime']['input'];
  messages?: InputMaybe<Array<Scalars['String']['input']>>;
  productId: Scalars['ID']['input'];
  productUpdatedAt: Scalars['DateTime']['input'];
  state: ResourceFeedbackState;
};

export type ProductSale = Sale & {
  actionType: SaleActionType;
  id: Scalars['ID']['output'];
  lineItem: LineItem;
  lineType: SaleLineType;
  quantity?: Maybe<Scalars['Int']['output']>;
  taxes: Array<SaleTax>;
  totalAmount: MoneyBag;
  totalDiscountAmountAfterTaxes: MoneyBag;
  totalDiscountAmountBeforeTaxes: MoneyBag;
  totalTaxAmount: MoneyBag;
};

export type ProductSetInput = {
  category?: InputMaybe<Scalars['ID']['input']>;
  claimOwnership?: InputMaybe<ProductClaimOwnershipInput>;
  collections?: InputMaybe<Array<Scalars['ID']['input']>>;
  combinedListingRole?: InputMaybe<CombinedListingsRole>;
  descriptionHtml?: InputMaybe<Scalars['String']['input']>;
  files?: InputMaybe<Array<FileSetInput>>;
  giftCard?: InputMaybe<Scalars['Boolean']['input']>;
  giftCardTemplateSuffix?: InputMaybe<Scalars['String']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  productOptions?: InputMaybe<Array<OptionSetInput>>;
  productType?: InputMaybe<Scalars['String']['input']>;
  redirectNewHandle?: InputMaybe<Scalars['Boolean']['input']>;
  requiresSellingPlan?: InputMaybe<Scalars['Boolean']['input']>;
  seo?: InputMaybe<SeoInput>;
  status?: InputMaybe<ProductStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  variants?: InputMaybe<Array<ProductVariantSetInput>>;
  vendor?: InputMaybe<Scalars['String']['input']>;
};

export type ProductSetInventoryInput = {
  locationId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
};

export type ProductSetOperation = Node & ProductOperation & {
  id: Scalars['ID']['output'];
  product?: Maybe<Product>;
  status: ProductOperationStatus;
  userErrors: Array<ProductSetUserError>;
};

export type ProductSetPayload = {
  product?: Maybe<Product>;
  productSetOperation?: Maybe<ProductSetOperation>;
  userErrors: Array<ProductSetUserError>;
};

export type ProductSetUserError = DisplayableError & {
  code?: Maybe<ProductSetUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductSetUserErrorCode = {
  CannotCombineLinkedAndNonlinkedOptionValues: 'CANNOT_COMBINE_LINKED_AND_NONLINKED_OPTION_VALUES',
  CapabilityViolation: 'CAPABILITY_VIOLATION',
  DuplicatedOptionName: 'DUPLICATED_OPTION_NAME',
  DuplicatedOptionValue: 'DUPLICATED_OPTION_VALUE',
  DuplicatedValue: 'DUPLICATED_VALUE',
  DuplicateLinkedOption: 'DUPLICATE_LINKED_OPTION',
  GenericError: 'GENERIC_ERROR',
  GiftCardsNotActivated: 'GIFT_CARDS_NOT_ACTIVATED',
  GiftCardAttributeCannotBeChanged: 'GIFT_CARD_ATTRIBUTE_CANNOT_BE_CHANGED',
  HandleNotUnique: 'HANDLE_NOT_UNIQUE',
  InvalidInput: 'INVALID_INPUT',
  InvalidMetafield: 'INVALID_METAFIELD',
  InvalidMetafieldValueForLinkedOption: 'INVALID_METAFIELD_VALUE_FOR_LINKED_OPTION',
  InvalidProduct: 'INVALID_PRODUCT',
  InvalidVariant: 'INVALID_VARIANT',
  JobError: 'JOB_ERROR',
  LinkedMetafieldDefinitionNotFound: 'LINKED_METAFIELD_DEFINITION_NOT_FOUND',
  LinkedOptionsNotSupportedForShop: 'LINKED_OPTIONS_NOT_SUPPORTED_FOR_SHOP',
  OptionsOverLimit: 'OPTIONS_OVER_LIMIT',
  OptionDoesNotExist: 'OPTION_DOES_NOT_EXIST',
  OptionValuesMissing: 'OPTION_VALUES_MISSING',
  OptionValuesOverLimit: 'OPTION_VALUES_OVER_LIMIT',
  OptionValueDoesNotExist: 'OPTION_VALUE_DOES_NOT_EXIST',
  ProductDoesNotExist: 'PRODUCT_DOES_NOT_EXIST',
  ProductOptionsInputMissing: 'PRODUCT_OPTIONS_INPUT_MISSING',
  ProductVariantDoesNotExist: 'PRODUCT_VARIANT_DOES_NOT_EXIST',
  VariantsInputMissing: 'VARIANTS_INPUT_MISSING',
  VariantsOverLimit: 'VARIANTS_OVER_LIMIT'
} as const;

export type ProductSetUserErrorCode = typeof ProductSetUserErrorCode[keyof typeof ProductSetUserErrorCode];
export const ProductSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  InventoryTotal: 'INVENTORY_TOTAL',
  ProductType: 'PRODUCT_TYPE',
  PublishedAt: 'PUBLISHED_AT',
  Relevance: 'RELEVANCE',
  Title: 'TITLE',
  UpdatedAt: 'UPDATED_AT',
  Vendor: 'VENDOR'
} as const;

export type ProductSortKeys = typeof ProductSortKeys[keyof typeof ProductSortKeys];
export const ProductStatus = {
  Active: 'ACTIVE',
  Archived: 'ARCHIVED',
  Draft: 'DRAFT'
} as const;

export type ProductStatus = typeof ProductStatus[keyof typeof ProductStatus];
export type ProductTaxonomyNode = Node & {
  fullName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isLeaf: Scalars['Boolean']['output'];
  isRoot: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
};

export type ProductUnpublishInput = {
  id: Scalars['ID']['input'];
  productPublications: Array<ProductPublicationInput>;
};

export type ProductUnpublishPayload = {
  product?: Maybe<Product>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type ProductUpdateInput = {
  category?: InputMaybe<Scalars['ID']['input']>;
  collectionsToJoin?: InputMaybe<Array<Scalars['ID']['input']>>;
  collectionsToLeave?: InputMaybe<Array<Scalars['ID']['input']>>;
  deleteConflictingConstrainedMetafields?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionHtml?: InputMaybe<Scalars['String']['input']>;
  giftCardTemplateSuffix?: InputMaybe<Scalars['String']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  productType?: InputMaybe<Scalars['String']['input']>;
  redirectNewHandle?: InputMaybe<Scalars['Boolean']['input']>;
  requiresSellingPlan?: InputMaybe<Scalars['Boolean']['input']>;
  seo?: InputMaybe<SeoInput>;
  status?: InputMaybe<ProductStatus>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  templateSuffix?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  vendor?: InputMaybe<Scalars['String']['input']>;
};

export type ProductUpdateMediaPayload = {
  media?: Maybe<Array<Media>>;
  mediaUserErrors: Array<MediaUserError>;
  product?: Maybe<Product>;
  /** @deprecated Use `mediaUserErrors` instead. */
  userErrors: Array<UserError>;
};

export type ProductUpdatePayload = {
  product?: Maybe<Product>;
  userErrors: Array<UserError>;
};

export type ProductVariant = HasEvents & HasMetafieldDefinitions & HasMetafields & HasPublishedTranslations & LegacyInteroperability & Navigable & Node & {
  availableForSale: Scalars['Boolean']['output'];
  barcode?: Maybe<Scalars['String']['output']>;
  compareAtPrice?: Maybe<Scalars['Money']['output']>;
  contextualPricing: ProductVariantContextualPricing;
  createdAt: Scalars['DateTime']['output'];
  defaultCursor: Scalars['String']['output'];
  deliveryProfile?: Maybe<DeliveryProfile>;
  displayName: Scalars['String']['output'];
  events: EventConnection;
  id: Scalars['ID']['output'];
  image?: Maybe<Image>;
  inventoryItem: InventoryItem;
  inventoryPolicy: ProductVariantInventoryPolicy;
  inventoryQuantity?: Maybe<Scalars['Int']['output']>;
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  media: MediaConnection;
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  position: Scalars['Int']['output'];
  /** @deprecated Use `contextualPricing` instead. */
  presentmentPrices: ProductVariantPricePairConnection;
  price: Scalars['Money']['output'];
  product: Product;
  productVariantComponents: ProductVariantComponentConnection;
  requiresComponents: Scalars['Boolean']['output'];
  selectedOptions: Array<SelectedOption>;
  sellableOnlineQuantity: Scalars['Int']['output'];
  /** @deprecated Use `sellingPlanGroupsCount` instead. */
  sellingPlanGroupCount: Scalars['Int']['output'];
  sellingPlanGroups: SellingPlanGroupConnection;
  sellingPlanGroupsCount?: Maybe<Count>;
  sku?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use `id` instead. */
  storefrontId: Scalars['StorefrontID']['output'];
  taxCode?: Maybe<Scalars['String']['output']>;
  taxable: Scalars['Boolean']['output'];
  title: Scalars['String']['output'];
  translations: Array<Translation>;
  unitPriceMeasurement?: Maybe<UnitPriceMeasurement>;
  updatedAt: Scalars['DateTime']['output'];
};


export type ProductVariantContextualPricingArgs = {
  context: ContextualPricingContext;
};


export type ProductVariantEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type ProductVariantMediaArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductVariantMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type ProductVariantMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type ProductVariantMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductVariantPresentmentPricesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  presentmentCurrencies?: InputMaybe<Array<CurrencyCode>>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductVariantProductVariantComponentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductVariantSellingPlanGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ProductVariantTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export type ProductVariantAppendMediaInput = {
  mediaIds: Array<Scalars['ID']['input']>;
  variantId: Scalars['ID']['input'];
};

export type ProductVariantAppendMediaPayload = {
  product?: Maybe<Product>;
  productVariants?: Maybe<Array<ProductVariant>>;
  userErrors: Array<MediaUserError>;
};

export type ProductVariantComponent = Node & {
  id: Scalars['ID']['output'];
  productVariant: ProductVariant;
  quantity: Scalars['Int']['output'];
};

export type ProductVariantComponentConnection = {
  edges: Array<ProductVariantComponentEdge>;
  nodes: Array<ProductVariantComponent>;
  pageInfo: PageInfo;
};

export type ProductVariantComponentEdge = {
  cursor: Scalars['String']['output'];
  node: ProductVariantComponent;
};

export type ProductVariantConnection = {
  edges: Array<ProductVariantEdge>;
  nodes: Array<ProductVariant>;
  pageInfo: PageInfo;
};

export type ProductVariantContextualPricing = {
  compareAtPrice?: Maybe<MoneyV2>;
  price: MoneyV2;
  quantityPriceBreaks: QuantityPriceBreakConnection;
  quantityRule: QuantityRule;
};


export type ProductVariantContextualPricingQuantityPriceBreaksArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<QuantityPriceBreakSortKeys>;
};

export type ProductVariantDetachMediaInput = {
  mediaIds: Array<Scalars['ID']['input']>;
  variantId: Scalars['ID']['input'];
};

export type ProductVariantDetachMediaPayload = {
  product?: Maybe<Product>;
  productVariants?: Maybe<Array<ProductVariant>>;
  userErrors: Array<MediaUserError>;
};

export type ProductVariantEdge = {
  cursor: Scalars['String']['output'];
  node: ProductVariant;
};

export type ProductVariantGroupRelationshipInput = {
  id: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
};

export const ProductVariantInventoryPolicy = {
  Continue: 'CONTINUE',
  Deny: 'DENY'
} as const;

export type ProductVariantInventoryPolicy = typeof ProductVariantInventoryPolicy[keyof typeof ProductVariantInventoryPolicy];
export type ProductVariantJoinSellingPlanGroupsPayload = {
  productVariant?: Maybe<ProductVariant>;
  userErrors: Array<SellingPlanGroupUserError>;
};

export type ProductVariantLeaveSellingPlanGroupsPayload = {
  productVariant?: Maybe<ProductVariant>;
  userErrors: Array<SellingPlanGroupUserError>;
};

export type ProductVariantPositionInput = {
  id: Scalars['ID']['input'];
  position: Scalars['Int']['input'];
};

export type ProductVariantPricePair = {
  compareAtPrice?: Maybe<MoneyV2>;
  price: MoneyV2;
};

export type ProductVariantPricePairConnection = {
  edges: Array<ProductVariantPricePairEdge>;
  nodes: Array<ProductVariantPricePair>;
  pageInfo: PageInfo;
};

export type ProductVariantPricePairEdge = {
  cursor: Scalars['String']['output'];
  node: ProductVariantPricePair;
};

export type ProductVariantRelationshipBulkUpdatePayload = {
  parentProductVariants?: Maybe<Array<ProductVariant>>;
  userErrors: Array<ProductVariantRelationshipBulkUpdateUserError>;
};

export type ProductVariantRelationshipBulkUpdateUserError = DisplayableError & {
  code?: Maybe<ProductVariantRelationshipBulkUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductVariantRelationshipBulkUpdateUserErrorCode = {
  ChildProductVariantCannotBeCombinedListing: 'CHILD_PRODUCT_VARIANT_CANNOT_BE_COMBINED_LISTING',
  CircularReference: 'CIRCULAR_REFERENCE',
  DuplicateProductVariantRelationship: 'DUPLICATE_PRODUCT_VARIANT_RELATIONSHIP',
  ExceededProductVariantRelationshipLimit: 'EXCEEDED_PRODUCT_VARIANT_RELATIONSHIP_LIMIT',
  FailedToCreate: 'FAILED_TO_CREATE',
  FailedToRemove: 'FAILED_TO_REMOVE',
  FailedToUpdate: 'FAILED_TO_UPDATE',
  FailedToUpdateParentProductVariantPrice: 'FAILED_TO_UPDATE_PARENT_PRODUCT_VARIANT_PRICE',
  InvalidQuantity: 'INVALID_QUANTITY',
  MustSpecifyComponents: 'MUST_SPECIFY_COMPONENTS',
  NestedParentProductVariant: 'NESTED_PARENT_PRODUCT_VARIANT',
  ParentProductVariantCannotBeCombinedListing: 'PARENT_PRODUCT_VARIANT_CANNOT_BE_COMBINED_LISTING',
  ParentProductVariantCannotBeGiftCard: 'PARENT_PRODUCT_VARIANT_CANNOT_BE_GIFT_CARD',
  ParentProductVariantCannotRequireSellingPlan: 'PARENT_PRODUCT_VARIANT_CANNOT_REQUIRE_SELLING_PLAN',
  ParentRequired: 'PARENT_REQUIRED',
  ProductExpanderAppOwnershipAlreadyExists: 'PRODUCT_EXPANDER_APP_OWNERSHIP_ALREADY_EXISTS',
  ProductVariantsNotComponents: 'PRODUCT_VARIANTS_NOT_COMPONENTS',
  ProductVariantsNotFound: 'PRODUCT_VARIANTS_NOT_FOUND',
  ProductVariantRelationshipTypeConflict: 'PRODUCT_VARIANT_RELATIONSHIP_TYPE_CONFLICT',
  UnexpectedError: 'UNEXPECTED_ERROR',
  UnsupportedMultipackRelationship: 'UNSUPPORTED_MULTIPACK_RELATIONSHIP',
  UpdateParentVariantPriceRequired: 'UPDATE_PARENT_VARIANT_PRICE_REQUIRED'
} as const;

export type ProductVariantRelationshipBulkUpdateUserErrorCode = typeof ProductVariantRelationshipBulkUpdateUserErrorCode[keyof typeof ProductVariantRelationshipBulkUpdateUserErrorCode];
export type ProductVariantRelationshipUpdateInput = {
  parentProductId?: InputMaybe<Scalars['ID']['input']>;
  parentProductVariantId?: InputMaybe<Scalars['ID']['input']>;
  priceInput?: InputMaybe<PriceInput>;
  productVariantRelationshipsToCreate?: InputMaybe<Array<ProductVariantGroupRelationshipInput>>;
  productVariantRelationshipsToRemove?: InputMaybe<Array<Scalars['ID']['input']>>;
  productVariantRelationshipsToUpdate?: InputMaybe<Array<ProductVariantGroupRelationshipInput>>;
  removeAllProductVariantRelationships?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductVariantSetInput = {
  barcode?: InputMaybe<Scalars['String']['input']>;
  compareAtPrice?: InputMaybe<Scalars['Money']['input']>;
  file?: InputMaybe<FileSetInput>;
  id?: InputMaybe<Scalars['ID']['input']>;
  inventoryItem?: InputMaybe<InventoryItemInput>;
  inventoryPolicy?: InputMaybe<ProductVariantInventoryPolicy>;
  inventoryQuantities?: InputMaybe<Array<ProductSetInventoryInput>>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  optionValues: Array<VariantOptionValueInput>;
  position?: InputMaybe<Scalars['Int']['input']>;
  price?: InputMaybe<Scalars['Money']['input']>;
  requiresComponents?: InputMaybe<Scalars['Boolean']['input']>;
  sku?: InputMaybe<Scalars['String']['input']>;
  taxCode?: InputMaybe<Scalars['String']['input']>;
  taxable?: InputMaybe<Scalars['Boolean']['input']>;
};

export const ProductVariantSortKeys = {
  FullTitle: 'FULL_TITLE',
  Id: 'ID',
  InventoryLevelsAvailable: 'INVENTORY_LEVELS_AVAILABLE',
  InventoryManagement: 'INVENTORY_MANAGEMENT',
  InventoryPolicy: 'INVENTORY_POLICY',
  InventoryQuantity: 'INVENTORY_QUANTITY',
  Name: 'NAME',
  Popular: 'POPULAR',
  Position: 'POSITION',
  Relevance: 'RELEVANCE',
  Sku: 'SKU',
  Title: 'TITLE'
} as const;

export type ProductVariantSortKeys = typeof ProductVariantSortKeys[keyof typeof ProductVariantSortKeys];
export type ProductVariantsBulkCreatePayload = {
  product?: Maybe<Product>;
  productVariants?: Maybe<Array<ProductVariant>>;
  userErrors: Array<ProductVariantsBulkCreateUserError>;
};

export const ProductVariantsBulkCreateStrategy = {
  Default: 'DEFAULT',
  RemoveStandaloneVariant: 'REMOVE_STANDALONE_VARIANT'
} as const;

export type ProductVariantsBulkCreateStrategy = typeof ProductVariantsBulkCreateStrategy[keyof typeof ProductVariantsBulkCreateStrategy];
export type ProductVariantsBulkCreateUserError = DisplayableError & {
  code?: Maybe<ProductVariantsBulkCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductVariantsBulkCreateUserErrorCode = {
  CannotSetNameForLinkedOptionValue: 'CANNOT_SET_NAME_FOR_LINKED_OPTION_VALUE',
  GreaterThanOrEqualTo: 'GREATER_THAN_OR_EQUAL_TO',
  Invalid: 'INVALID',
  InvalidInput: 'INVALID_INPUT',
  MustBeForThisProduct: 'MUST_BE_FOR_THIS_PRODUCT',
  NeedToAddOptionValues: 'NEED_TO_ADD_OPTION_VALUES',
  NegativePriceValue: 'NEGATIVE_PRICE_VALUE',
  NotDefinedForShop: 'NOT_DEFINED_FOR_SHOP',
  NoKeyOnCreate: 'NO_KEY_ON_CREATE',
  OptionValuesForNumberOfUnknownOptions: 'OPTION_VALUES_FOR_NUMBER_OF_UNKNOWN_OPTIONS',
  ProductDoesNotExist: 'PRODUCT_DOES_NOT_EXIST',
  ProductSuspended: 'PRODUCT_SUSPENDED',
  SubscriptionViolation: 'SUBSCRIPTION_VIOLATION',
  TooManyInventoryLocations: 'TOO_MANY_INVENTORY_LOCATIONS',
  TrackedVariantLocationNotFound: 'TRACKED_VARIANT_LOCATION_NOT_FOUND',
  UnsupportedCombinedListingParentOperation: 'UNSUPPORTED_COMBINED_LISTING_PARENT_OPERATION',
  VariantAlreadyExists: 'VARIANT_ALREADY_EXISTS',
  VariantAlreadyExistsChangeOptionValue: 'VARIANT_ALREADY_EXISTS_CHANGE_OPTION_VALUE'
} as const;

export type ProductVariantsBulkCreateUserErrorCode = typeof ProductVariantsBulkCreateUserErrorCode[keyof typeof ProductVariantsBulkCreateUserErrorCode];
export type ProductVariantsBulkDeletePayload = {
  product?: Maybe<Product>;
  userErrors: Array<ProductVariantsBulkDeleteUserError>;
};

export type ProductVariantsBulkDeleteUserError = DisplayableError & {
  code?: Maybe<ProductVariantsBulkDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductVariantsBulkDeleteUserErrorCode = {
  AtLeastOneVariantDoesNotBelongToTheProduct: 'AT_LEAST_ONE_VARIANT_DOES_NOT_BELONG_TO_THE_PRODUCT',
  CannotDeleteLastVariant: 'CANNOT_DELETE_LAST_VARIANT',
  ProductDoesNotExist: 'PRODUCT_DOES_NOT_EXIST',
  UnsupportedCombinedListingParentOperation: 'UNSUPPORTED_COMBINED_LISTING_PARENT_OPERATION'
} as const;

export type ProductVariantsBulkDeleteUserErrorCode = typeof ProductVariantsBulkDeleteUserErrorCode[keyof typeof ProductVariantsBulkDeleteUserErrorCode];
export type ProductVariantsBulkInput = {
  barcode?: InputMaybe<Scalars['String']['input']>;
  compareAtPrice?: InputMaybe<Scalars['Money']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  inventoryItem?: InputMaybe<InventoryItemInput>;
  inventoryPolicy?: InputMaybe<ProductVariantInventoryPolicy>;
  inventoryQuantities?: InputMaybe<Array<InventoryLevelInput>>;
  mediaId?: InputMaybe<Scalars['ID']['input']>;
  mediaSrc?: InputMaybe<Array<Scalars['String']['input']>>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  optionValues?: InputMaybe<Array<VariantOptionValueInput>>;
  price?: InputMaybe<Scalars['Money']['input']>;
  requiresComponents?: InputMaybe<Scalars['Boolean']['input']>;
  taxCode?: InputMaybe<Scalars['String']['input']>;
  taxable?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductVariantsBulkReorderPayload = {
  product?: Maybe<Product>;
  userErrors: Array<ProductVariantsBulkReorderUserError>;
};

export type ProductVariantsBulkReorderUserError = DisplayableError & {
  code?: Maybe<ProductVariantsBulkReorderUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductVariantsBulkReorderUserErrorCode = {
  DuplicatedVariantId: 'DUPLICATED_VARIANT_ID',
  InvalidPosition: 'INVALID_POSITION',
  MissingVariant: 'MISSING_VARIANT',
  ProductDoesNotExist: 'PRODUCT_DOES_NOT_EXIST'
} as const;

export type ProductVariantsBulkReorderUserErrorCode = typeof ProductVariantsBulkReorderUserErrorCode[keyof typeof ProductVariantsBulkReorderUserErrorCode];
export type ProductVariantsBulkUpdatePayload = {
  product?: Maybe<Product>;
  productVariants?: Maybe<Array<ProductVariant>>;
  userErrors: Array<ProductVariantsBulkUpdateUserError>;
};

export type ProductVariantsBulkUpdateUserError = DisplayableError & {
  code?: Maybe<ProductVariantsBulkUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ProductVariantsBulkUpdateUserErrorCode = {
  CannotSetNameForLinkedOptionValue: 'CANNOT_SET_NAME_FOR_LINKED_OPTION_VALUE',
  CannotSpecifyBoth: 'CANNOT_SPECIFY_BOTH',
  GreaterThanOrEqualTo: 'GREATER_THAN_OR_EQUAL_TO',
  InvalidInput: 'INVALID_INPUT',
  MustBeForThisProduct: 'MUST_BE_FOR_THIS_PRODUCT',
  MustSpecifyOneOfPair: 'MUST_SPECIFY_ONE_OF_PAIR',
  NeedToAddOptionValues: 'NEED_TO_ADD_OPTION_VALUES',
  NegativePriceValue: 'NEGATIVE_PRICE_VALUE',
  NotDefinedForShop: 'NOT_DEFINED_FOR_SHOP',
  NoInventoryQuantitesDuringUpdate: 'NO_INVENTORY_QUANTITES_DURING_UPDATE',
  NoInventoryQuantitiesOnVariantsUpdate: 'NO_INVENTORY_QUANTITIES_ON_VARIANTS_UPDATE',
  OptionDoesNotExist: 'OPTION_DOES_NOT_EXIST',
  OptionValuesForNumberOfUnknownOptions: 'OPTION_VALUES_FOR_NUMBER_OF_UNKNOWN_OPTIONS',
  OptionValueDoesNotExist: 'OPTION_VALUE_DOES_NOT_EXIST',
  ProductDoesNotExist: 'PRODUCT_DOES_NOT_EXIST',
  ProductSuspended: 'PRODUCT_SUSPENDED',
  ProductVariantDoesNotExist: 'PRODUCT_VARIANT_DOES_NOT_EXIST',
  ProductVariantIdMissing: 'PRODUCT_VARIANT_ID_MISSING',
  SubscriptionViolation: 'SUBSCRIPTION_VIOLATION',
  UnsupportedCombinedListingParentOperation: 'UNSUPPORTED_COMBINED_LISTING_PARENT_OPERATION',
  VariantAlreadyExists: 'VARIANT_ALREADY_EXISTS'
} as const;

export type ProductVariantsBulkUpdateUserErrorCode = typeof ProductVariantsBulkUpdateUserErrorCode[keyof typeof ProductVariantsBulkUpdateUserErrorCode];
export const ProfileItemSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  InventoryTotal: 'INVENTORY_TOTAL',
  ProductType: 'PRODUCT_TYPE',
  PublishedAt: 'PUBLISHED_AT',
  Relevance: 'RELEVANCE',
  Title: 'TITLE',
  UpdatedAt: 'UPDATED_AT',
  Vendor: 'VENDOR'
} as const;

export type ProfileItemSortKeys = typeof ProfileItemSortKeys[keyof typeof ProfileItemSortKeys];
export type PubSubServerPixelUpdatePayload = {
  serverPixel?: Maybe<ServerPixel>;
  userErrors: Array<ErrorsServerPixelUserError>;
};

export type PubSubWebhookSubscriptionCreatePayload = {
  userErrors: Array<PubSubWebhookSubscriptionCreateUserError>;
  webhookSubscription?: Maybe<WebhookSubscription>;
};

export type PubSubWebhookSubscriptionCreateUserError = DisplayableError & {
  code?: Maybe<PubSubWebhookSubscriptionCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PubSubWebhookSubscriptionCreateUserErrorCode = {
  InvalidParameters: 'INVALID_PARAMETERS',
  Taken: 'TAKEN'
} as const;

export type PubSubWebhookSubscriptionCreateUserErrorCode = typeof PubSubWebhookSubscriptionCreateUserErrorCode[keyof typeof PubSubWebhookSubscriptionCreateUserErrorCode];
export type PubSubWebhookSubscriptionInput = {
  filter?: InputMaybe<Scalars['String']['input']>;
  format?: InputMaybe<WebhookSubscriptionFormat>;
  includeFields?: InputMaybe<Array<Scalars['String']['input']>>;
  metafieldNamespaces?: InputMaybe<Array<Scalars['String']['input']>>;
  pubSubProject: Scalars['String']['input'];
  pubSubTopic: Scalars['String']['input'];
};

export type PubSubWebhookSubscriptionUpdatePayload = {
  userErrors: Array<PubSubWebhookSubscriptionUpdateUserError>;
  webhookSubscription?: Maybe<WebhookSubscription>;
};

export type PubSubWebhookSubscriptionUpdateUserError = DisplayableError & {
  code?: Maybe<PubSubWebhookSubscriptionUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PubSubWebhookSubscriptionUpdateUserErrorCode = {
  InvalidParameters: 'INVALID_PARAMETERS'
} as const;

export type PubSubWebhookSubscriptionUpdateUserErrorCode = typeof PubSubWebhookSubscriptionUpdateUserErrorCode[keyof typeof PubSubWebhookSubscriptionUpdateUserErrorCode];
export type Publication = Node & {
  /** @deprecated Use [AppCatalog.apps](https://shopify.dev/api/admin-graphql/unstable/objects/AppCatalog#connection-appcatalog-apps) instead. */
  app: App;
  autoPublish: Scalars['Boolean']['output'];
  catalog?: Maybe<Catalog>;
  collectionPublicationsV3: ResourcePublicationConnection;
  collections: CollectionConnection;
  hasCollection: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** @deprecated Use [Catalog.title](https://shopify.dev/api/admin-graphql/unstable/interfaces/Catalog#field-catalog-title) instead. */
  name: Scalars['String']['output'];
  operation?: Maybe<PublicationOperation>;
  productPublicationsV3: ResourcePublicationConnection;
  products: ProductConnection;
  supportsFuturePublishing: Scalars['Boolean']['output'];
};


export type PublicationCollectionPublicationsV3Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PublicationCollectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PublicationHasCollectionArgs = {
  id: Scalars['ID']['input'];
};


export type PublicationProductPublicationsV3Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PublicationProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PublicationConnection = {
  edges: Array<PublicationEdge>;
  nodes: Array<Publication>;
  pageInfo: PageInfo;
};

export type PublicationCreateInput = {
  autoPublish?: InputMaybe<Scalars['Boolean']['input']>;
  catalogId?: InputMaybe<Scalars['ID']['input']>;
  defaultState?: InputMaybe<PublicationCreateInputPublicationDefaultState>;
};

export const PublicationCreateInputPublicationDefaultState = {
  AllProducts: 'ALL_PRODUCTS',
  Empty: 'EMPTY'
} as const;

export type PublicationCreateInputPublicationDefaultState = typeof PublicationCreateInputPublicationDefaultState[keyof typeof PublicationCreateInputPublicationDefaultState];
export type PublicationCreatePayload = {
  publication?: Maybe<Publication>;
  userErrors: Array<PublicationUserError>;
};

export type PublicationDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<PublicationUserError>;
};

export type PublicationEdge = {
  cursor: Scalars['String']['output'];
  node: Publication;
};

export type PublicationInput = {
  publicationId?: InputMaybe<Scalars['ID']['input']>;
  publishDate?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PublicationOperation = AddAllProductsOperation | CatalogCsvOperation | PublicationResourceOperation;

export type PublicationResourceOperation = Node & ResourceOperation & {
  id: Scalars['ID']['output'];
  processedRowCount?: Maybe<Scalars['Int']['output']>;
  rowCount?: Maybe<RowCount>;
  status: ResourceOperationStatus;
};

export type PublicationUpdateInput = {
  autoPublish?: InputMaybe<Scalars['Boolean']['input']>;
  publishablesToAdd?: InputMaybe<Array<Scalars['ID']['input']>>;
  publishablesToRemove?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type PublicationUpdatePayload = {
  publication?: Maybe<Publication>;
  userErrors: Array<PublicationUserError>;
};

export type PublicationUserError = DisplayableError & {
  code?: Maybe<PublicationUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const PublicationUserErrorCode = {
  Blank: 'BLANK',
  CannotModifyAppCatalog: 'CANNOT_MODIFY_APP_CATALOG',
  CannotModifyAppCatalogPublication: 'CANNOT_MODIFY_APP_CATALOG_PUBLICATION',
  CannotModifyMarketCatalog: 'CANNOT_MODIFY_MARKET_CATALOG',
  CannotModifyMarketCatalogPublication: 'CANNOT_MODIFY_MARKET_CATALOG_PUBLICATION',
  CatalogNotFound: 'CATALOG_NOT_FOUND',
  Invalid: 'INVALID',
  InvalidPublishableId: 'INVALID_PUBLISHABLE_ID',
  MarketNotFound: 'MARKET_NOT_FOUND',
  ProductTypeIncompatibleWithCatalogType: 'PRODUCT_TYPE_INCOMPATIBLE_WITH_CATALOG_TYPE',
  PublicationLocked: 'PUBLICATION_LOCKED',
  PublicationNotFound: 'PUBLICATION_NOT_FOUND',
  PublicationUpdateLimitExceeded: 'PUBLICATION_UPDATE_LIMIT_EXCEEDED',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  TooShort: 'TOO_SHORT',
  UnsupportedPublicationAction: 'UNSUPPORTED_PUBLICATION_ACTION',
  UnsupportedPublishableType: 'UNSUPPORTED_PUBLISHABLE_TYPE'
} as const;

export type PublicationUserErrorCode = typeof PublicationUserErrorCode[keyof typeof PublicationUserErrorCode];
export type Publishable = {
  availablePublicationsCount?: Maybe<Count>;
  /** @deprecated Use `resourcePublicationsCount` instead. */
  publicationCount: Scalars['Int']['output'];
  /** @deprecated Use `publishedOnPublication` instead. */
  publishedOnChannel: Scalars['Boolean']['output'];
  /** @deprecated Use `publishedOnCurrentPublication` instead. */
  publishedOnCurrentChannel: Scalars['Boolean']['output'];
  publishedOnCurrentPublication: Scalars['Boolean']['output'];
  publishedOnPublication: Scalars['Boolean']['output'];
  resourcePublications: ResourcePublicationConnection;
  resourcePublicationsCount?: Maybe<Count>;
  resourcePublicationsV2: ResourcePublicationV2Connection;
  /** @deprecated Use `unpublishedPublications` instead. */
  unpublishedChannels: ChannelConnection;
  unpublishedPublications: PublicationConnection;
};


export type PublishablePublicationCountArgs = {
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PublishablePublishedOnChannelArgs = {
  channelId: Scalars['ID']['input'];
};


export type PublishablePublishedOnPublicationArgs = {
  publicationId: Scalars['ID']['input'];
};


export type PublishableResourcePublicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PublishableResourcePublicationsCountArgs = {
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PublishableResourcePublicationsV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  catalogType?: InputMaybe<CatalogType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  onlyPublished?: InputMaybe<Scalars['Boolean']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PublishableUnpublishedChannelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type PublishableUnpublishedPublicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PublishablePublishPayload = {
  publishable?: Maybe<Publishable>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type PublishablePublishToCurrentChannelPayload = {
  publishable?: Maybe<Publishable>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type PublishableUnpublishPayload = {
  publishable?: Maybe<Publishable>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type PublishableUnpublishToCurrentChannelPayload = {
  publishable?: Maybe<Publishable>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type PurchasingCompany = {
  company: Company;
  contact?: Maybe<CompanyContact>;
  location: CompanyLocation;
};

export type PurchasingCompanyInput = {
  companyContactId: Scalars['ID']['input'];
  companyId: Scalars['ID']['input'];
  companyLocationId: Scalars['ID']['input'];
};

export type PurchasingEntity = Customer | PurchasingCompany;

export type PurchasingEntityInput = {
  customerId?: InputMaybe<Scalars['ID']['input']>;
  purchasingCompany?: InputMaybe<PurchasingCompanyInput>;
};

export type QuantityPriceBreak = Node & {
  id: Scalars['ID']['output'];
  minimumQuantity: Scalars['Int']['output'];
  price: MoneyV2;
  priceList: PriceList;
  variant: ProductVariant;
};

export type QuantityPriceBreakConnection = {
  edges: Array<QuantityPriceBreakEdge>;
  nodes: Array<QuantityPriceBreak>;
  pageInfo: PageInfo;
};

export type QuantityPriceBreakEdge = {
  cursor: Scalars['String']['output'];
  node: QuantityPriceBreak;
};

export type QuantityPriceBreakInput = {
  minimumQuantity: Scalars['Int']['input'];
  price: MoneyInput;
  variantId: Scalars['ID']['input'];
};

export const QuantityPriceBreakSortKeys = {
  Id: 'ID',
  MinimumQuantity: 'MINIMUM_QUANTITY',
  Relevance: 'RELEVANCE'
} as const;

export type QuantityPriceBreakSortKeys = typeof QuantityPriceBreakSortKeys[keyof typeof QuantityPriceBreakSortKeys];
export type QuantityPricingByVariantUpdateInput = {
  pricesToAdd: Array<PriceListPriceInput>;
  pricesToDeleteByVariantId: Array<Scalars['ID']['input']>;
  quantityPriceBreaksToAdd: Array<QuantityPriceBreakInput>;
  quantityPriceBreaksToDelete: Array<Scalars['ID']['input']>;
  quantityRulesToAdd: Array<QuantityRuleInput>;
  quantityRulesToDeleteByVariantId: Array<Scalars['ID']['input']>;
};

export type QuantityPricingByVariantUpdatePayload = {
  productVariants?: Maybe<Array<ProductVariant>>;
  userErrors: Array<QuantityPricingByVariantUserError>;
};

export type QuantityPricingByVariantUserError = DisplayableError & {
  code?: Maybe<QuantityPricingByVariantUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const QuantityPricingByVariantUserErrorCode = {
  Blank: 'BLANK',
  GenericError: 'GENERIC_ERROR',
  PriceAddCurrencyMismatch: 'PRICE_ADD_CURRENCY_MISMATCH',
  PriceAddDuplicateInputForVariant: 'PRICE_ADD_DUPLICATE_INPUT_FOR_VARIANT',
  PriceAddVariantNotFound: 'PRICE_ADD_VARIANT_NOT_FOUND',
  PriceDeletePriceNotFixed: 'PRICE_DELETE_PRICE_NOT_FIXED',
  PriceDeleteVariantNotFound: 'PRICE_DELETE_VARIANT_NOT_FOUND',
  PriceListNotFound: 'PRICE_LIST_NOT_FOUND',
  QuantityPriceBreakAddCurrencyMismatch: 'QUANTITY_PRICE_BREAK_ADD_CURRENCY_MISMATCH',
  QuantityPriceBreakAddDuplicateInputForVariantAndMin: 'QUANTITY_PRICE_BREAK_ADD_DUPLICATE_INPUT_FOR_VARIANT_AND_MIN',
  QuantityPriceBreakAddFailedToSave: 'QUANTITY_PRICE_BREAK_ADD_FAILED_TO_SAVE',
  QuantityPriceBreakAddInvalid: 'QUANTITY_PRICE_BREAK_ADD_INVALID',
  QuantityPriceBreakAddLimitExceeded: 'QUANTITY_PRICE_BREAK_ADD_LIMIT_EXCEEDED',
  QuantityPriceBreakAddMinHigherThanQuantityRulesMax: 'QUANTITY_PRICE_BREAK_ADD_MIN_HIGHER_THAN_QUANTITY_RULES_MAX',
  QuantityPriceBreakAddMinLowerThanQuantityRulesMin: 'QUANTITY_PRICE_BREAK_ADD_MIN_LOWER_THAN_QUANTITY_RULES_MIN',
  QuantityPriceBreakAddMinNotAMultipleOfQuantityRulesIncrement: 'QUANTITY_PRICE_BREAK_ADD_MIN_NOT_A_MULTIPLE_OF_QUANTITY_RULES_INCREMENT',
  QuantityPriceBreakAddPriceListPriceNotFound: 'QUANTITY_PRICE_BREAK_ADD_PRICE_LIST_PRICE_NOT_FOUND',
  QuantityPriceBreakAddVariantNotFound: 'QUANTITY_PRICE_BREAK_ADD_VARIANT_NOT_FOUND',
  QuantityPriceBreakDeleteFailed: 'QUANTITY_PRICE_BREAK_DELETE_FAILED',
  QuantityPriceBreakDeleteNotFound: 'QUANTITY_PRICE_BREAK_DELETE_NOT_FOUND',
  QuantityRuleAddCatalogContextNotSupported: 'QUANTITY_RULE_ADD_CATALOG_CONTEXT_NOT_SUPPORTED',
  QuantityRuleAddDuplicateInputForVariant: 'QUANTITY_RULE_ADD_DUPLICATE_INPUT_FOR_VARIANT',
  QuantityRuleAddIncrementIsGreaterThanMinimum: 'QUANTITY_RULE_ADD_INCREMENT_IS_GREATER_THAN_MINIMUM',
  QuantityRuleAddIncrementIsLessThanOne: 'QUANTITY_RULE_ADD_INCREMENT_IS_LESS_THAN_ONE',
  QuantityRuleAddIncrementNotAMultipleOfQuantityPriceBreakMin: 'QUANTITY_RULE_ADD_INCREMENT_NOT_A_MULTIPLE_OF_QUANTITY_PRICE_BREAK_MIN',
  QuantityRuleAddMaximumIsLessThanOne: 'QUANTITY_RULE_ADD_MAXIMUM_IS_LESS_THAN_ONE',
  QuantityRuleAddMaximumNotAMultipleOfIncrement: 'QUANTITY_RULE_ADD_MAXIMUM_NOT_A_MULTIPLE_OF_INCREMENT',
  QuantityRuleAddMaxLowerThanQuantityPriceBreakMin: 'QUANTITY_RULE_ADD_MAX_LOWER_THAN_QUANTITY_PRICE_BREAK_MIN',
  QuantityRuleAddMinimumGreaterThanMaximum: 'QUANTITY_RULE_ADD_MINIMUM_GREATER_THAN_MAXIMUM',
  QuantityRuleAddMinimumIsLessThanOne: 'QUANTITY_RULE_ADD_MINIMUM_IS_LESS_THAN_ONE',
  QuantityRuleAddMinimumNotAMultipleOfIncrement: 'QUANTITY_RULE_ADD_MINIMUM_NOT_A_MULTIPLE_OF_INCREMENT',
  QuantityRuleAddMinHigherThanQuantityPriceBreakMin: 'QUANTITY_RULE_ADD_MIN_HIGHER_THAN_QUANTITY_PRICE_BREAK_MIN',
  QuantityRuleAddVariantNotFound: 'QUANTITY_RULE_ADD_VARIANT_NOT_FOUND',
  QuantityRuleDeleteRuleNotFound: 'QUANTITY_RULE_DELETE_RULE_NOT_FOUND',
  QuantityRuleDeleteVariantNotFound: 'QUANTITY_RULE_DELETE_VARIANT_NOT_FOUND'
} as const;

export type QuantityPricingByVariantUserErrorCode = typeof QuantityPricingByVariantUserErrorCode[keyof typeof QuantityPricingByVariantUserErrorCode];
export type QuantityRule = {
  increment: Scalars['Int']['output'];
  isDefault: Scalars['Boolean']['output'];
  maximum?: Maybe<Scalars['Int']['output']>;
  minimum: Scalars['Int']['output'];
  originType: QuantityRuleOriginType;
  productVariant: ProductVariant;
};

export type QuantityRuleConnection = {
  edges: Array<QuantityRuleEdge>;
  nodes: Array<QuantityRule>;
  pageInfo: PageInfo;
};

export type QuantityRuleEdge = {
  cursor: Scalars['String']['output'];
  node: QuantityRule;
};

export type QuantityRuleInput = {
  increment: Scalars['Int']['input'];
  maximum?: InputMaybe<Scalars['Int']['input']>;
  minimum: Scalars['Int']['input'];
  variantId: Scalars['ID']['input'];
};

export const QuantityRuleOriginType = {
  Fixed: 'FIXED',
  Relative: 'RELATIVE'
} as const;

export type QuantityRuleOriginType = typeof QuantityRuleOriginType[keyof typeof QuantityRuleOriginType];
export type QuantityRuleUserError = DisplayableError & {
  code?: Maybe<QuantityRuleUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const QuantityRuleUserErrorCode = {
  Blank: 'BLANK',
  CatalogContextDoesNotSupportQuantityRules: 'CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_RULES',
  DuplicateInputForVariant: 'DUPLICATE_INPUT_FOR_VARIANT',
  GenericError: 'GENERIC_ERROR',
  GreaterThanOrEqualTo: 'GREATER_THAN_OR_EQUAL_TO',
  IncrementIsGreaterThanMinimum: 'INCREMENT_IS_GREATER_THAN_MINIMUM',
  IncrementNotAMultipleOfQuantityPriceBreakMinimum: 'INCREMENT_NOT_A_MULTIPLE_OF_QUANTITY_PRICE_BREAK_MINIMUM',
  MaximumIsLowerThanQuantityPriceBreakMinimum: 'MAXIMUM_IS_LOWER_THAN_QUANTITY_PRICE_BREAK_MINIMUM',
  MaximumNotMultipleOfIncrement: 'MAXIMUM_NOT_MULTIPLE_OF_INCREMENT',
  MinimumIsGreaterThanMaximum: 'MINIMUM_IS_GREATER_THAN_MAXIMUM',
  MinimumIsHigherThanQuantityPriceBreakMinimum: 'MINIMUM_IS_HIGHER_THAN_QUANTITY_PRICE_BREAK_MINIMUM',
  MinimumNotMultipleOfIncrement: 'MINIMUM_NOT_MULTIPLE_OF_INCREMENT',
  PriceListDoesNotExist: 'PRICE_LIST_DOES_NOT_EXIST',
  ProductVariantDoesNotExist: 'PRODUCT_VARIANT_DOES_NOT_EXIST',
  VariantQuantityRuleDoesNotExist: 'VARIANT_QUANTITY_RULE_DOES_NOT_EXIST'
} as const;

export type QuantityRuleUserErrorCode = typeof QuantityRuleUserErrorCode[keyof typeof QuantityRuleUserErrorCode];
export type QuantityRulesAddPayload = {
  quantityRules?: Maybe<Array<QuantityRule>>;
  userErrors: Array<QuantityRuleUserError>;
};

export type QuantityRulesDeletePayload = {
  deletedQuantityRulesVariantIds?: Maybe<Array<Scalars['ID']['output']>>;
  userErrors: Array<QuantityRuleUserError>;
};

export type QueryRoot = {
  abandonedCheckouts: AbandonedCheckoutConnection;
  abandonedCheckoutsCount?: Maybe<Count>;
  abandonment?: Maybe<Abandonment>;
  abandonmentByAbandonedCheckoutId?: Maybe<Abandonment>;
  app?: Maybe<App>;
  appByHandle?: Maybe<App>;
  appByKey?: Maybe<App>;
  appDiscountType?: Maybe<AppDiscountType>;
  appDiscountTypes: Array<AppDiscountType>;
  appInstallation?: Maybe<AppInstallation>;
  appInstallations: AppInstallationConnection;
  article?: Maybe<Article>;
  articleTags: Array<Scalars['String']['output']>;
  articles: ArticleConnection;
  assignedFulfillmentOrders: FulfillmentOrderConnection;
  /** @deprecated Use `automaticDiscountNode` instead. */
  automaticDiscount?: Maybe<DiscountAutomatic>;
  automaticDiscountNode?: Maybe<DiscountAutomaticNode>;
  automaticDiscountNodes: DiscountAutomaticNodeConnection;
  automaticDiscountSavedSearches: SavedSearchConnection;
  /** @deprecated Use `automaticDiscountNodes` instead. */
  automaticDiscounts: DiscountAutomaticConnection;
  availableCarrierServices: Array<DeliveryCarrierServiceAndLocations>;
  availableLocales: Array<Locale>;
  blog?: Maybe<Blog>;
  blogs: BlogConnection;
  blogsCount?: Maybe<Count>;
  businessEntities: Array<BusinessEntity>;
  businessEntity?: Maybe<BusinessEntity>;
  carrierService?: Maybe<DeliveryCarrierService>;
  carrierServices: DeliveryCarrierServiceConnection;
  cartTransforms: CartTransformConnection;
  cashTrackingSession?: Maybe<CashTrackingSession>;
  cashTrackingSessions: CashTrackingSessionConnection;
  catalog?: Maybe<Catalog>;
  catalogOperations: Array<ResourceOperation>;
  catalogs: CatalogConnection;
  catalogsCount?: Maybe<Count>;
  /** @deprecated Use `publication` instead. */
  channel?: Maybe<Channel>;
  /** @deprecated Use `publications` instead. */
  channels: ChannelConnection;
  checkoutBranding?: Maybe<CheckoutBranding>;
  checkoutProfile?: Maybe<CheckoutProfile>;
  checkoutProfiles: CheckoutProfileConnection;
  codeDiscountNode?: Maybe<DiscountCodeNode>;
  codeDiscountNodeByCode?: Maybe<DiscountCodeNode>;
  codeDiscountNodes: DiscountCodeNodeConnection;
  codeDiscountSavedSearches: SavedSearchConnection;
  collection?: Maybe<Collection>;
  /** @deprecated Use `collectionByIdentifier` instead. */
  collectionByHandle?: Maybe<Collection>;
  collectionRulesConditions: Array<CollectionRuleConditions>;
  collectionSavedSearches: SavedSearchConnection;
  collections: CollectionConnection;
  collectionsCount?: Maybe<Count>;
  comment?: Maybe<Comment>;
  comments: CommentConnection;
  companies: CompanyConnection;
  companiesCount?: Maybe<Count>;
  company?: Maybe<Company>;
  companyContact?: Maybe<CompanyContact>;
  companyContactRole?: Maybe<CompanyContactRole>;
  companyLocation?: Maybe<CompanyLocation>;
  companyLocations: CompanyLocationConnection;
  currentAppInstallation: AppInstallation;
  currentBulkOperation?: Maybe<BulkOperation>;
  currentStaffMember?: Maybe<StaffMember>;
  customer?: Maybe<Customer>;
  customerAccountPage?: Maybe<CustomerAccountPage>;
  customerAccountPages?: Maybe<CustomerAccountPageConnection>;
  customerByIdentifier?: Maybe<Customer>;
  customerMergeJobStatus?: Maybe<CustomerMergeRequest>;
  customerMergePreview: CustomerMergePreview;
  customerPaymentMethod?: Maybe<CustomerPaymentMethod>;
  customerSavedSearches: SavedSearchConnection;
  customerSegmentMembers: CustomerSegmentMemberConnection;
  customerSegmentMembersQuery?: Maybe<CustomerSegmentMembersQuery>;
  customerSegmentMembership: SegmentMembershipResponse;
  customers: CustomerConnection;
  customersCount?: Maybe<Count>;
  /** @deprecated Use `events` instead. */
  deletionEvents: DeletionEventConnection;
  deliveryCustomization?: Maybe<DeliveryCustomization>;
  deliveryCustomizations: DeliveryCustomizationConnection;
  deliveryProfile?: Maybe<DeliveryProfile>;
  deliveryProfiles: DeliveryProfileConnection;
  deliveryPromiseParticipants?: Maybe<DeliveryPromiseParticipantConnection>;
  deliveryPromiseProvider?: Maybe<DeliveryPromiseProvider>;
  deliveryPromiseSettings: DeliveryPromiseSetting;
  deliverySettings?: Maybe<DeliverySetting>;
  discountCodesCount?: Maybe<Count>;
  discountNode?: Maybe<DiscountNode>;
  discountNodes: DiscountNodeConnection;
  discountNodesCount?: Maybe<Count>;
  discountRedeemCodeBulkCreation?: Maybe<DiscountRedeemCodeBulkCreation>;
  discountRedeemCodeSavedSearches: SavedSearchConnection;
  dispute?: Maybe<ShopifyPaymentsDispute>;
  disputeEvidence?: Maybe<ShopifyPaymentsDisputeEvidence>;
  disputes: ShopifyPaymentsDisputeConnection;
  domain?: Maybe<Domain>;
  draftOrder?: Maybe<DraftOrder>;
  draftOrderSavedSearches: SavedSearchConnection;
  draftOrderTag?: Maybe<DraftOrderTag>;
  draftOrders: DraftOrderConnection;
  event?: Maybe<Event>;
  events?: Maybe<EventConnection>;
  eventsCount?: Maybe<Count>;
  fileSavedSearches: SavedSearchConnection;
  files: FileConnection;
  fulfillment?: Maybe<Fulfillment>;
  fulfillmentConstraintRules: Array<FulfillmentConstraintRule>;
  fulfillmentOrder?: Maybe<FulfillmentOrder>;
  fulfillmentOrders: FulfillmentOrderConnection;
  fulfillmentService?: Maybe<FulfillmentService>;
  giftCard?: Maybe<GiftCard>;
  giftCards: GiftCardConnection;
  giftCardsCount?: Maybe<Count>;
  inventoryItem?: Maybe<InventoryItem>;
  inventoryItems: InventoryItemConnection;
  inventoryLevel?: Maybe<InventoryLevel>;
  inventoryProperties: InventoryProperties;
  job?: Maybe<Job>;
  location?: Maybe<Location>;
  locations: LocationConnection;
  /** @deprecated Use `locationsAvailableForDeliveryProfilesConnection` instead. */
  locationsAvailableForDeliveryProfiles?: Maybe<Array<Location>>;
  locationsAvailableForDeliveryProfilesConnection: LocationConnection;
  locationsCount?: Maybe<Count>;
  manualHoldsFulfillmentOrders: FulfillmentOrderConnection;
  market?: Maybe<Market>;
  marketByGeography?: Maybe<Market>;
  marketLocalizableResource?: Maybe<MarketLocalizableResource>;
  marketLocalizableResources: MarketLocalizableResourceConnection;
  marketLocalizableResourcesByIds: MarketLocalizableResourceConnection;
  marketingActivities: MarketingActivityConnection;
  marketingActivity?: Maybe<MarketingActivity>;
  marketingEvent?: Maybe<MarketingEvent>;
  marketingEvents: MarketingEventConnection;
  markets: MarketConnection;
  menu?: Maybe<Menu>;
  menus: MenuConnection;
  metafieldDefinition?: Maybe<MetafieldDefinition>;
  metafieldDefinitionTypes: Array<MetafieldDefinitionType>;
  metafieldDefinitions: MetafieldDefinitionConnection;
  metaobject?: Maybe<Metaobject>;
  metaobjectByHandle?: Maybe<Metaobject>;
  metaobjectDefinition?: Maybe<MetaobjectDefinition>;
  metaobjectDefinitionByType?: Maybe<MetaobjectDefinition>;
  metaobjectDefinitions: MetaobjectDefinitionConnection;
  metaobjects: MetaobjectConnection;
  mobilePlatformApplication?: Maybe<MobilePlatformApplication>;
  mobilePlatformApplications: MobilePlatformApplicationConnection;
  node?: Maybe<Node>;
  nodes: Array<Maybe<Node>>;
  onlineStore: OnlineStore;
  order?: Maybe<Order>;
  orderPaymentStatus?: Maybe<OrderPaymentStatus>;
  orderSavedSearches: SavedSearchConnection;
  orders: OrderConnection;
  ordersCount?: Maybe<Count>;
  page?: Maybe<Page>;
  pages: PageConnection;
  pagesCount?: Maybe<Count>;
  paymentCustomization?: Maybe<PaymentCustomization>;
  paymentCustomizations: PaymentCustomizationConnection;
  paymentTermsTemplates: Array<PaymentTermsTemplate>;
  pendingOrdersCount?: Maybe<Count>;
  priceList?: Maybe<PriceList>;
  priceLists: PriceListConnection;
  /** @deprecated Use `backupRegion` instead. */
  primaryMarket: Market;
  product?: Maybe<Product>;
  /** @deprecated Use `productByIdentifier` instead. */
  productByHandle?: Maybe<Product>;
  productByIdentifier?: Maybe<Product>;
  productDuplicateJob: ProductDuplicateJob;
  productFeed?: Maybe<ProductFeed>;
  productFeeds: ProductFeedConnection;
  productOperation?: Maybe<ProductOperation>;
  productResourceFeedback?: Maybe<ProductResourceFeedback>;
  productSavedSearches: SavedSearchConnection;
  productTags?: Maybe<StringConnection>;
  productTypes?: Maybe<StringConnection>;
  productVariant?: Maybe<ProductVariant>;
  productVariants: ProductVariantConnection;
  productVariantsCount?: Maybe<Count>;
  productVendors?: Maybe<StringConnection>;
  products: ProductConnection;
  productsCount?: Maybe<Count>;
  publicApiVersions: Array<ApiVersion>;
  publication?: Maybe<Publication>;
  publications: PublicationConnection;
  publicationsCount?: Maybe<Count>;
  publishedProductsCount?: Maybe<Count>;
  refund?: Maybe<Refund>;
  return?: Maybe<Return>;
  returnCalculate?: Maybe<CalculatedReturn>;
  returnableFulfillment?: Maybe<ReturnableFulfillment>;
  returnableFulfillments: ReturnableFulfillmentConnection;
  reverseDelivery?: Maybe<ReverseDelivery>;
  reverseFulfillmentOrder?: Maybe<ReverseFulfillmentOrder>;
  scriptTag?: Maybe<ScriptTag>;
  scriptTags: ScriptTagConnection;
  segment?: Maybe<Segment>;
  segmentFilterSuggestions: SegmentFilterConnection;
  segmentFilters: SegmentFilterConnection;
  segmentMigrations: SegmentMigrationConnection;
  segmentValueSuggestions: SegmentValueConnection;
  segments: SegmentConnection;
  segmentsCount?: Maybe<Count>;
  sellingPlanGroup?: Maybe<SellingPlanGroup>;
  sellingPlanGroups: SellingPlanGroupConnection;
  serverPixel?: Maybe<ServerPixel>;
  shop: Shop;
  shopBillingPreferences: ShopBillingPreferences;
  shopLocales: Array<ShopLocale>;
  shopifyFunction?: Maybe<ShopifyFunction>;
  shopifyFunctions: ShopifyFunctionConnection;
  shopifyPaymentsAccount?: Maybe<ShopifyPaymentsAccount>;
  staffMember?: Maybe<StaffMember>;
  staffMembers?: Maybe<StaffMemberConnection>;
  standardMetafieldDefinitionTemplates: StandardMetafieldDefinitionTemplateConnection;
  storeCreditAccount?: Maybe<StoreCreditAccount>;
  subscriptionBillingAttempt?: Maybe<SubscriptionBillingAttempt>;
  subscriptionBillingAttempts: SubscriptionBillingAttemptConnection;
  subscriptionBillingCycle?: Maybe<SubscriptionBillingCycle>;
  subscriptionBillingCycleBulkResults: SubscriptionBillingCycleConnection;
  subscriptionBillingCycles: SubscriptionBillingCycleConnection;
  subscriptionContract?: Maybe<SubscriptionContract>;
  subscriptionContracts: SubscriptionContractConnection;
  subscriptionDraft?: Maybe<SubscriptionDraft>;
  taxonomy?: Maybe<Taxonomy>;
  tenderTransactions: TenderTransactionConnection;
  theme?: Maybe<OnlineStoreTheme>;
  themes?: Maybe<OnlineStoreThemeConnection>;
  translatableResource?: Maybe<TranslatableResource>;
  translatableResources: TranslatableResourceConnection;
  translatableResourcesByIds: TranslatableResourceConnection;
  urlRedirect?: Maybe<UrlRedirect>;
  urlRedirectImport?: Maybe<UrlRedirectImport>;
  urlRedirectSavedSearches: SavedSearchConnection;
  urlRedirects: UrlRedirectConnection;
  urlRedirectsCount?: Maybe<Count>;
  validation?: Maybe<Validation>;
  validations: ValidationConnection;
  webPixel?: Maybe<WebPixel>;
  webhookSubscription?: Maybe<WebhookSubscription>;
  webhookSubscriptions: WebhookSubscriptionConnection;
  webhookSubscriptionsCount?: Maybe<Count>;
};


export type QueryRootAbandonedCheckoutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<AbandonedCheckoutSortKeys>;
};


export type QueryRootAbandonedCheckoutsCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootAbandonmentArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootAbandonmentByAbandonedCheckoutIdArgs = {
  abandonedCheckoutId: Scalars['ID']['input'];
};


export type QueryRootAppArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootAppByHandleArgs = {
  handle: Scalars['String']['input'];
};


export type QueryRootAppByKeyArgs = {
  apiKey: Scalars['String']['input'];
};


export type QueryRootAppDiscountTypeArgs = {
  functionId: Scalars['String']['input'];
};


export type QueryRootAppInstallationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootAppInstallationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<AppInstallationCategory>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  privacy?: InputMaybe<AppInstallationPrivacy>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<AppInstallationSortKeys>;
};


export type QueryRootArticleArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootArticleTagsArgs = {
  limit: Scalars['Int']['input'];
  sort?: InputMaybe<ArticleTagSort>;
};


export type QueryRootArticlesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<ArticleSortKeys>;
};


export type QueryRootAssignedFulfillmentOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assignmentStatus?: InputMaybe<FulfillmentOrderAssignmentStatus>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  locationIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<FulfillmentOrderSortKeys>;
};


export type QueryRootAutomaticDiscountArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootAutomaticDiscountNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootAutomaticDiscountNodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<AutomaticDiscountSortKeys>;
};


export type QueryRootAutomaticDiscountSavedSearchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootAutomaticDiscountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<AutomaticDiscountSortKeys>;
};


export type QueryRootBlogArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootBlogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<BlogSortKeys>;
};


export type QueryRootBlogsCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
};


export type QueryRootBusinessEntityArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootCarrierServiceArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCarrierServicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CarrierServiceSortKeys>;
};


export type QueryRootCartTransformsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootCashTrackingSessionArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCashTrackingSessionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CashTrackingSessionsSortKeys>;
};


export type QueryRootCatalogArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCatalogsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CatalogSortKeys>;
  type?: InputMaybe<CatalogType>;
};


export type QueryRootCatalogsCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<CatalogType>;
};


export type QueryRootChannelArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootChannelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootCheckoutBrandingArgs = {
  checkoutProfileId: Scalars['ID']['input'];
};


export type QueryRootCheckoutProfileArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCheckoutProfilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CheckoutProfileSortKeys>;
};


export type QueryRootCodeDiscountNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCodeDiscountNodeByCodeArgs = {
  code: Scalars['String']['input'];
};


export type QueryRootCodeDiscountNodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<CodeDiscountSortKeys>;
};


export type QueryRootCodeDiscountSavedSearchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootCollectionArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCollectionByHandleArgs = {
  handle: Scalars['String']['input'];
};


export type QueryRootCollectionSavedSearchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootCollectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<CollectionSortKeys>;
};


export type QueryRootCollectionsCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootCommentArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCommentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CommentSortKeys>;
};


export type QueryRootCompaniesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CompanySortKeys>;
};


export type QueryRootCompanyArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCompanyContactArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCompanyContactRoleArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCompanyLocationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCompanyLocationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CompanyLocationSortKeys>;
};


export type QueryRootCurrentBulkOperationArgs = {
  type?: InputMaybe<BulkOperationType>;
};


export type QueryRootCustomerArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCustomerAccountPageArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCustomerAccountPagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootCustomerByIdentifierArgs = {
  identifier: CustomerIdentifierInput;
};


export type QueryRootCustomerMergeJobStatusArgs = {
  jobId: Scalars['ID']['input'];
};


export type QueryRootCustomerMergePreviewArgs = {
  customerOneId: Scalars['ID']['input'];
  customerTwoId: Scalars['ID']['input'];
  overrideFields?: InputMaybe<CustomerMergeOverrideFields>;
};


export type QueryRootCustomerPaymentMethodArgs = {
  id: Scalars['ID']['input'];
  showRevoked?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootCustomerSavedSearchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CustomerSavedSearchSortKeys>;
};


export type QueryRootCustomerSegmentMembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  queryId?: InputMaybe<Scalars['ID']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  segmentId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
};


export type QueryRootCustomerSegmentMembersQueryArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootCustomerSegmentMembershipArgs = {
  customerId: Scalars['ID']['input'];
  segmentIds: Array<Scalars['ID']['input']>;
};


export type QueryRootCustomersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CustomerSortKeys>;
};


export type QueryRootCustomersCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
};


export type QueryRootDeletionEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<DeletionEventSortKeys>;
  subjectTypes?: InputMaybe<Array<DeletionEventSubjectType>>;
};


export type QueryRootDeliveryCustomizationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootDeliveryCustomizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootDeliveryProfileArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootDeliveryProfilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  merchantOwnedOnly?: InputMaybe<Scalars['Boolean']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootDeliveryPromiseParticipantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  brandedPromiseHandle: Scalars['String']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  ownerIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootDeliveryPromiseProviderArgs = {
  locationId: Scalars['ID']['input'];
};


export type QueryRootDiscountCodesCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
};


export type QueryRootDiscountNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootDiscountNodesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<DiscountSortKeys>;
};


export type QueryRootDiscountNodesCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootDiscountRedeemCodeBulkCreationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootDiscountRedeemCodeSavedSearchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<DiscountCodeSortKeys>;
};


export type QueryRootDisputeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootDisputeEvidenceArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootDisputesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootDomainArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootDraftOrderArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootDraftOrderSavedSearchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootDraftOrderTagArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootDraftOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<DraftOrderSortKeys>;
};


export type QueryRootEventArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<EventSortKeys>;
};


export type QueryRootEventsCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
};


export type QueryRootFileSavedSearchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootFilesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<FileSortKeys>;
};


export type QueryRootFulfillmentArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootFulfillmentOrderArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootFulfillmentOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeClosed?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<FulfillmentOrderSortKeys>;
};


export type QueryRootFulfillmentServiceArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootGiftCardArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootGiftCardsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<GiftCardSortKeys>;
};


export type QueryRootGiftCardsCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootInventoryItemArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootInventoryItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootInventoryLevelArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootJobArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootLocationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootLocationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeInactive?: InputMaybe<Scalars['Boolean']['input']>;
  includeLegacy?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<LocationSortKeys>;
};


export type QueryRootLocationsAvailableForDeliveryProfilesConnectionArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootLocationsCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
};


export type QueryRootManualHoldsFulfillmentOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootMarketArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootMarketByGeographyArgs = {
  countryCode: CountryCode;
};


export type QueryRootMarketLocalizableResourceArgs = {
  resourceId: Scalars['ID']['input'];
};


export type QueryRootMarketLocalizableResourcesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  resourceType: MarketLocalizableResourceType;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootMarketLocalizableResourcesByIdsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  resourceIds: Array<Scalars['ID']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootMarketingActivitiesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  marketingActivityIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  query?: InputMaybe<Scalars['String']['input']>;
  remoteIds?: InputMaybe<Array<Scalars['String']['input']>>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<MarketingActivitySortKeys>;
  utm?: InputMaybe<UtmInput>;
};


export type QueryRootMarketingActivityArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootMarketingEventArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootMarketingEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MarketingEventSortKeys>;
};


export type QueryRootMarketsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootMenuArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootMenusArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MenuSortKeys>;
};


export type QueryRootMetafieldDefinitionArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  constraintStatus?: InputMaybe<MetafieldDefinitionConstraintStatus>;
  constraintSubtype?: InputMaybe<MetafieldDefinitionConstraintSubtypeIdentifier>;
  first?: InputMaybe<Scalars['Int']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  ownerType: MetafieldOwnerType;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type QueryRootMetaobjectArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootMetaobjectByHandleArgs = {
  handle: MetaobjectHandleInput;
};


export type QueryRootMetaobjectDefinitionArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootMetaobjectDefinitionByTypeArgs = {
  type: Scalars['String']['input'];
};


export type QueryRootMetaobjectDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootMetaobjectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<Scalars['String']['input']>;
  type: Scalars['String']['input'];
};


export type QueryRootMobilePlatformApplicationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootMobilePlatformApplicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QueryRootOrderArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootOrderPaymentStatusArgs = {
  orderId: Scalars['ID']['input'];
  paymentReferenceId: Scalars['String']['input'];
};


export type QueryRootOrderSavedSearchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<OrderSortKeys>;
};


export type QueryRootOrdersCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootPageArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootPagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootPaymentCustomizationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootPaymentCustomizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootPaymentTermsTemplatesArgs = {
  paymentTermsType?: InputMaybe<PaymentTermsType>;
};


export type QueryRootPriceListArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootPriceListsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<PriceListSortKeys>;
};


export type QueryRootProductArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootProductByHandleArgs = {
  handle: Scalars['String']['input'];
};


export type QueryRootProductByIdentifierArgs = {
  identifier: ProductIdentifierInput;
};


export type QueryRootProductDuplicateJobArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootProductFeedArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootProductFeedsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootProductOperationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootProductResourceFeedbackArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootProductSavedSearchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootProductTagsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootProductTypesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootProductVariantArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootProductVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<ProductVariantSortKeys>;
};


export type QueryRootProductVariantsCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
};


export type QueryRootProductVendorsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<ProductSortKeys>;
};


export type QueryRootProductsCountArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootPublicationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootPublicationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  catalogType?: InputMaybe<CatalogType>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootPublicationsCountArgs = {
  catalogType?: InputMaybe<CatalogType>;
};


export type QueryRootPublishedProductsCountArgs = {
  publicationId: Scalars['ID']['input'];
};


export type QueryRootRefundArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootReturnArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootReturnCalculateArgs = {
  input: CalculateReturnInput;
};


export type QueryRootReturnableFulfillmentArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootReturnableFulfillmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderId: Scalars['ID']['input'];
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootReverseDeliveryArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootReverseFulfillmentOrderArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootScriptTagArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootScriptTagsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  src?: InputMaybe<Scalars['URL']['input']>;
};


export type QueryRootSegmentArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootSegmentFilterSuggestionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
  search: Scalars['String']['input'];
};


export type QueryRootSegmentFiltersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryRootSegmentMigrationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootSegmentValueSuggestionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filterQueryName?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  functionParameterQueryName?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search: Scalars['String']['input'];
};


export type QueryRootSegmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<SegmentSortKeys>;
};


export type QueryRootSellingPlanGroupArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootSellingPlanGroupsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<SellingPlanGroupSortKeys>;
};


export type QueryRootShopLocalesArgs = {
  published?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootShopifyFunctionArgs = {
  id: Scalars['String']['input'];
};


export type QueryRootShopifyFunctionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  apiType?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  useCreationUi?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootStaffMemberArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootStaffMembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<StaffMembersSortKeys>;
};


export type QueryRootStandardMetafieldDefinitionTemplatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  constraintStatus?: InputMaybe<MetafieldDefinitionConstraintStatus>;
  constraintSubtype?: InputMaybe<MetafieldDefinitionConstraintSubtypeIdentifier>;
  excludeActivated?: InputMaybe<Scalars['Boolean']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootStoreCreditAccountArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootSubscriptionBillingAttemptArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootSubscriptionBillingAttemptsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<SubscriptionBillingAttemptsSortKeys>;
};


export type QueryRootSubscriptionBillingCycleArgs = {
  billingCycleInput: SubscriptionBillingCycleInput;
};


export type QueryRootSubscriptionBillingCycleBulkResultsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  jobId: Scalars['ID']['input'];
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootSubscriptionBillingCyclesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  billingCyclesDateRangeSelector?: InputMaybe<SubscriptionBillingCyclesDateRangeSelector>;
  billingCyclesIndexRangeSelector?: InputMaybe<SubscriptionBillingCyclesIndexRangeSelector>;
  contractId: Scalars['ID']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<SubscriptionBillingCyclesSortKeys>;
};


export type QueryRootSubscriptionContractArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootSubscriptionContractsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootSubscriptionDraftArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootTenderTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootThemeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootThemesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  names?: InputMaybe<Array<Scalars['String']['input']>>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  roles?: InputMaybe<Array<ThemeRole>>;
};


export type QueryRootTranslatableResourceArgs = {
  resourceId: Scalars['ID']['input'];
};


export type QueryRootTranslatableResourcesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  resourceType: TranslatableResourceType;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootTranslatableResourcesByIdsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  resourceIds: Array<Scalars['ID']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootUrlRedirectArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootUrlRedirectImportArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootUrlRedirectSavedSearchesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QueryRootUrlRedirectsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<UrlRedirectSortKeys>;
};


export type QueryRootUrlRedirectsCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootValidationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootValidationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<ValidationSortKeys>;
};


export type QueryRootWebPixelArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryRootWebhookSubscriptionArgs = {
  id: Scalars['ID']['input'];
};


export type QueryRootWebhookSubscriptionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  callbackUrl?: InputMaybe<Scalars['URL']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  format?: InputMaybe<WebhookSubscriptionFormat>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<WebhookSubscriptionSortKeys>;
  topics?: InputMaybe<Array<WebhookSubscriptionTopic>>;
};


export type QueryRootWebhookSubscriptionsCountArgs = {
  query?: InputMaybe<Scalars['String']['input']>;
};

export type Refund = LegacyInteroperability & Node & {
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  duties?: Maybe<Array<RefundDuty>>;
  id: Scalars['ID']['output'];
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  note?: Maybe<Scalars['String']['output']>;
  order: Order;
  orderAdjustments: OrderAdjustmentConnection;
  refundLineItems: RefundLineItemConnection;
  refundShippingLines: RefundShippingLineConnection;
  return?: Maybe<Return>;
  staffMember?: Maybe<StaffMember>;
  /** @deprecated Use `totalRefundedSet` instead. */
  totalRefunded: MoneyV2;
  totalRefundedSet: MoneyBag;
  transactions: OrderTransactionConnection;
  updatedAt: Scalars['DateTime']['output'];
};


export type RefundOrderAdjustmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type RefundRefundLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type RefundRefundShippingLinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type RefundTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RefundAgreement = SalesAgreement & {
  app?: Maybe<App>;
  happenedAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  reason: OrderActionType;
  refund: Refund;
  sales: SaleConnection;
  user?: Maybe<StaffMember>;
};


export type RefundAgreementSalesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type RefundConnection = {
  edges: Array<RefundEdge>;
  nodes: Array<Refund>;
  pageInfo: PageInfo;
};

export type RefundCreatePayload = {
  order?: Maybe<Order>;
  refund?: Maybe<Refund>;
  userErrors: Array<UserError>;
};

export type RefundDuty = {
  amountSet: MoneyBag;
  originalDuty?: Maybe<Duty>;
};

export type RefundDutyInput = {
  dutyId: Scalars['ID']['input'];
  refundType?: InputMaybe<RefundDutyRefundType>;
};

export const RefundDutyRefundType = {
  Full: 'FULL',
  Proportional: 'PROPORTIONAL'
} as const;

export type RefundDutyRefundType = typeof RefundDutyRefundType[keyof typeof RefundDutyRefundType];
export type RefundEdge = {
  cursor: Scalars['String']['output'];
  node: Refund;
};

export type RefundInput = {
  currency?: InputMaybe<CurrencyCode>;
  discrepancyReason?: InputMaybe<OrderAdjustmentInputDiscrepancyReason>;
  note?: InputMaybe<Scalars['String']['input']>;
  notify?: InputMaybe<Scalars['Boolean']['input']>;
  orderId: Scalars['ID']['input'];
  refundDuties?: InputMaybe<Array<RefundDutyInput>>;
  refundLineItems?: InputMaybe<Array<RefundLineItemInput>>;
  shipping?: InputMaybe<ShippingRefundInput>;
  transactions?: InputMaybe<Array<OrderTransactionInput>>;
};

export type RefundLineItem = {
  id?: Maybe<Scalars['ID']['output']>;
  lineItem: LineItem;
  location?: Maybe<Location>;
  /** @deprecated Use `priceSet` instead. */
  price: Scalars['Money']['output'];
  priceSet: MoneyBag;
  quantity: Scalars['Int']['output'];
  restockType: RefundLineItemRestockType;
  restocked: Scalars['Boolean']['output'];
  /** @deprecated Use `subtotalSet` instead. */
  subtotal: Scalars['Money']['output'];
  subtotalSet: MoneyBag;
  /** @deprecated Use `totalTaxSet` instead. */
  totalTax: Scalars['Money']['output'];
  totalTaxSet: MoneyBag;
};

export type RefundLineItemConnection = {
  edges: Array<RefundLineItemEdge>;
  nodes: Array<RefundLineItem>;
  pageInfo: PageInfo;
};

export type RefundLineItemEdge = {
  cursor: Scalars['String']['output'];
  node: RefundLineItem;
};

export type RefundLineItemInput = {
  lineItemId: Scalars['ID']['input'];
  locationId?: InputMaybe<Scalars['ID']['input']>;
  quantity: Scalars['Int']['input'];
  restockType?: InputMaybe<RefundLineItemRestockType>;
};

export const RefundLineItemRestockType = {
  Cancel: 'CANCEL',
  LegacyRestock: 'LEGACY_RESTOCK',
  NoRestock: 'NO_RESTOCK',
  Return: 'RETURN'
} as const;

export type RefundLineItemRestockType = typeof RefundLineItemRestockType[keyof typeof RefundLineItemRestockType];
export type RefundShippingInput = {
  fullRefund?: InputMaybe<Scalars['Boolean']['input']>;
  shippingRefundAmount?: InputMaybe<MoneyInput>;
};

export type RefundShippingLine = Node & {
  id: Scalars['ID']['output'];
  shippingLine: ShippingLine;
  subtotalAmountSet: MoneyBag;
  taxAmountSet: MoneyBag;
};

export type RefundShippingLineConnection = {
  edges: Array<RefundShippingLineEdge>;
  nodes: Array<RefundShippingLine>;
  pageInfo: PageInfo;
};

export type RefundShippingLineEdge = {
  cursor: Scalars['String']['output'];
  node: RefundShippingLine;
};

export type RemoteAuthorizeNetCustomerPaymentProfileInput = {
  customerPaymentProfileId?: InputMaybe<Scalars['String']['input']>;
  customerProfileId: Scalars['String']['input'];
};

export type RemoteBraintreePaymentMethodInput = {
  customerId: Scalars['String']['input'];
  paymentMethodToken?: InputMaybe<Scalars['String']['input']>;
};

export type RemoteStripePaymentMethodInput = {
  customerId: Scalars['String']['input'];
  paymentMethodId?: InputMaybe<Scalars['String']['input']>;
};

export type ResourceAlert = {
  actions: Array<ResourceAlertAction>;
  content: Scalars['HTML']['output'];
  dismissibleHandle?: Maybe<Scalars['String']['output']>;
  icon?: Maybe<ResourceAlertIcon>;
  severity: ResourceAlertSeverity;
  title: Scalars['String']['output'];
};

export type ResourceAlertAction = {
  primary: Scalars['Boolean']['output'];
  show?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  url: Scalars['URL']['output'];
};

export const ResourceAlertIcon = {
  CheckmarkCircle: 'CHECKMARK_CIRCLE',
  InformationCircle: 'INFORMATION_CIRCLE'
} as const;

export type ResourceAlertIcon = typeof ResourceAlertIcon[keyof typeof ResourceAlertIcon];
export const ResourceAlertSeverity = {
  Critical: 'CRITICAL',
  Default: 'DEFAULT',
  Error: 'ERROR',
  Info: 'INFO',
  Success: 'SUCCESS',
  Warning: 'WARNING'
} as const;

export type ResourceAlertSeverity = typeof ResourceAlertSeverity[keyof typeof ResourceAlertSeverity];
export type ResourceFeedback = {
  /** @deprecated Use `details` instead. */
  appFeedback: Array<AppFeedback>;
  details: Array<AppFeedback>;
  summary: Scalars['String']['output'];
};

export type ResourceFeedbackCreateInput = {
  feedbackGeneratedAt: Scalars['DateTime']['input'];
  messages?: InputMaybe<Array<Scalars['String']['input']>>;
  state: ResourceFeedbackState;
};

export const ResourceFeedbackState = {
  Accepted: 'ACCEPTED',
  RequiresAction: 'REQUIRES_ACTION'
} as const;

export type ResourceFeedbackState = typeof ResourceFeedbackState[keyof typeof ResourceFeedbackState];
export type ResourceOperation = {
  id: Scalars['ID']['output'];
  processedRowCount?: Maybe<Scalars['Int']['output']>;
  rowCount?: Maybe<RowCount>;
  status: ResourceOperationStatus;
};

export const ResourceOperationStatus = {
  Active: 'ACTIVE',
  Complete: 'COMPLETE',
  Created: 'CREATED'
} as const;

export type ResourceOperationStatus = typeof ResourceOperationStatus[keyof typeof ResourceOperationStatus];
export type ResourcePublication = {
  /** @deprecated Use `publication` instead. */
  channel: Channel;
  isPublished: Scalars['Boolean']['output'];
  publication: Publication;
  publishDate: Scalars['DateTime']['output'];
  publishable: Publishable;
};

export type ResourcePublicationConnection = {
  edges: Array<ResourcePublicationEdge>;
  nodes: Array<ResourcePublication>;
  pageInfo: PageInfo;
};

export type ResourcePublicationEdge = {
  cursor: Scalars['String']['output'];
  node: ResourcePublication;
};

export type ResourcePublicationV2 = {
  isPublished: Scalars['Boolean']['output'];
  publication: Publication;
  publishDate?: Maybe<Scalars['DateTime']['output']>;
  publishable: Publishable;
};

export type ResourcePublicationV2Connection = {
  edges: Array<ResourcePublicationV2Edge>;
  nodes: Array<ResourcePublicationV2>;
  pageInfo: PageInfo;
};

export type ResourcePublicationV2Edge = {
  cursor: Scalars['String']['output'];
  node: ResourcePublicationV2;
};

export type RestockingFee = Fee & {
  amountSet: MoneyBag;
  id: Scalars['ID']['output'];
  percentage: Scalars['Float']['output'];
};

export type RestockingFeeInput = {
  percentage: Scalars['Float']['input'];
};

export type RestrictedForResource = {
  restricted: Scalars['Boolean']['output'];
  restrictedReason: Scalars['String']['output'];
};

export type Return = Node & {
  decline?: Maybe<ReturnDecline>;
  exchangeLineItems: ExchangeLineItemConnection;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  order: Order;
  refunds: RefundConnection;
  returnLineItems: ReturnLineItemTypeConnection;
  returnShippingFees: Array<ReturnShippingFee>;
  reverseFulfillmentOrders: ReverseFulfillmentOrderConnection;
  status: ReturnStatus;
  suggestedRefund?: Maybe<SuggestedReturnRefund>;
  totalQuantity: Scalars['Int']['output'];
};


export type ReturnExchangeLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeRemovedItems?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ReturnRefundsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ReturnReturnLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ReturnReverseFulfillmentOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ReturnSuggestedRefundArgs = {
  refundDuties?: InputMaybe<Array<RefundDutyInput>>;
  refundShipping?: InputMaybe<RefundShippingInput>;
  returnRefundLineItems: Array<ReturnRefundLineItemInput>;
};

export type ReturnAgreement = SalesAgreement & {
  app?: Maybe<App>;
  happenedAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  reason: OrderActionType;
  return: Return;
  sales: SaleConnection;
  user?: Maybe<StaffMember>;
};


export type ReturnAgreementSalesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ReturnApproveRequestInput = {
  id: Scalars['ID']['input'];
  notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ReturnApproveRequestPayload = {
  return?: Maybe<Return>;
  userErrors: Array<ReturnUserError>;
};

export type ReturnCancelPayload = {
  return?: Maybe<Return>;
  userErrors: Array<ReturnUserError>;
};

export type ReturnClosePayload = {
  return?: Maybe<Return>;
  userErrors: Array<ReturnUserError>;
};

export type ReturnConnection = {
  edges: Array<ReturnEdge>;
  nodes: Array<Return>;
  pageInfo: PageInfo;
};

export type ReturnCreatePayload = {
  return?: Maybe<Return>;
  userErrors: Array<ReturnUserError>;
};

export type ReturnDecline = {
  note?: Maybe<Scalars['String']['output']>;
  reason: ReturnDeclineReason;
};

export const ReturnDeclineReason = {
  FinalSale: 'FINAL_SALE',
  Other: 'OTHER',
  ReturnPeriodEnded: 'RETURN_PERIOD_ENDED'
} as const;

export type ReturnDeclineReason = typeof ReturnDeclineReason[keyof typeof ReturnDeclineReason];
export type ReturnDeclineRequestInput = {
  declineNote?: InputMaybe<Scalars['String']['input']>;
  declineReason: ReturnDeclineReason;
  id: Scalars['ID']['input'];
  notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ReturnDeclineRequestPayload = {
  return?: Maybe<Return>;
  userErrors: Array<ReturnUserError>;
};

export type ReturnEdge = {
  cursor: Scalars['String']['output'];
  node: Return;
};

export const ReturnErrorCode = {
  AlreadyExists: 'ALREADY_EXISTS',
  Blank: 'BLANK',
  CreationFailed: 'CREATION_FAILED',
  EqualTo: 'EQUAL_TO',
  FeatureNotEnabled: 'FEATURE_NOT_ENABLED',
  GreaterThan: 'GREATER_THAN',
  GreaterThanOrEqualTo: 'GREATER_THAN_OR_EQUAL_TO',
  Inclusion: 'INCLUSION',
  InternalError: 'INTERNAL_ERROR',
  Invalid: 'INVALID',
  InvalidState: 'INVALID_STATE',
  LessThan: 'LESS_THAN',
  LessThanOrEqualTo: 'LESS_THAN_OR_EQUAL_TO',
  NotificationFailed: 'NOTIFICATION_FAILED',
  NotANumber: 'NOT_A_NUMBER',
  NotEditable: 'NOT_EDITABLE',
  NotFound: 'NOT_FOUND',
  Present: 'PRESENT',
  Taken: 'TAKEN',
  TooBig: 'TOO_BIG',
  TooLong: 'TOO_LONG',
  TooManyArguments: 'TOO_MANY_ARGUMENTS',
  TooShort: 'TOO_SHORT',
  WrongLength: 'WRONG_LENGTH'
} as const;

export type ReturnErrorCode = typeof ReturnErrorCode[keyof typeof ReturnErrorCode];
export type ReturnInput = {
  exchangeLineItems?: InputMaybe<Array<ExchangeLineItemInput>>;
  orderId: Scalars['ID']['input'];
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  returnLineItems: Array<ReturnLineItemInput>;
  returnShippingFee?: InputMaybe<ReturnShippingFeeInput>;
};

export type ReturnLineItem = Node & ReturnLineItemType & {
  customerNote?: Maybe<Scalars['String']['output']>;
  fulfillmentLineItem: FulfillmentLineItem;
  id: Scalars['ID']['output'];
  quantity: Scalars['Int']['output'];
  refundableQuantity: Scalars['Int']['output'];
  refundedQuantity: Scalars['Int']['output'];
  restockingFee?: Maybe<RestockingFee>;
  returnReason: ReturnReason;
  returnReasonNote: Scalars['String']['output'];
  totalWeight?: Maybe<Weight>;
  withCodeDiscountedTotalPriceSet: MoneyBag;
};

export type ReturnLineItemInput = {
  fulfillmentLineItemId: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
  restockingFee?: InputMaybe<RestockingFeeInput>;
  returnReason: ReturnReason;
  returnReasonNote?: InputMaybe<Scalars['String']['input']>;
};

export type ReturnLineItemRemoveFromReturnInput = {
  quantity: Scalars['Int']['input'];
  returnLineItemId: Scalars['ID']['input'];
};

export type ReturnLineItemRemoveFromReturnPayload = {
  return?: Maybe<Return>;
  userErrors: Array<ReturnUserError>;
};

export type ReturnLineItemType = {
  customerNote?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  quantity: Scalars['Int']['output'];
  refundableQuantity: Scalars['Int']['output'];
  refundedQuantity: Scalars['Int']['output'];
  returnReason: ReturnReason;
  returnReasonNote: Scalars['String']['output'];
};

export type ReturnLineItemTypeConnection = {
  edges: Array<ReturnLineItemTypeEdge>;
  nodes: Array<ReturnLineItemType>;
  pageInfo: PageInfo;
};

export type ReturnLineItemTypeEdge = {
  cursor: Scalars['String']['output'];
  node: ReturnLineItemType;
};

export const ReturnReason = {
  Color: 'COLOR',
  Defective: 'DEFECTIVE',
  NotAsDescribed: 'NOT_AS_DESCRIBED',
  Other: 'OTHER',
  SizeTooLarge: 'SIZE_TOO_LARGE',
  SizeTooSmall: 'SIZE_TOO_SMALL',
  Style: 'STYLE',
  Unknown: 'UNKNOWN',
  Unwanted: 'UNWANTED',
  WrongItem: 'WRONG_ITEM'
} as const;

export type ReturnReason = typeof ReturnReason[keyof typeof ReturnReason];
export type ReturnRefundInput = {
  notifyCustomer?: InputMaybe<Scalars['Boolean']['input']>;
  orderTransactions?: InputMaybe<Array<ReturnRefundOrderTransactionInput>>;
  refundDuties?: InputMaybe<Array<RefundDutyInput>>;
  refundShipping?: InputMaybe<RefundShippingInput>;
  returnId: Scalars['ID']['input'];
  returnRefundLineItems: Array<ReturnRefundLineItemInput>;
};

export type ReturnRefundLineItemInput = {
  quantity: Scalars['Int']['input'];
  returnLineItemId: Scalars['ID']['input'];
};

export type ReturnRefundOrderTransactionInput = {
  parentId: Scalars['ID']['input'];
  transactionAmount: MoneyInput;
};

export type ReturnRefundPayload = {
  refund?: Maybe<Refund>;
  userErrors: Array<ReturnUserError>;
};

export type ReturnReopenPayload = {
  return?: Maybe<Return>;
  userErrors: Array<ReturnUserError>;
};

export type ReturnRequestInput = {
  orderId: Scalars['ID']['input'];
  returnLineItems: Array<ReturnRequestLineItemInput>;
  returnShippingFee?: InputMaybe<ReturnShippingFeeInput>;
};

export type ReturnRequestLineItemInput = {
  customerNote?: InputMaybe<Scalars['String']['input']>;
  fulfillmentLineItemId: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
  restockingFee?: InputMaybe<RestockingFeeInput>;
  returnReason: ReturnReason;
};

export type ReturnRequestPayload = {
  return?: Maybe<Return>;
  userErrors: Array<ReturnUserError>;
};

export type ReturnShippingFee = Fee & {
  amountSet: MoneyBag;
  id: Scalars['ID']['output'];
};

export type ReturnShippingFeeInput = {
  amount: MoneyInput;
};

export const ReturnStatus = {
  Canceled: 'CANCELED',
  Closed: 'CLOSED',
  Declined: 'DECLINED',
  Open: 'OPEN',
  Requested: 'REQUESTED'
} as const;

export type ReturnStatus = typeof ReturnStatus[keyof typeof ReturnStatus];
export type ReturnUserError = DisplayableError & {
  code?: Maybe<ReturnErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type ReturnableFulfillment = Node & {
  fulfillment: Fulfillment;
  id: Scalars['ID']['output'];
  returnableFulfillmentLineItems: ReturnableFulfillmentLineItemConnection;
};


export type ReturnableFulfillmentReturnableFulfillmentLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ReturnableFulfillmentConnection = {
  edges: Array<ReturnableFulfillmentEdge>;
  nodes: Array<ReturnableFulfillment>;
  pageInfo: PageInfo;
};

export type ReturnableFulfillmentEdge = {
  cursor: Scalars['String']['output'];
  node: ReturnableFulfillment;
};

export type ReturnableFulfillmentLineItem = {
  fulfillmentLineItem: FulfillmentLineItem;
  quantity: Scalars['Int']['output'];
};

export type ReturnableFulfillmentLineItemConnection = {
  edges: Array<ReturnableFulfillmentLineItemEdge>;
  nodes: Array<ReturnableFulfillmentLineItem>;
  pageInfo: PageInfo;
};

export type ReturnableFulfillmentLineItemEdge = {
  cursor: Scalars['String']['output'];
  node: ReturnableFulfillmentLineItem;
};

export type ReverseDelivery = Node & {
  deliverable?: Maybe<ReverseDeliveryDeliverable>;
  id: Scalars['ID']['output'];
  reverseDeliveryLineItems: ReverseDeliveryLineItemConnection;
  reverseFulfillmentOrder: ReverseFulfillmentOrder;
};


export type ReverseDeliveryReverseDeliveryLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ReverseDeliveryConnection = {
  edges: Array<ReverseDeliveryEdge>;
  nodes: Array<ReverseDelivery>;
  pageInfo: PageInfo;
};

export type ReverseDeliveryCreateWithShippingPayload = {
  reverseDelivery?: Maybe<ReverseDelivery>;
  userErrors: Array<ReturnUserError>;
};

export type ReverseDeliveryDeliverable = ReverseDeliveryShippingDeliverable;

export type ReverseDeliveryEdge = {
  cursor: Scalars['String']['output'];
  node: ReverseDelivery;
};

export type ReverseDeliveryLabelInput = {
  fileUrl: Scalars['URL']['input'];
};

export type ReverseDeliveryLabelV2 = {
  createdAt: Scalars['DateTime']['output'];
  publicFileUrl?: Maybe<Scalars['URL']['output']>;
  updatedAt: Scalars['DateTime']['output'];
};

export type ReverseDeliveryLineItem = Node & {
  dispositions: Array<ReverseFulfillmentOrderDisposition>;
  id: Scalars['ID']['output'];
  quantity: Scalars['Int']['output'];
  reverseFulfillmentOrderLineItem: ReverseFulfillmentOrderLineItem;
};

export type ReverseDeliveryLineItemConnection = {
  edges: Array<ReverseDeliveryLineItemEdge>;
  nodes: Array<ReverseDeliveryLineItem>;
  pageInfo: PageInfo;
};

export type ReverseDeliveryLineItemEdge = {
  cursor: Scalars['String']['output'];
  node: ReverseDeliveryLineItem;
};

export type ReverseDeliveryLineItemInput = {
  quantity: Scalars['Int']['input'];
  reverseFulfillmentOrderLineItemId: Scalars['ID']['input'];
};

export type ReverseDeliveryShippingDeliverable = {
  label?: Maybe<ReverseDeliveryLabelV2>;
  tracking?: Maybe<ReverseDeliveryTrackingV2>;
};

export type ReverseDeliveryShippingUpdatePayload = {
  reverseDelivery?: Maybe<ReverseDelivery>;
  userErrors: Array<ReturnUserError>;
};

export type ReverseDeliveryTrackingInput = {
  number?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['URL']['input']>;
};

export type ReverseDeliveryTrackingV2 = {
  carrierName?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['URL']['output']>;
};

export type ReverseFulfillmentOrder = Node & {
  id: Scalars['ID']['output'];
  lineItems: ReverseFulfillmentOrderLineItemConnection;
  order?: Maybe<Order>;
  reverseDeliveries: ReverseDeliveryConnection;
  status: ReverseFulfillmentOrderStatus;
  thirdPartyConfirmation?: Maybe<ReverseFulfillmentOrderThirdPartyConfirmation>;
};


export type ReverseFulfillmentOrderLineItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ReverseFulfillmentOrderReverseDeliveriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ReverseFulfillmentOrderConnection = {
  edges: Array<ReverseFulfillmentOrderEdge>;
  nodes: Array<ReverseFulfillmentOrder>;
  pageInfo: PageInfo;
};

export type ReverseFulfillmentOrderDisposeInput = {
  dispositionType: ReverseFulfillmentOrderDispositionType;
  locationId?: InputMaybe<Scalars['ID']['input']>;
  quantity: Scalars['Int']['input'];
  reverseFulfillmentOrderLineItemId: Scalars['ID']['input'];
};

export type ReverseFulfillmentOrderDisposePayload = {
  reverseFulfillmentOrderLineItems?: Maybe<Array<ReverseFulfillmentOrderLineItem>>;
  userErrors: Array<ReturnUserError>;
};

export type ReverseFulfillmentOrderDisposition = Node & {
  id: Scalars['ID']['output'];
  location?: Maybe<Location>;
  quantity: Scalars['Int']['output'];
  type: ReverseFulfillmentOrderDispositionType;
};

export const ReverseFulfillmentOrderDispositionType = {
  Missing: 'MISSING',
  NotRestocked: 'NOT_RESTOCKED',
  ProcessingRequired: 'PROCESSING_REQUIRED',
  Restocked: 'RESTOCKED'
} as const;

export type ReverseFulfillmentOrderDispositionType = typeof ReverseFulfillmentOrderDispositionType[keyof typeof ReverseFulfillmentOrderDispositionType];
export type ReverseFulfillmentOrderEdge = {
  cursor: Scalars['String']['output'];
  node: ReverseFulfillmentOrder;
};

export type ReverseFulfillmentOrderLineItem = Node & {
  dispositions: Array<ReverseFulfillmentOrderDisposition>;
  fulfillmentLineItem?: Maybe<FulfillmentLineItem>;
  id: Scalars['ID']['output'];
  totalQuantity: Scalars['Int']['output'];
};

export type ReverseFulfillmentOrderLineItemConnection = {
  edges: Array<ReverseFulfillmentOrderLineItemEdge>;
  nodes: Array<ReverseFulfillmentOrderLineItem>;
  pageInfo: PageInfo;
};

export type ReverseFulfillmentOrderLineItemEdge = {
  cursor: Scalars['String']['output'];
  node: ReverseFulfillmentOrderLineItem;
};

export const ReverseFulfillmentOrderStatus = {
  Canceled: 'CANCELED',
  Closed: 'CLOSED',
  Open: 'OPEN'
} as const;

export type ReverseFulfillmentOrderStatus = typeof ReverseFulfillmentOrderStatus[keyof typeof ReverseFulfillmentOrderStatus];
export type ReverseFulfillmentOrderThirdPartyConfirmation = {
  status: ReverseFulfillmentOrderThirdPartyConfirmationStatus;
};

export const ReverseFulfillmentOrderThirdPartyConfirmationStatus = {
  Accepted: 'ACCEPTED',
  CancelAccepted: 'CANCEL_ACCEPTED',
  CancelRejected: 'CANCEL_REJECTED',
  PendingAcceptance: 'PENDING_ACCEPTANCE',
  PendingCancelation: 'PENDING_CANCELATION',
  Rejected: 'REJECTED'
} as const;

export type ReverseFulfillmentOrderThirdPartyConfirmationStatus = typeof ReverseFulfillmentOrderThirdPartyConfirmationStatus[keyof typeof ReverseFulfillmentOrderThirdPartyConfirmationStatus];
export const RiskAssessmentResult = {
  High: 'HIGH',
  Low: 'LOW',
  Medium: 'MEDIUM',
  None: 'NONE',
  Pending: 'PENDING'
} as const;

export type RiskAssessmentResult = typeof RiskAssessmentResult[keyof typeof RiskAssessmentResult];
export type RiskFact = {
  description: Scalars['String']['output'];
  sentiment: RiskFactSentiment;
};

export const RiskFactSentiment = {
  Negative: 'NEGATIVE',
  Neutral: 'NEUTRAL',
  Positive: 'POSITIVE'
} as const;

export type RiskFactSentiment = typeof RiskFactSentiment[keyof typeof RiskFactSentiment];
export type RowCount = {
  count: Scalars['Int']['output'];
  exceedsMax: Scalars['Boolean']['output'];
};

export type Seo = {
  description?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};

export type SeoInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type Sale = {
  actionType: SaleActionType;
  id: Scalars['ID']['output'];
  lineType: SaleLineType;
  quantity?: Maybe<Scalars['Int']['output']>;
  taxes: Array<SaleTax>;
  totalAmount: MoneyBag;
  totalDiscountAmountAfterTaxes: MoneyBag;
  totalDiscountAmountBeforeTaxes: MoneyBag;
  totalTaxAmount: MoneyBag;
};

export const SaleActionType = {
  Order: 'ORDER',
  Return: 'RETURN',
  Unknown: 'UNKNOWN',
  Update: 'UPDATE'
} as const;

export type SaleActionType = typeof SaleActionType[keyof typeof SaleActionType];
export type SaleAdditionalFee = Node & {
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  price: MoneyBag;
  taxLines: Array<TaxLine>;
};

export type SaleConnection = {
  edges: Array<SaleEdge>;
  nodes: Array<Sale>;
  pageInfo: PageInfo;
};

export type SaleEdge = {
  cursor: Scalars['String']['output'];
  node: Sale;
};

export const SaleLineType = {
  AdditionalFee: 'ADDITIONAL_FEE',
  Adjustment: 'ADJUSTMENT',
  Duty: 'DUTY',
  Fee: 'FEE',
  GiftCard: 'GIFT_CARD',
  Product: 'PRODUCT',
  Shipping: 'SHIPPING',
  Tip: 'TIP',
  Unknown: 'UNKNOWN'
} as const;

export type SaleLineType = typeof SaleLineType[keyof typeof SaleLineType];
export type SaleTax = {
  amount: MoneyBag;
  id: Scalars['ID']['output'];
  taxLine: TaxLine;
};

export type SalesAgreement = {
  app?: Maybe<App>;
  happenedAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  reason: OrderActionType;
  sales: SaleConnection;
  user?: Maybe<StaffMember>;
};


export type SalesAgreementSalesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SalesAgreementConnection = {
  edges: Array<SalesAgreementEdge>;
  nodes: Array<SalesAgreement>;
  pageInfo: PageInfo;
};

export type SalesAgreementEdge = {
  cursor: Scalars['String']['output'];
  node: SalesAgreement;
};

export type SavedSearch = LegacyInteroperability & Node & {
  filters: Array<SearchFilter>;
  id: Scalars['ID']['output'];
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  name: Scalars['String']['output'];
  query: Scalars['String']['output'];
  resourceType: SearchResultType;
  searchTerms: Scalars['String']['output'];
};

export type SavedSearchConnection = {
  edges: Array<SavedSearchEdge>;
  nodes: Array<SavedSearch>;
  pageInfo: PageInfo;
};

export type SavedSearchCreateInput = {
  name: Scalars['String']['input'];
  query: Scalars['String']['input'];
  resourceType: SearchResultType;
};

export type SavedSearchCreatePayload = {
  savedSearch?: Maybe<SavedSearch>;
  userErrors: Array<UserError>;
};

export type SavedSearchDeleteInput = {
  id: Scalars['ID']['input'];
};

export type SavedSearchDeletePayload = {
  deletedSavedSearchId?: Maybe<Scalars['ID']['output']>;
  shop: Shop;
  userErrors: Array<UserError>;
};

export type SavedSearchEdge = {
  cursor: Scalars['String']['output'];
  node: SavedSearch;
};

export type SavedSearchUpdateInput = {
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
};

export type SavedSearchUpdatePayload = {
  savedSearch?: Maybe<SavedSearch>;
  userErrors: Array<UserError>;
};

export const ScheduledChangeSortKeys = {
  ExpectedAt: 'EXPECTED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type ScheduledChangeSortKeys = typeof ScheduledChangeSortKeys[keyof typeof ScheduledChangeSortKeys];
export type ScriptDiscountApplication = DiscountApplication & {
  allocationMethod: DiscountApplicationAllocationMethod;
  /** @deprecated Use `title` instead. */
  description: Scalars['String']['output'];
  index: Scalars['Int']['output'];
  targetSelection: DiscountApplicationTargetSelection;
  targetType: DiscountApplicationTargetType;
  title: Scalars['String']['output'];
  value: PricingValue;
};

export type ScriptTag = LegacyInteroperability & Node & {
  cache: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  displayScope: ScriptTagDisplayScope;
  id: Scalars['ID']['output'];
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  src: Scalars['URL']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type ScriptTagConnection = {
  edges: Array<ScriptTagEdge>;
  nodes: Array<ScriptTag>;
  pageInfo: PageInfo;
};

export type ScriptTagCreatePayload = {
  scriptTag?: Maybe<ScriptTag>;
  userErrors: Array<UserError>;
};

export type ScriptTagDeletePayload = {
  deletedScriptTagId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<UserError>;
};

export const ScriptTagDisplayScope = {
  All: 'ALL',
  OnlineStore: 'ONLINE_STORE',
  OrderStatus: 'ORDER_STATUS'
} as const;

export type ScriptTagDisplayScope = typeof ScriptTagDisplayScope[keyof typeof ScriptTagDisplayScope];
export type ScriptTagEdge = {
  cursor: Scalars['String']['output'];
  node: ScriptTag;
};

export type ScriptTagInput = {
  cache?: InputMaybe<Scalars['Boolean']['input']>;
  displayScope?: InputMaybe<ScriptTagDisplayScope>;
  src?: InputMaybe<Scalars['URL']['input']>;
};

export type ScriptTagUpdatePayload = {
  scriptTag?: Maybe<ScriptTag>;
  userErrors: Array<UserError>;
};

export type SearchFilter = {
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type SearchFilterOptions = {
  productAvailability: Array<FilterOption>;
};

export type SearchResult = {
  description?: Maybe<Scalars['String']['output']>;
  image?: Maybe<Image>;
  reference: Node;
  title: Scalars['String']['output'];
  url: Scalars['URL']['output'];
};

export type SearchResultConnection = {
  edges: Array<SearchResultEdge>;
  pageInfo: PageInfo;
  /** @deprecated The provided information is not accurate. */
  resultsAfterCount: Scalars['Int']['output'];
};

export type SearchResultEdge = {
  cursor: Scalars['String']['output'];
  node: SearchResult;
};

export const SearchResultType = {
  Article: 'ARTICLE',
  BalanceTransaction: 'BALANCE_TRANSACTION',
  Blog: 'BLOG',
  Collection: 'COLLECTION',
  Customer: 'CUSTOMER',
  DiscountRedeemCode: 'DISCOUNT_REDEEM_CODE',
  DraftOrder: 'DRAFT_ORDER',
  File: 'FILE',
  Order: 'ORDER',
  Page: 'PAGE',
  PriceRule: 'PRICE_RULE',
  Product: 'PRODUCT',
  UrlRedirect: 'URL_REDIRECT'
} as const;

export type SearchResultType = typeof SearchResultType[keyof typeof SearchResultType];
export type Segment = Node & {
  creationDate: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  lastEditDate: Scalars['DateTime']['output'];
  name: Scalars['String']['output'];
  query: Scalars['String']['output'];
};

export type SegmentAssociationFilter = SegmentFilter & {
  localizedName: Scalars['String']['output'];
  multiValue: Scalars['Boolean']['output'];
  queryName: Scalars['String']['output'];
};

export type SegmentAttributeStatistics = {
  average: Scalars['Float']['output'];
  sum: Scalars['Float']['output'];
};

export type SegmentBooleanFilter = SegmentFilter & {
  localizedName: Scalars['String']['output'];
  multiValue: Scalars['Boolean']['output'];
  queryName: Scalars['String']['output'];
};

export type SegmentConnection = {
  edges: Array<SegmentEdge>;
  nodes: Array<Segment>;
  pageInfo: PageInfo;
};

export type SegmentCreatePayload = {
  segment?: Maybe<Segment>;
  userErrors: Array<UserError>;
};

export type SegmentDateFilter = SegmentFilter & {
  localizedName: Scalars['String']['output'];
  multiValue: Scalars['Boolean']['output'];
  queryName: Scalars['String']['output'];
};

export type SegmentDeletePayload = {
  deletedSegmentId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<UserError>;
};

export type SegmentEdge = {
  cursor: Scalars['String']['output'];
  node: Segment;
};

export type SegmentEnumFilter = SegmentFilter & {
  localizedName: Scalars['String']['output'];
  multiValue: Scalars['Boolean']['output'];
  queryName: Scalars['String']['output'];
};

export type SegmentEventFilter = SegmentFilter & {
  localizedName: Scalars['String']['output'];
  multiValue: Scalars['Boolean']['output'];
  parameters: Array<SegmentEventFilterParameter>;
  queryName: Scalars['String']['output'];
  returnValueType: Scalars['String']['output'];
};

export type SegmentEventFilterParameter = {
  acceptsMultipleValues: Scalars['Boolean']['output'];
  localizedDescription: Scalars['String']['output'];
  localizedName: Scalars['String']['output'];
  optional: Scalars['Boolean']['output'];
  parameterType: Scalars['String']['output'];
  queryName: Scalars['String']['output'];
};

export type SegmentFilter = {
  localizedName: Scalars['String']['output'];
  multiValue: Scalars['Boolean']['output'];
  queryName: Scalars['String']['output'];
};

export type SegmentFilterConnection = {
  edges: Array<SegmentFilterEdge>;
  nodes: Array<SegmentFilter>;
  pageInfo: PageInfo;
};

export type SegmentFilterEdge = {
  cursor: Scalars['String']['output'];
  node: SegmentFilter;
};

export type SegmentFloatFilter = SegmentFilter & {
  localizedName: Scalars['String']['output'];
  multiValue: Scalars['Boolean']['output'];
  queryName: Scalars['String']['output'];
};

export type SegmentIntegerFilter = SegmentFilter & {
  localizedName: Scalars['String']['output'];
  multiValue: Scalars['Boolean']['output'];
  queryName: Scalars['String']['output'];
};

export type SegmentMembership = {
  isMember: Scalars['Boolean']['output'];
  segmentId: Scalars['ID']['output'];
};

export type SegmentMembershipResponse = {
  memberships: Array<SegmentMembership>;
};

export type SegmentMigration = {
  id: Scalars['ID']['output'];
  savedSearchId: Scalars['ID']['output'];
  segmentId?: Maybe<Scalars['ID']['output']>;
};

export type SegmentMigrationConnection = {
  edges: Array<SegmentMigrationEdge>;
  nodes: Array<SegmentMigration>;
  pageInfo: PageInfo;
};

export type SegmentMigrationEdge = {
  cursor: Scalars['String']['output'];
  node: SegmentMigration;
};

export const SegmentSortKeys = {
  CreationDate: 'CREATION_DATE',
  Id: 'ID',
  LastEditDate: 'LAST_EDIT_DATE',
  Relevance: 'RELEVANCE'
} as const;

export type SegmentSortKeys = typeof SegmentSortKeys[keyof typeof SegmentSortKeys];
export type SegmentStatistics = {
  attributeStatistics: SegmentAttributeStatistics;
};


export type SegmentStatisticsAttributeStatisticsArgs = {
  attributeName: Scalars['String']['input'];
};

export type SegmentStringFilter = SegmentFilter & {
  localizedName: Scalars['String']['output'];
  multiValue: Scalars['Boolean']['output'];
  queryName: Scalars['String']['output'];
};

export type SegmentUpdatePayload = {
  segment?: Maybe<Segment>;
  userErrors: Array<UserError>;
};

export type SegmentValue = {
  localizedValue: Scalars['String']['output'];
  queryName: Scalars['String']['output'];
};

export type SegmentValueConnection = {
  edges: Array<SegmentValueEdge>;
  nodes: Array<SegmentValue>;
  pageInfo: PageInfo;
};

export type SegmentValueEdge = {
  cursor: Scalars['String']['output'];
  node: SegmentValue;
};

export type SelectedOption = {
  name: Scalars['String']['output'];
  optionValue: ProductOptionValue;
  value: Scalars['String']['output'];
};

export type SelectedVariantOptionInput = {
  linkedMetafieldValue?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type SellingPlan = HasMetafieldDefinitions & HasMetafields & HasPublishedTranslations & Node & {
  billingPolicy: SellingPlanBillingPolicy;
  category?: Maybe<SellingPlanCategory>;
  createdAt: Scalars['DateTime']['output'];
  deliveryPolicy: SellingPlanDeliveryPolicy;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  inventoryPolicy?: Maybe<SellingPlanInventoryPolicy>;
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  name: Scalars['String']['output'];
  options: Array<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  pricingPolicies: Array<SellingPlanPricingPolicy>;
  translations: Array<Translation>;
};


export type SellingPlanMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type SellingPlanMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type SellingPlanMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SellingPlanTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export type SellingPlanAnchor = {
  cutoffDay?: Maybe<Scalars['Int']['output']>;
  day: Scalars['Int']['output'];
  month?: Maybe<Scalars['Int']['output']>;
  type: SellingPlanAnchorType;
};

export type SellingPlanAnchorInput = {
  cutoffDay?: InputMaybe<Scalars['Int']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  month?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<SellingPlanAnchorType>;
};

export const SellingPlanAnchorType = {
  Monthday: 'MONTHDAY',
  Weekday: 'WEEKDAY',
  Yearday: 'YEARDAY'
} as const;

export type SellingPlanAnchorType = typeof SellingPlanAnchorType[keyof typeof SellingPlanAnchorType];
export type SellingPlanBillingPolicy = SellingPlanFixedBillingPolicy | SellingPlanRecurringBillingPolicy;

export type SellingPlanBillingPolicyInput = {
  fixed?: InputMaybe<SellingPlanFixedBillingPolicyInput>;
  recurring?: InputMaybe<SellingPlanRecurringBillingPolicyInput>;
};

export const SellingPlanCategory = {
  Other: 'OTHER',
  PreOrder: 'PRE_ORDER',
  Subscription: 'SUBSCRIPTION',
  TryBeforeYouBuy: 'TRY_BEFORE_YOU_BUY'
} as const;

export type SellingPlanCategory = typeof SellingPlanCategory[keyof typeof SellingPlanCategory];
export type SellingPlanCheckoutCharge = {
  type: SellingPlanCheckoutChargeType;
  value: SellingPlanCheckoutChargeValue;
};

export type SellingPlanCheckoutChargeInput = {
  type?: InputMaybe<SellingPlanCheckoutChargeType>;
  value?: InputMaybe<SellingPlanCheckoutChargeValueInput>;
};

export type SellingPlanCheckoutChargePercentageValue = {
  percentage: Scalars['Float']['output'];
};

export const SellingPlanCheckoutChargeType = {
  Percentage: 'PERCENTAGE',
  Price: 'PRICE'
} as const;

export type SellingPlanCheckoutChargeType = typeof SellingPlanCheckoutChargeType[keyof typeof SellingPlanCheckoutChargeType];
export type SellingPlanCheckoutChargeValue = MoneyV2 | SellingPlanCheckoutChargePercentageValue;

export type SellingPlanCheckoutChargeValueInput = {
  fixedValue?: InputMaybe<Scalars['Decimal']['input']>;
  percentage?: InputMaybe<Scalars['Float']['input']>;
};

export type SellingPlanConnection = {
  edges: Array<SellingPlanEdge>;
  nodes: Array<SellingPlan>;
  pageInfo: PageInfo;
};

export type SellingPlanDeliveryPolicy = SellingPlanFixedDeliveryPolicy | SellingPlanRecurringDeliveryPolicy;

export type SellingPlanDeliveryPolicyInput = {
  fixed?: InputMaybe<SellingPlanFixedDeliveryPolicyInput>;
  recurring?: InputMaybe<SellingPlanRecurringDeliveryPolicyInput>;
};

export type SellingPlanEdge = {
  cursor: Scalars['String']['output'];
  node: SellingPlan;
};

export type SellingPlanFixedBillingPolicy = {
  checkoutCharge: SellingPlanCheckoutCharge;
  remainingBalanceChargeExactTime?: Maybe<Scalars['DateTime']['output']>;
  remainingBalanceChargeTimeAfterCheckout?: Maybe<Scalars['String']['output']>;
  remainingBalanceChargeTrigger: SellingPlanRemainingBalanceChargeTrigger;
};

export type SellingPlanFixedBillingPolicyInput = {
  checkoutCharge?: InputMaybe<SellingPlanCheckoutChargeInput>;
  remainingBalanceChargeExactTime?: InputMaybe<Scalars['DateTime']['input']>;
  remainingBalanceChargeTimeAfterCheckout?: InputMaybe<Scalars['String']['input']>;
  remainingBalanceChargeTrigger?: InputMaybe<SellingPlanRemainingBalanceChargeTrigger>;
};

export type SellingPlanFixedDeliveryPolicy = {
  anchors: Array<SellingPlanAnchor>;
  cutoff?: Maybe<Scalars['Int']['output']>;
  fulfillmentExactTime?: Maybe<Scalars['DateTime']['output']>;
  fulfillmentTrigger: SellingPlanFulfillmentTrigger;
  intent: SellingPlanFixedDeliveryPolicyIntent;
  preAnchorBehavior: SellingPlanFixedDeliveryPolicyPreAnchorBehavior;
};

export type SellingPlanFixedDeliveryPolicyInput = {
  anchors?: InputMaybe<Array<SellingPlanAnchorInput>>;
  cutoff?: InputMaybe<Scalars['Int']['input']>;
  fulfillmentExactTime?: InputMaybe<Scalars['DateTime']['input']>;
  fulfillmentTrigger?: InputMaybe<SellingPlanFulfillmentTrigger>;
  intent?: InputMaybe<SellingPlanFixedDeliveryPolicyIntent>;
  preAnchorBehavior?: InputMaybe<SellingPlanFixedDeliveryPolicyPreAnchorBehavior>;
};

export const SellingPlanFixedDeliveryPolicyIntent = {
  FulfillmentBegin: 'FULFILLMENT_BEGIN'
} as const;

export type SellingPlanFixedDeliveryPolicyIntent = typeof SellingPlanFixedDeliveryPolicyIntent[keyof typeof SellingPlanFixedDeliveryPolicyIntent];
export const SellingPlanFixedDeliveryPolicyPreAnchorBehavior = {
  Asap: 'ASAP',
  Next: 'NEXT'
} as const;

export type SellingPlanFixedDeliveryPolicyPreAnchorBehavior = typeof SellingPlanFixedDeliveryPolicyPreAnchorBehavior[keyof typeof SellingPlanFixedDeliveryPolicyPreAnchorBehavior];
export type SellingPlanFixedPricingPolicy = SellingPlanPricingPolicyBase & {
  adjustmentType: SellingPlanPricingPolicyAdjustmentType;
  adjustmentValue: SellingPlanPricingPolicyAdjustmentValue;
  createdAt: Scalars['DateTime']['output'];
};

export type SellingPlanFixedPricingPolicyInput = {
  adjustmentType?: InputMaybe<SellingPlanPricingPolicyAdjustmentType>;
  adjustmentValue?: InputMaybe<SellingPlanPricingPolicyValueInput>;
  id?: InputMaybe<Scalars['ID']['input']>;
};

export const SellingPlanFulfillmentTrigger = {
  Anchor: 'ANCHOR',
  Asap: 'ASAP',
  ExactTime: 'EXACT_TIME',
  Unknown: 'UNKNOWN'
} as const;

export type SellingPlanFulfillmentTrigger = typeof SellingPlanFulfillmentTrigger[keyof typeof SellingPlanFulfillmentTrigger];
export type SellingPlanGroup = HasPublishedTranslations & Node & {
  appId?: Maybe<Scalars['String']['output']>;
  appliesToProduct: Scalars['Boolean']['output'];
  appliesToProductVariant: Scalars['Boolean']['output'];
  appliesToProductVariants: Scalars['Boolean']['output'];
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  merchantCode: Scalars['String']['output'];
  name: Scalars['String']['output'];
  options: Array<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  productVariants: ProductVariantConnection;
  productVariantsCount?: Maybe<Count>;
  products: ProductConnection;
  productsCount?: Maybe<Count>;
  sellingPlans: SellingPlanConnection;
  summary?: Maybe<Scalars['String']['output']>;
  translations: Array<Translation>;
};


export type SellingPlanGroupAppliesToProductArgs = {
  productId: Scalars['ID']['input'];
};


export type SellingPlanGroupAppliesToProductVariantArgs = {
  productVariantId: Scalars['ID']['input'];
};


export type SellingPlanGroupAppliesToProductVariantsArgs = {
  productId: Scalars['ID']['input'];
};


export type SellingPlanGroupProductVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  productId?: InputMaybe<Scalars['ID']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SellingPlanGroupProductVariantsCountArgs = {
  productId?: InputMaybe<Scalars['ID']['input']>;
};


export type SellingPlanGroupProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SellingPlanGroupSellingPlansArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SellingPlanGroupTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export type SellingPlanGroupAddProductVariantsPayload = {
  sellingPlanGroup?: Maybe<SellingPlanGroup>;
  userErrors: Array<SellingPlanGroupUserError>;
};

export type SellingPlanGroupAddProductsPayload = {
  sellingPlanGroup?: Maybe<SellingPlanGroup>;
  userErrors: Array<SellingPlanGroupUserError>;
};

export type SellingPlanGroupConnection = {
  edges: Array<SellingPlanGroupEdge>;
  nodes: Array<SellingPlanGroup>;
  pageInfo: PageInfo;
};

export type SellingPlanGroupCreatePayload = {
  sellingPlanGroup?: Maybe<SellingPlanGroup>;
  userErrors: Array<SellingPlanGroupUserError>;
};

export type SellingPlanGroupDeletePayload = {
  deletedSellingPlanGroupId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<SellingPlanGroupUserError>;
};

export type SellingPlanGroupEdge = {
  cursor: Scalars['String']['output'];
  node: SellingPlanGroup;
};

export type SellingPlanGroupInput = {
  appId?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  merchantCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  options?: InputMaybe<Array<Scalars['String']['input']>>;
  position?: InputMaybe<Scalars['Int']['input']>;
  sellingPlansToCreate?: InputMaybe<Array<SellingPlanInput>>;
  sellingPlansToDelete?: InputMaybe<Array<Scalars['ID']['input']>>;
  sellingPlansToUpdate?: InputMaybe<Array<SellingPlanInput>>;
};

export type SellingPlanGroupRemoveProductVariantsPayload = {
  removedProductVariantIds?: Maybe<Array<Scalars['ID']['output']>>;
  userErrors: Array<SellingPlanGroupUserError>;
};

export type SellingPlanGroupRemoveProductsPayload = {
  removedProductIds?: Maybe<Array<Scalars['ID']['output']>>;
  userErrors: Array<SellingPlanGroupUserError>;
};

export type SellingPlanGroupResourceInput = {
  productIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  productVariantIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export const SellingPlanGroupSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Name: 'NAME',
  Relevance: 'RELEVANCE',
  UpdatedAt: 'UPDATED_AT'
} as const;

export type SellingPlanGroupSortKeys = typeof SellingPlanGroupSortKeys[keyof typeof SellingPlanGroupSortKeys];
export type SellingPlanGroupUpdatePayload = {
  deletedSellingPlanIds?: Maybe<Array<Scalars['ID']['output']>>;
  sellingPlanGroup?: Maybe<SellingPlanGroup>;
  userErrors: Array<SellingPlanGroupUserError>;
};

export type SellingPlanGroupUserError = DisplayableError & {
  code?: Maybe<SellingPlanGroupUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const SellingPlanGroupUserErrorCode = {
  BillingAndDeliveryPolicyTypesMustBeTheSame: 'BILLING_AND_DELIVERY_POLICY_TYPES_MUST_BE_THE_SAME',
  BillingPolicyIntervalTooLarge: 'BILLING_POLICY_INTERVAL_TOO_LARGE',
  Blank: 'BLANK',
  CheckoutChargeValueAndTypeMustMatch: 'CHECKOUT_CHARGE_VALUE_AND_TYPE_MUST_MATCH',
  DeliveryPolicyIntervalTooLarge: 'DELIVERY_POLICY_INTERVAL_TOO_LARGE',
  EqualTo: 'EQUAL_TO',
  ErrorAddingResourceToGroup: 'ERROR_ADDING_RESOURCE_TO_GROUP',
  FulfillmentExactTimeNotAllowed: 'FULFILLMENT_EXACT_TIME_NOT_ALLOWED',
  FulfillmentExactTimeRequired: 'FULFILLMENT_EXACT_TIME_REQUIRED',
  GreaterThan: 'GREATER_THAN',
  GreaterThanOrEqualTo: 'GREATER_THAN_OR_EQUAL_TO',
  GroupCouldNotBeDeleted: 'GROUP_COULD_NOT_BE_DELETED',
  GroupDoesNotExist: 'GROUP_DOES_NOT_EXIST',
  Inclusion: 'INCLUSION',
  Invalid: 'INVALID',
  InvalidInput: 'INVALID_INPUT',
  LessThan: 'LESS_THAN',
  LessThanOrEqualTo: 'LESS_THAN_OR_EQUAL_TO',
  NotANumber: 'NOT_A_NUMBER',
  NotFound: 'NOT_FOUND',
  OnlyNeedOneBillingPolicyType: 'ONLY_NEED_ONE_BILLING_POLICY_TYPE',
  OnlyNeedOneCheckoutChargeValue: 'ONLY_NEED_ONE_CHECKOUT_CHARGE_VALUE',
  OnlyNeedOneDeliveryPolicyType: 'ONLY_NEED_ONE_DELIVERY_POLICY_TYPE',
  OnlyNeedOnePricingPolicyType: 'ONLY_NEED_ONE_PRICING_POLICY_TYPE',
  OnlyNeedOnePricingPolicyValue: 'ONLY_NEED_ONE_PRICING_POLICY_VALUE',
  OnlyOneOfFixedOrRecurringBilling: 'ONLY_ONE_OF_FIXED_OR_RECURRING_BILLING',
  OnlyOneOfFixedOrRecurringDelivery: 'ONLY_ONE_OF_FIXED_OR_RECURRING_DELIVERY',
  PlanDoesNotExist: 'PLAN_DOES_NOT_EXIST',
  PlanIdMustBeSpecifiedToUpdate: 'PLAN_ID_MUST_BE_SPECIFIED_TO_UPDATE',
  Present: 'PRESENT',
  PricingPolicyAdjustmentValueAndTypeMustMatch: 'PRICING_POLICY_ADJUSTMENT_VALUE_AND_TYPE_MUST_MATCH',
  ProductDoesNotExist: 'PRODUCT_DOES_NOT_EXIST',
  ProductVariantDoesNotExist: 'PRODUCT_VARIANT_DOES_NOT_EXIST',
  RemainingBalanceChargeExactTimeNotAllowed: 'REMAINING_BALANCE_CHARGE_EXACT_TIME_NOT_ALLOWED',
  RemainingBalanceChargeExactTimeRequired: 'REMAINING_BALANCE_CHARGE_EXACT_TIME_REQUIRED',
  RemainingBalanceChargeTimeAfterCheckoutMustBeGreaterThanZero: 'REMAINING_BALANCE_CHARGE_TIME_AFTER_CHECKOUT_MUST_BE_GREATER_THAN_ZERO',
  RemainingBalanceChargeTriggerNoRemainingBalanceOnPartialPercentageCheckoutCharge: 'REMAINING_BALANCE_CHARGE_TRIGGER_NO_REMAINING_BALANCE_ON_PARTIAL_PERCENTAGE_CHECKOUT_CHARGE',
  RemainingBalanceChargeTriggerNoRemainingBalanceOnPriceCheckoutCharge: 'REMAINING_BALANCE_CHARGE_TRIGGER_NO_REMAINING_BALANCE_ON_PRICE_CHECKOUT_CHARGE',
  RemainingBalanceChargeTriggerOnFullCheckout: 'REMAINING_BALANCE_CHARGE_TRIGGER_ON_FULL_CHECKOUT',
  ResourceListContainsInvalidIds: 'RESOURCE_LIST_CONTAINS_INVALID_IDS',
  SellingPlanAnchorsNotAllowed: 'SELLING_PLAN_ANCHORS_NOT_ALLOWED',
  SellingPlanAnchorsRequired: 'SELLING_PLAN_ANCHORS_REQUIRED',
  SellingPlanBillingAndDeliveryPolicyAnchorsMustBeEqual: 'SELLING_PLAN_BILLING_AND_DELIVERY_POLICY_ANCHORS_MUST_BE_EQUAL',
  SellingPlanBillingCycleMustBeAMultipleOfDeliveryCycle: 'SELLING_PLAN_BILLING_CYCLE_MUST_BE_A_MULTIPLE_OF_DELIVERY_CYCLE',
  SellingPlanBillingPolicyMissing: 'SELLING_PLAN_BILLING_POLICY_MISSING',
  SellingPlanCountLowerBound: 'SELLING_PLAN_COUNT_LOWER_BOUND',
  SellingPlanCountUpperBound: 'SELLING_PLAN_COUNT_UPPER_BOUND',
  SellingPlanDeliveryPolicyMissing: 'SELLING_PLAN_DELIVERY_POLICY_MISSING',
  SellingPlanDuplicateName: 'SELLING_PLAN_DUPLICATE_NAME',
  SellingPlanDuplicateOptions: 'SELLING_PLAN_DUPLICATE_OPTIONS',
  SellingPlanFixedPricingPoliciesLimit: 'SELLING_PLAN_FIXED_PRICING_POLICIES_LIMIT',
  SellingPlanMaxCyclesMustBeGreaterThanMinCycles: 'SELLING_PLAN_MAX_CYCLES_MUST_BE_GREATER_THAN_MIN_CYCLES',
  SellingPlanMissingOption2LabelOnParentGroup: 'SELLING_PLAN_MISSING_OPTION2_LABEL_ON_PARENT_GROUP',
  SellingPlanMissingOption3LabelOnParentGroup: 'SELLING_PLAN_MISSING_OPTION3_LABEL_ON_PARENT_GROUP',
  SellingPlanOption2RequiredAsDefinedOnParentGroup: 'SELLING_PLAN_OPTION2_REQUIRED_AS_DEFINED_ON_PARENT_GROUP',
  SellingPlanOption3RequiredAsDefinedOnParentGroup: 'SELLING_PLAN_OPTION3_REQUIRED_AS_DEFINED_ON_PARENT_GROUP',
  SellingPlanPricingPoliciesLimit: 'SELLING_PLAN_PRICING_POLICIES_LIMIT',
  SellingPlanPricingPoliciesMustContainAFixedPricingPolicy: 'SELLING_PLAN_PRICING_POLICIES_MUST_CONTAIN_A_FIXED_PRICING_POLICY',
  Taken: 'TAKEN',
  TooBig: 'TOO_BIG',
  TooLong: 'TOO_LONG',
  TooShort: 'TOO_SHORT',
  WrongLength: 'WRONG_LENGTH'
} as const;

export type SellingPlanGroupUserErrorCode = typeof SellingPlanGroupUserErrorCode[keyof typeof SellingPlanGroupUserErrorCode];
export type SellingPlanInput = {
  billingPolicy?: InputMaybe<SellingPlanBillingPolicyInput>;
  category?: InputMaybe<SellingPlanCategory>;
  deliveryPolicy?: InputMaybe<SellingPlanDeliveryPolicyInput>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  inventoryPolicy?: InputMaybe<SellingPlanInventoryPolicyInput>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  name?: InputMaybe<Scalars['String']['input']>;
  options?: InputMaybe<Array<Scalars['String']['input']>>;
  position?: InputMaybe<Scalars['Int']['input']>;
  pricingPolicies?: InputMaybe<Array<SellingPlanPricingPolicyInput>>;
};

export const SellingPlanInterval = {
  Day: 'DAY',
  Month: 'MONTH',
  Week: 'WEEK',
  Year: 'YEAR'
} as const;

export type SellingPlanInterval = typeof SellingPlanInterval[keyof typeof SellingPlanInterval];
export type SellingPlanInventoryPolicy = {
  reserve: SellingPlanReserve;
};

export type SellingPlanInventoryPolicyInput = {
  reserve?: InputMaybe<SellingPlanReserve>;
};

export type SellingPlanPricingPolicy = SellingPlanFixedPricingPolicy | SellingPlanRecurringPricingPolicy;

export const SellingPlanPricingPolicyAdjustmentType = {
  FixedAmount: 'FIXED_AMOUNT',
  Percentage: 'PERCENTAGE',
  Price: 'PRICE'
} as const;

export type SellingPlanPricingPolicyAdjustmentType = typeof SellingPlanPricingPolicyAdjustmentType[keyof typeof SellingPlanPricingPolicyAdjustmentType];
export type SellingPlanPricingPolicyAdjustmentValue = MoneyV2 | SellingPlanPricingPolicyPercentageValue;

export type SellingPlanPricingPolicyBase = {
  adjustmentType: SellingPlanPricingPolicyAdjustmentType;
  adjustmentValue: SellingPlanPricingPolicyAdjustmentValue;
};

export type SellingPlanPricingPolicyInput = {
  fixed?: InputMaybe<SellingPlanFixedPricingPolicyInput>;
  recurring?: InputMaybe<SellingPlanRecurringPricingPolicyInput>;
};

export type SellingPlanPricingPolicyPercentageValue = {
  percentage: Scalars['Float']['output'];
};

export type SellingPlanPricingPolicyValueInput = {
  fixedValue?: InputMaybe<Scalars['Decimal']['input']>;
  percentage?: InputMaybe<Scalars['Float']['input']>;
};

export type SellingPlanRecurringBillingPolicy = {
  anchors: Array<SellingPlanAnchor>;
  createdAt: Scalars['DateTime']['output'];
  interval: SellingPlanInterval;
  intervalCount: Scalars['Int']['output'];
  maxCycles?: Maybe<Scalars['Int']['output']>;
  minCycles?: Maybe<Scalars['Int']['output']>;
};

export type SellingPlanRecurringBillingPolicyInput = {
  anchors?: InputMaybe<Array<SellingPlanAnchorInput>>;
  interval?: InputMaybe<SellingPlanInterval>;
  intervalCount?: InputMaybe<Scalars['Int']['input']>;
  maxCycles?: InputMaybe<Scalars['Int']['input']>;
  minCycles?: InputMaybe<Scalars['Int']['input']>;
};

export type SellingPlanRecurringDeliveryPolicy = {
  anchors: Array<SellingPlanAnchor>;
  createdAt: Scalars['DateTime']['output'];
  cutoff?: Maybe<Scalars['Int']['output']>;
  intent: SellingPlanRecurringDeliveryPolicyIntent;
  interval: SellingPlanInterval;
  intervalCount: Scalars['Int']['output'];
  preAnchorBehavior: SellingPlanRecurringDeliveryPolicyPreAnchorBehavior;
};

export type SellingPlanRecurringDeliveryPolicyInput = {
  anchors?: InputMaybe<Array<SellingPlanAnchorInput>>;
  cutoff?: InputMaybe<Scalars['Int']['input']>;
  intent?: InputMaybe<SellingPlanRecurringDeliveryPolicyIntent>;
  interval?: InputMaybe<SellingPlanInterval>;
  intervalCount?: InputMaybe<Scalars['Int']['input']>;
  preAnchorBehavior?: InputMaybe<SellingPlanRecurringDeliveryPolicyPreAnchorBehavior>;
};

export const SellingPlanRecurringDeliveryPolicyIntent = {
  FulfillmentBegin: 'FULFILLMENT_BEGIN'
} as const;

export type SellingPlanRecurringDeliveryPolicyIntent = typeof SellingPlanRecurringDeliveryPolicyIntent[keyof typeof SellingPlanRecurringDeliveryPolicyIntent];
export const SellingPlanRecurringDeliveryPolicyPreAnchorBehavior = {
  Asap: 'ASAP',
  Next: 'NEXT'
} as const;

export type SellingPlanRecurringDeliveryPolicyPreAnchorBehavior = typeof SellingPlanRecurringDeliveryPolicyPreAnchorBehavior[keyof typeof SellingPlanRecurringDeliveryPolicyPreAnchorBehavior];
export type SellingPlanRecurringPricingPolicy = SellingPlanPricingPolicyBase & {
  adjustmentType: SellingPlanPricingPolicyAdjustmentType;
  adjustmentValue: SellingPlanPricingPolicyAdjustmentValue;
  afterCycle?: Maybe<Scalars['Int']['output']>;
  createdAt: Scalars['DateTime']['output'];
};

export type SellingPlanRecurringPricingPolicyInput = {
  adjustmentType?: InputMaybe<SellingPlanPricingPolicyAdjustmentType>;
  adjustmentValue?: InputMaybe<SellingPlanPricingPolicyValueInput>;
  afterCycle: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
};

export const SellingPlanRemainingBalanceChargeTrigger = {
  ExactTime: 'EXACT_TIME',
  NoRemainingBalance: 'NO_REMAINING_BALANCE',
  TimeAfterCheckout: 'TIME_AFTER_CHECKOUT'
} as const;

export type SellingPlanRemainingBalanceChargeTrigger = typeof SellingPlanRemainingBalanceChargeTrigger[keyof typeof SellingPlanRemainingBalanceChargeTrigger];
export const SellingPlanReserve = {
  OnFulfillment: 'ON_FULFILLMENT',
  OnSale: 'ON_SALE'
} as const;

export type SellingPlanReserve = typeof SellingPlanReserve[keyof typeof SellingPlanReserve];
export type ServerPixel = Node & {
  id: Scalars['ID']['output'];
  status?: Maybe<ServerPixelStatus>;
  webhookEndpointAddress?: Maybe<Scalars['String']['output']>;
};

export type ServerPixelCreatePayload = {
  serverPixel?: Maybe<ServerPixel>;
  userErrors: Array<ErrorsServerPixelUserError>;
};

export type ServerPixelDeletePayload = {
  deletedServerPixelId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<ErrorsServerPixelUserError>;
};

export const ServerPixelStatus = {
  Connected: 'CONNECTED',
  DisconnectedConfigured: 'DISCONNECTED_CONFIGURED',
  DisconnectedUnconfigured: 'DISCONNECTED_UNCONFIGURED'
} as const;

export type ServerPixelStatus = typeof ServerPixelStatus[keyof typeof ServerPixelStatus];
export const ShippingDiscountClass = {
  Shipping: 'SHIPPING'
} as const;

export type ShippingDiscountClass = typeof ShippingDiscountClass[keyof typeof ShippingDiscountClass];
export type ShippingLine = {
  carrierIdentifier?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  currentDiscountedPriceSet: MoneyBag;
  custom: Scalars['Boolean']['output'];
  deliveryCategory?: Maybe<Scalars['String']['output']>;
  discountAllocations: Array<DiscountAllocation>;
  /** @deprecated Use `discountedPriceSet` instead. */
  discountedPrice: MoneyV2;
  discountedPriceSet: MoneyBag;
  id?: Maybe<Scalars['ID']['output']>;
  isRemoved: Scalars['Boolean']['output'];
  /** @deprecated Use `originalPriceSet` instead. */
  originalPrice: MoneyV2;
  originalPriceSet: MoneyBag;
  phone?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use `originalPriceSet` instead. */
  price: Scalars['Money']['output'];
  /** @deprecated requestedFulfillmentService is no longer in use. Order routing does not use the requestedFulfillmentService during order and fulfillment order creation. */
  requestedFulfillmentService?: Maybe<FulfillmentService>;
  shippingRateHandle?: Maybe<Scalars['String']['output']>;
  source?: Maybe<Scalars['String']['output']>;
  taxLines: Array<TaxLine>;
  title: Scalars['String']['output'];
};

export type ShippingLineConnection = {
  edges: Array<ShippingLineEdge>;
  nodes: Array<ShippingLine>;
  pageInfo: PageInfo;
};

export type ShippingLineEdge = {
  cursor: Scalars['String']['output'];
  node: ShippingLine;
};

export type ShippingLineInput = {
  priceWithCurrency?: InputMaybe<MoneyInput>;
  shippingRateHandle?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ShippingLineSale = Sale & {
  actionType: SaleActionType;
  id: Scalars['ID']['output'];
  lineType: SaleLineType;
  quantity?: Maybe<Scalars['Int']['output']>;
  shippingLine?: Maybe<ShippingLine>;
  taxes: Array<SaleTax>;
  totalAmount: MoneyBag;
  totalDiscountAmountAfterTaxes: MoneyBag;
  totalDiscountAmountBeforeTaxes: MoneyBag;
  totalTaxAmount: MoneyBag;
};

export type ShippingPackageDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<UserError>;
};

export type ShippingPackageMakeDefaultPayload = {
  userErrors: Array<UserError>;
};

export const ShippingPackageType = {
  Box: 'BOX',
  Envelope: 'ENVELOPE',
  FlatRate: 'FLAT_RATE',
  SoftPack: 'SOFT_PACK'
} as const;

export type ShippingPackageType = typeof ShippingPackageType[keyof typeof ShippingPackageType];
export type ShippingPackageUpdatePayload = {
  userErrors: Array<UserError>;
};

export type ShippingRate = {
  handle: Scalars['String']['output'];
  price: MoneyV2;
  title: Scalars['String']['output'];
};

export type ShippingRefund = {
  /** @deprecated Use `amountSet` instead. */
  amount: Scalars['Money']['output'];
  amountSet: MoneyBag;
  /** @deprecated Use `maximumRefundableSet` instead. */
  maximumRefundable: Scalars['Money']['output'];
  maximumRefundableSet: MoneyBag;
  /** @deprecated Use `taxSet` instead. */
  tax: Scalars['Money']['output'];
  taxSet: MoneyBag;
};

export type ShippingRefundInput = {
  amount?: InputMaybe<Scalars['Money']['input']>;
  fullRefund?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Shop = HasMetafields & HasPublishedTranslations & Node & {
  accountOwner: StaffMember;
  alerts: Array<ShopAlert>;
  /** @deprecated Deprecated in API version 2024-07. Use `allProductCategoriesList` instead. */
  allProductCategories: Array<ProductCategory>;
  allProductCategoriesList: Array<TaxonomyCategory>;
  /** @deprecated Not supported anymore. */
  analyticsToken: Scalars['String']['output'];
  /** @deprecated Use `QueryRoot.assignedFulfillmentOrders` instead. Details: https://shopify.dev/changelog/moving-the-shop-assignedfulfillmentorders-connection-to-queryroot */
  assignedFulfillmentOrders: FulfillmentOrderConnection;
  availableChannelApps: AppConnection;
  billingAddress: ShopAddress;
  channelDefinitionsForInstalledChannels: Array<AvailableChannelDefinitionsByChannel>;
  /** @deprecated Use `QueryRoot.channels` instead. */
  channels: ChannelConnection;
  checkoutApiSupported: Scalars['Boolean']['output'];
  /** @deprecated Use `QueryRoot.collections` instead. */
  collections: CollectionConnection;
  contactEmail: Scalars['String']['output'];
  countriesInShippingZones: CountriesInShippingZones;
  createdAt: Scalars['DateTime']['output'];
  currencyCode: CurrencyCode;
  currencyFormats: CurrencyFormats;
  currencySettings: CurrencySettingConnection;
  customerAccounts: ShopCustomerAccountsSetting;
  customerAccountsV2: CustomerAccountsV2;
  customerTags: StringConnection;
  /** @deprecated Use `QueryRoot.customers` instead. */
  customers: CustomerConnection;
  description?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use `domainsPaginated` instead. */
  domains: Array<Domain>;
  draftOrderTags: StringConnection;
  /** @deprecated Use `QueryRoot.draftOrders` instead. */
  draftOrders: DraftOrderConnection;
  email: Scalars['String']['output'];
  enabledPresentmentCurrencies: Array<CurrencyCode>;
  features: ShopFeatures;
  /** @deprecated Use `QueryRoot.fulfillmentOrders` instead. */
  fulfillmentOrders: FulfillmentOrderConnection;
  fulfillmentServices: Array<FulfillmentService>;
  ianaTimezone: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** @deprecated Use `QueryRoot.inventoryItems` instead. */
  inventoryItems: InventoryItemConnection;
  /** @deprecated Use `QueryRoot.pendingOrdersCount` instead. */
  limitedPendingOrderCount: LimitedPendingOrderCount;
  /** @deprecated Use `QueryRoot.locations` instead. */
  locations: LocationConnection;
  marketingSmsConsentEnabledAtCheckout: Scalars['Boolean']['output'];
  merchantApprovalSignals?: Maybe<MerchantApprovalSignals>;
  metafield?: Maybe<Metafield>;
  metafields: MetafieldConnection;
  myshopifyDomain: Scalars['String']['output'];
  name: Scalars['String']['output'];
  navigationSettings: Array<NavigationItem>;
  orderNumberFormatPrefix: Scalars['String']['output'];
  orderNumberFormatSuffix: Scalars['String']['output'];
  orderTags: StringConnection;
  /** @deprecated Use `QueryRoot.orders` instead. */
  orders: OrderConnection;
  paymentSettings: PaymentSettings;
  plan: ShopPlan;
  primaryDomain: Domain;
  /** @deprecated Use `files` instead. See [filesQuery](https://shopify.dev/docs/api/admin-graphql/latest/queries/files) and its [query](https://shopify.dev/docs/api/admin-graphql/2024-01/queries/files#argument-query) argument for more information. */
  productImages: ImageConnection;
  /** @deprecated Use `QueryRoot.productTags` instead. */
  productTags: StringConnection;
  /** @deprecated Use `QueryRoot.productTypes` instead. */
  productTypes: StringConnection;
  /** @deprecated Use `QueryRoot.productVariants` instead. */
  productVariants: ProductVariantConnection;
  /** @deprecated Use `QueryRoot.productVendors` instead. */
  productVendors: StringConnection;
  /** @deprecated Use `QueryRoot.products`. */
  products: ProductConnection;
  /** @deprecated Use `QueryRoot.publicationsCount` instead. */
  publicationCount: Scalars['Int']['output'];
  resourceLimits: ShopResourceLimits;
  richTextEditorUrl: Scalars['URL']['output'];
  search: SearchResultConnection;
  searchFilters: SearchFilterOptions;
  setupRequired: Scalars['Boolean']['output'];
  shipsToCountries: Array<CountryCode>;
  shopOwnerName: Scalars['String']['output'];
  shopPolicies: Array<ShopPolicy>;
  /** @deprecated Use `QueryRoot.staffMembers` instead. */
  staffMembers: StaffMemberConnection;
  storefrontAccessTokens: StorefrontAccessTokenConnection;
  /** @deprecated Use `url` instead. */
  storefrontUrl: Scalars['URL']['output'];
  taxShipping: Scalars['Boolean']['output'];
  taxesIncluded: Scalars['Boolean']['output'];
  timezoneAbbreviation: Scalars['String']['output'];
  timezoneOffset: Scalars['String']['output'];
  timezoneOffsetMinutes: Scalars['Int']['output'];
  transactionalSmsDisabled: Scalars['Boolean']['output'];
  translations: Array<Translation>;
  unitSystem: UnitSystem;
  updatedAt: Scalars['DateTime']['output'];
  url: Scalars['URL']['output'];
  weightUnit: WeightUnit;
};


export type ShopAssignedFulfillmentOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  assignmentStatus?: InputMaybe<FulfillmentOrderAssignmentStatus>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  locationIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<FulfillmentOrderSortKeys>;
};


export type ShopAvailableChannelAppsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ShopChannelsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ShopCollectionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<CollectionSortKeys>;
};


export type ShopCurrencySettingsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ShopCustomerTagsArgs = {
  first: Scalars['Int']['input'];
};


export type ShopCustomersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<CustomerSortKeys>;
};


export type ShopDraftOrderTagsArgs = {
  first: Scalars['Int']['input'];
};


export type ShopDraftOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<DraftOrderSortKeys>;
};


export type ShopFulfillmentOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeClosed?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<FulfillmentOrderSortKeys>;
};


export type ShopInventoryItemsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ShopLocationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  includeInactive?: InputMaybe<Scalars['Boolean']['input']>;
  includeLegacy?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<LocationSortKeys>;
};


export type ShopMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type ShopMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ShopOrderTagsArgs = {
  first: Scalars['Int']['input'];
  sort?: InputMaybe<ShopTagSort>;
};


export type ShopOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<OrderSortKeys>;
};


export type ShopProductImagesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<ProductImageSortKeys>;
};


export type ShopProductTagsArgs = {
  first: Scalars['Int']['input'];
};


export type ShopProductTypesArgs = {
  first: Scalars['Int']['input'];
};


export type ShopProductVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<ProductVariantSortKeys>;
};


export type ShopProductVendorsArgs = {
  first: Scalars['Int']['input'];
};


export type ShopProductsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<ProductSortKeys>;
};


export type ShopSearchArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
  query: Scalars['String']['input'];
  types?: InputMaybe<Array<SearchResultType>>;
};


export type ShopStaffMembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ShopStorefrontAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ShopTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export type ShopAddress = Node & {
  address1?: Maybe<Scalars['String']['output']>;
  address2?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  company?: Maybe<Scalars['String']['output']>;
  coordinatesValidated: Scalars['Boolean']['output'];
  country?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use `countryCodeV2` instead. */
  countryCode?: Maybe<Scalars['String']['output']>;
  countryCodeV2?: Maybe<CountryCode>;
  /** @deprecated Always null in this context. */
  firstName?: Maybe<Scalars['String']['output']>;
  formatted: Array<Scalars['String']['output']>;
  formattedArea?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** @deprecated Always null in this context. */
  lastName?: Maybe<Scalars['String']['output']>;
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  /** @deprecated Always null in this context. */
  name?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  provinceCode?: Maybe<Scalars['String']['output']>;
  zip?: Maybe<Scalars['String']['output']>;
};


export type ShopAddressFormattedArgs = {
  withCompany?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShopAlert = {
  action: ShopAlertAction;
  description: Scalars['String']['output'];
};

export type ShopAlertAction = {
  title: Scalars['String']['output'];
  url: Scalars['URL']['output'];
};

export type ShopBillingPreferences = {
  currency: CurrencyCode;
};

export const ShopBranding = {
  Rogers: 'ROGERS',
  Shopify: 'SHOPIFY',
  ShopifyGold: 'SHOPIFY_GOLD',
  ShopifyPlus: 'SHOPIFY_PLUS'
} as const;

export type ShopBranding = typeof ShopBranding[keyof typeof ShopBranding];
export const ShopCustomerAccountsSetting = {
  Disabled: 'DISABLED',
  Optional: 'OPTIONAL',
  Required: 'REQUIRED'
} as const;

export type ShopCustomerAccountsSetting = typeof ShopCustomerAccountsSetting[keyof typeof ShopCustomerAccountsSetting];
export type ShopFeatures = {
  avalaraAvatax: Scalars['Boolean']['output'];
  branding: ShopBranding;
  bundles: BundlesFeature;
  captcha: Scalars['Boolean']['output'];
  /** @deprecated No longer required for external domains */
  captchaExternalDomains: Scalars['Boolean']['output'];
  cartTransform: CartTransformFeature;
  /** @deprecated Delivery profiles are now 100% enabled across Shopify. */
  deliveryProfiles: Scalars['Boolean']['output'];
  dynamicRemarketing: Scalars['Boolean']['output'];
  eligibleForSubscriptionMigration: Scalars['Boolean']['output'];
  eligibleForSubscriptions: Scalars['Boolean']['output'];
  giftCards: Scalars['Boolean']['output'];
  harmonizedSystemCode: Scalars['Boolean']['output'];
  /** @deprecated All shops have international domains through Shopify Markets. */
  internationalDomains: Scalars['Boolean']['output'];
  internationalPriceOverrides: Scalars['Boolean']['output'];
  internationalPriceRules: Scalars['Boolean']['output'];
  legacySubscriptionGatewayEnabled: Scalars['Boolean']['output'];
  liveView: Scalars['Boolean']['output'];
  /** @deprecated No longer supported. */
  onboardingVisual: Scalars['Boolean']['output'];
  paypalExpressSubscriptionGatewayStatus: PaypalExpressSubscriptionsGatewayStatus;
  reports: Scalars['Boolean']['output'];
  sellsSubscriptions: Scalars['Boolean']['output'];
  /** @deprecated Use Shop.plan.shopifyPlus instead. */
  shopifyPlus: Scalars['Boolean']['output'];
  showMetrics: Scalars['Boolean']['output'];
  storefront: Scalars['Boolean']['output'];
  usingShopifyBalance: Scalars['Boolean']['output'];
};

export type ShopLocale = {
  locale: Scalars['String']['output'];
  marketWebPresences: Array<MarketWebPresence>;
  name: Scalars['String']['output'];
  primary: Scalars['Boolean']['output'];
  published: Scalars['Boolean']['output'];
};

export type ShopLocaleDisablePayload = {
  locale?: Maybe<Scalars['String']['output']>;
  userErrors: Array<UserError>;
};

export type ShopLocaleEnablePayload = {
  shopLocale?: Maybe<ShopLocale>;
  userErrors: Array<UserError>;
};

export type ShopLocaleInput = {
  marketWebPresenceIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ShopLocaleUpdatePayload = {
  shopLocale?: Maybe<ShopLocale>;
  userErrors: Array<UserError>;
};

export type ShopPayInstallmentsPaymentDetails = BasePaymentDetails & {
  paymentMethodName?: Maybe<Scalars['String']['output']>;
};

export type ShopPlan = {
  displayName: Scalars['String']['output'];
  partnerDevelopment: Scalars['Boolean']['output'];
  shopifyPlus: Scalars['Boolean']['output'];
};

export type ShopPolicy = HasPublishedTranslations & Node & {
  body: Scalars['HTML']['output'];
  createdAt: Scalars['Date']['output'];
  id: Scalars['ID']['output'];
  title: Scalars['String']['output'];
  translations: Array<Translation>;
  type: ShopPolicyType;
  updatedAt: Scalars['Date']['output'];
  url: Scalars['URL']['output'];
};


export type ShopPolicyTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
};

export const ShopPolicyErrorCode = {
  TooBig: 'TOO_BIG'
} as const;

export type ShopPolicyErrorCode = typeof ShopPolicyErrorCode[keyof typeof ShopPolicyErrorCode];
export type ShopPolicyInput = {
  body: Scalars['String']['input'];
  type: ShopPolicyType;
};

export const ShopPolicyType = {
  ContactInformation: 'CONTACT_INFORMATION',
  LegalNotice: 'LEGAL_NOTICE',
  PrivacyPolicy: 'PRIVACY_POLICY',
  RefundPolicy: 'REFUND_POLICY',
  ShippingPolicy: 'SHIPPING_POLICY',
  SubscriptionPolicy: 'SUBSCRIPTION_POLICY',
  TermsOfSale: 'TERMS_OF_SALE',
  TermsOfService: 'TERMS_OF_SERVICE'
} as const;

export type ShopPolicyType = typeof ShopPolicyType[keyof typeof ShopPolicyType];
export type ShopPolicyUpdatePayload = {
  shopPolicy?: Maybe<ShopPolicy>;
  userErrors: Array<ShopPolicyUserError>;
};

export type ShopPolicyUserError = DisplayableError & {
  code?: Maybe<ShopPolicyErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type ShopResourceFeedbackCreatePayload = {
  feedback?: Maybe<AppFeedback>;
  userErrors: Array<ShopResourceFeedbackCreateUserError>;
};

export type ShopResourceFeedbackCreateUserError = DisplayableError & {
  code?: Maybe<ShopResourceFeedbackCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ShopResourceFeedbackCreateUserErrorCode = {
  Blank: 'BLANK',
  Invalid: 'INVALID',
  OutdatedFeedback: 'OUTDATED_FEEDBACK',
  Present: 'PRESENT'
} as const;

export type ShopResourceFeedbackCreateUserErrorCode = typeof ShopResourceFeedbackCreateUserErrorCode[keyof typeof ShopResourceFeedbackCreateUserErrorCode];
export type ShopResourceLimits = {
  locationLimit: Scalars['Int']['output'];
  maxProductOptions: Scalars['Int']['output'];
  maxProductVariants: Scalars['Int']['output'];
  redirectLimitReached: Scalars['Boolean']['output'];
};

export const ShopTagSort = {
  Alphabetical: 'ALPHABETICAL',
  Popular: 'POPULAR'
} as const;

export type ShopTagSort = typeof ShopTagSort[keyof typeof ShopTagSort];
export type ShopifyFunction = {
  apiType: Scalars['String']['output'];
  apiVersion: Scalars['String']['output'];
  app: App;
  appBridge: FunctionsAppBridge;
  appKey: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  inputQuery?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  useCreationUi: Scalars['Boolean']['output'];
};

export type ShopifyFunctionConnection = {
  edges: Array<ShopifyFunctionEdge>;
  nodes: Array<ShopifyFunction>;
  pageInfo: PageInfo;
};

export type ShopifyFunctionEdge = {
  cursor: Scalars['String']['output'];
  node: ShopifyFunction;
};

export type ShopifyPaymentsAccount = Node & {
  accountOpenerName?: Maybe<Scalars['String']['output']>;
  activated: Scalars['Boolean']['output'];
  balance: Array<MoneyV2>;
  balanceTransactions: ShopifyPaymentsBalanceTransactionConnection;
  bankAccounts: ShopifyPaymentsBankAccountConnection;
  /** @deprecated Use `chargeStatementDescriptors` instead. */
  chargeStatementDescriptor?: Maybe<Scalars['String']['output']>;
  chargeStatementDescriptors?: Maybe<ShopifyPaymentsChargeStatementDescriptor>;
  country: Scalars['String']['output'];
  defaultCurrency: CurrencyCode;
  disputes: ShopifyPaymentsDisputeConnection;
  id: Scalars['ID']['output'];
  onboardable: Scalars['Boolean']['output'];
  payoutSchedule: ShopifyPaymentsPayoutSchedule;
  payoutStatementDescriptor?: Maybe<Scalars['String']['output']>;
  payouts: ShopifyPaymentsPayoutConnection;
};


export type ShopifyPaymentsAccountBalanceTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  hideTransfers?: InputMaybe<Scalars['Boolean']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<BalanceTransactionSortKeys>;
};


export type ShopifyPaymentsAccountBankAccountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ShopifyPaymentsAccountDisputesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ShopifyPaymentsAccountPayoutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<PayoutSortKeys>;
  transactionType?: InputMaybe<ShopifyPaymentsPayoutTransactionType>;
};

export type ShopifyPaymentsAdjustmentOrder = {
  amount: MoneyV2;
  link: Scalars['URL']['output'];
  name: Scalars['String']['output'];
  orderTransactionId: Scalars['BigInt']['output'];
};

export type ShopifyPaymentsAssociatedOrder = {
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type ShopifyPaymentsBalanceTransaction = Node & {
  adjustmentReason?: Maybe<Scalars['String']['output']>;
  adjustmentsOrders: Array<ShopifyPaymentsAdjustmentOrder>;
  amount: MoneyV2;
  associatedOrder?: Maybe<ShopifyPaymentsAssociatedOrder>;
  associatedPayout: ShopifyPaymentsBalanceTransactionAssociatedPayout;
  fee: MoneyV2;
  id: Scalars['ID']['output'];
  net: MoneyV2;
  sourceId?: Maybe<Scalars['BigInt']['output']>;
  sourceOrderTransactionId?: Maybe<Scalars['BigInt']['output']>;
  sourceType?: Maybe<ShopifyPaymentsSourceType>;
  test: Scalars['Boolean']['output'];
  transactionDate: Scalars['DateTime']['output'];
  type: ShopifyPaymentsTransactionType;
};

export type ShopifyPaymentsBalanceTransactionAssociatedPayout = {
  id?: Maybe<Scalars['ID']['output']>;
  status?: Maybe<ShopifyPaymentsBalanceTransactionPayoutStatus>;
};

export type ShopifyPaymentsBalanceTransactionConnection = {
  edges: Array<ShopifyPaymentsBalanceTransactionEdge>;
  nodes: Array<ShopifyPaymentsBalanceTransaction>;
  pageInfo: PageInfo;
};

export type ShopifyPaymentsBalanceTransactionEdge = {
  cursor: Scalars['String']['output'];
  node: ShopifyPaymentsBalanceTransaction;
};

export const ShopifyPaymentsBalanceTransactionPayoutStatus = {
  ActionRequired: 'ACTION_REQUIRED',
  Canceled: 'CANCELED',
  Failed: 'FAILED',
  InTransit: 'IN_TRANSIT',
  Paid: 'PAID',
  Pending: 'PENDING',
  Scheduled: 'SCHEDULED'
} as const;

export type ShopifyPaymentsBalanceTransactionPayoutStatus = typeof ShopifyPaymentsBalanceTransactionPayoutStatus[keyof typeof ShopifyPaymentsBalanceTransactionPayoutStatus];
export type ShopifyPaymentsBankAccount = Node & {
  accountNumberLastDigits: Scalars['String']['output'];
  bankName?: Maybe<Scalars['String']['output']>;
  country: CountryCode;
  createdAt: Scalars['DateTime']['output'];
  currency: CurrencyCode;
  id: Scalars['ID']['output'];
  payouts: ShopifyPaymentsPayoutConnection;
  status: ShopifyPaymentsBankAccountStatus;
};


export type ShopifyPaymentsBankAccountPayoutsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  savedSearchId?: InputMaybe<Scalars['ID']['input']>;
  sortKey?: InputMaybe<PayoutSortKeys>;
  transactionType?: InputMaybe<ShopifyPaymentsPayoutTransactionType>;
};

export type ShopifyPaymentsBankAccountConnection = {
  edges: Array<ShopifyPaymentsBankAccountEdge>;
  nodes: Array<ShopifyPaymentsBankAccount>;
  pageInfo: PageInfo;
};

export type ShopifyPaymentsBankAccountEdge = {
  cursor: Scalars['String']['output'];
  node: ShopifyPaymentsBankAccount;
};

export const ShopifyPaymentsBankAccountStatus = {
  Errored: 'ERRORED',
  New: 'NEW',
  Validated: 'VALIDATED',
  Verified: 'VERIFIED'
} as const;

export type ShopifyPaymentsBankAccountStatus = typeof ShopifyPaymentsBankAccountStatus[keyof typeof ShopifyPaymentsBankAccountStatus];
export type ShopifyPaymentsChargeStatementDescriptor = {
  default?: Maybe<Scalars['String']['output']>;
  prefix: Scalars['String']['output'];
};

export type ShopifyPaymentsDefaultChargeStatementDescriptor = ShopifyPaymentsChargeStatementDescriptor & {
  default?: Maybe<Scalars['String']['output']>;
  prefix: Scalars['String']['output'];
};

export type ShopifyPaymentsDispute = LegacyInteroperability & Node & {
  amount: MoneyV2;
  evidenceDueBy?: Maybe<Scalars['Date']['output']>;
  evidenceSentOn?: Maybe<Scalars['Date']['output']>;
  finalizedOn?: Maybe<Scalars['Date']['output']>;
  id: Scalars['ID']['output'];
  initiatedAt: Scalars['DateTime']['output'];
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  order?: Maybe<Order>;
  reasonDetails: ShopifyPaymentsDisputeReasonDetails;
  status: DisputeStatus;
  type: DisputeType;
};

export type ShopifyPaymentsDisputeConnection = {
  edges: Array<ShopifyPaymentsDisputeEdge>;
  nodes: Array<ShopifyPaymentsDispute>;
  pageInfo: PageInfo;
};

export type ShopifyPaymentsDisputeEdge = {
  cursor: Scalars['String']['output'];
  node: ShopifyPaymentsDispute;
};

export type ShopifyPaymentsDisputeEvidence = Node & {
  accessActivityLog?: Maybe<Scalars['String']['output']>;
  billingAddress?: Maybe<MailingAddress>;
  cancellationPolicyDisclosure?: Maybe<Scalars['String']['output']>;
  cancellationPolicyFile?: Maybe<ShopifyPaymentsDisputeFileUpload>;
  cancellationRebuttal?: Maybe<Scalars['String']['output']>;
  customerCommunicationFile?: Maybe<ShopifyPaymentsDisputeFileUpload>;
  customerEmailAddress?: Maybe<Scalars['String']['output']>;
  customerFirstName?: Maybe<Scalars['String']['output']>;
  customerLastName?: Maybe<Scalars['String']['output']>;
  customerPurchaseIp?: Maybe<Scalars['String']['output']>;
  dispute: ShopifyPaymentsDispute;
  disputeFileUploads: Array<ShopifyPaymentsDisputeFileUpload>;
  fulfillments: Array<ShopifyPaymentsDisputeFulfillment>;
  id: Scalars['ID']['output'];
  productDescription?: Maybe<Scalars['String']['output']>;
  refundPolicyDisclosure?: Maybe<Scalars['String']['output']>;
  refundPolicyFile?: Maybe<ShopifyPaymentsDisputeFileUpload>;
  refundRefusalExplanation?: Maybe<Scalars['String']['output']>;
  serviceDocumentationFile?: Maybe<ShopifyPaymentsDisputeFileUpload>;
  shippingAddress?: Maybe<MailingAddress>;
  shippingDocumentationFile?: Maybe<ShopifyPaymentsDisputeFileUpload>;
  submitted: Scalars['Boolean']['output'];
  uncategorizedFile?: Maybe<ShopifyPaymentsDisputeFileUpload>;
  uncategorizedText?: Maybe<Scalars['String']['output']>;
};

export const ShopifyPaymentsDisputeEvidenceFileType = {
  CancellationPolicyFile: 'CANCELLATION_POLICY_FILE',
  CustomerCommunicationFile: 'CUSTOMER_COMMUNICATION_FILE',
  RefundPolicyFile: 'REFUND_POLICY_FILE',
  ServiceDocumentationFile: 'SERVICE_DOCUMENTATION_FILE',
  ShippingDocumentationFile: 'SHIPPING_DOCUMENTATION_FILE',
  UncategorizedFile: 'UNCATEGORIZED_FILE'
} as const;

export type ShopifyPaymentsDisputeEvidenceFileType = typeof ShopifyPaymentsDisputeEvidenceFileType[keyof typeof ShopifyPaymentsDisputeEvidenceFileType];
export type ShopifyPaymentsDisputeEvidenceUpdateInput = {
  accessActivityLog?: InputMaybe<Scalars['String']['input']>;
  cancellationPolicyDisclosure?: InputMaybe<Scalars['String']['input']>;
  cancellationPolicyFile?: InputMaybe<ShopifyPaymentsDisputeFileUploadUpdateInput>;
  cancellationRebuttal?: InputMaybe<Scalars['String']['input']>;
  customerCommunicationFile?: InputMaybe<ShopifyPaymentsDisputeFileUploadUpdateInput>;
  customerEmailAddress?: InputMaybe<Scalars['String']['input']>;
  customerFirstName?: InputMaybe<Scalars['String']['input']>;
  customerLastName?: InputMaybe<Scalars['String']['input']>;
  refundPolicyDisclosure?: InputMaybe<Scalars['String']['input']>;
  refundPolicyFile?: InputMaybe<ShopifyPaymentsDisputeFileUploadUpdateInput>;
  refundRefusalExplanation?: InputMaybe<Scalars['String']['input']>;
  serviceDocumentationFile?: InputMaybe<ShopifyPaymentsDisputeFileUploadUpdateInput>;
  shippingAddress?: InputMaybe<MailingAddressInput>;
  shippingDocumentationFile?: InputMaybe<ShopifyPaymentsDisputeFileUploadUpdateInput>;
  submitEvidence?: InputMaybe<Scalars['Boolean']['input']>;
  uncategorizedFile?: InputMaybe<ShopifyPaymentsDisputeFileUploadUpdateInput>;
  uncategorizedText?: InputMaybe<Scalars['String']['input']>;
};

export type ShopifyPaymentsDisputeFileUpload = Node & {
  disputeEvidenceType?: Maybe<ShopifyPaymentsDisputeEvidenceFileType>;
  fileSize: Scalars['Int']['output'];
  fileType: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  originalFileName?: Maybe<Scalars['String']['output']>;
  url: Scalars['URL']['output'];
};

export type ShopifyPaymentsDisputeFileUploadUpdateInput = {
  destroy?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
};

export type ShopifyPaymentsDisputeFulfillment = Node & {
  id: Scalars['ID']['output'];
  shippingCarrier?: Maybe<Scalars['String']['output']>;
  shippingDate?: Maybe<Scalars['Date']['output']>;
  shippingTrackingNumber?: Maybe<Scalars['String']['output']>;
};

export const ShopifyPaymentsDisputeReason = {
  BankCannotProcess: 'BANK_CANNOT_PROCESS',
  CreditNotProcessed: 'CREDIT_NOT_PROCESSED',
  CustomerInitiated: 'CUSTOMER_INITIATED',
  DebitNotAuthorized: 'DEBIT_NOT_AUTHORIZED',
  Duplicate: 'DUPLICATE',
  Fraudulent: 'FRAUDULENT',
  General: 'GENERAL',
  IncorrectAccountDetails: 'INCORRECT_ACCOUNT_DETAILS',
  InsufficientFunds: 'INSUFFICIENT_FUNDS',
  ProductNotReceived: 'PRODUCT_NOT_RECEIVED',
  ProductUnacceptable: 'PRODUCT_UNACCEPTABLE',
  SubscriptionCancelled: 'SUBSCRIPTION_CANCELLED',
  Unrecognized: 'UNRECOGNIZED'
} as const;

export type ShopifyPaymentsDisputeReason = typeof ShopifyPaymentsDisputeReason[keyof typeof ShopifyPaymentsDisputeReason];
export type ShopifyPaymentsDisputeReasonDetails = {
  networkReasonCode?: Maybe<Scalars['String']['output']>;
  reason: ShopifyPaymentsDisputeReason;
};

export type ShopifyPaymentsExtendedAuthorization = {
  extendedAuthorizationExpiresAt: Scalars['DateTime']['output'];
  standardAuthorizationExpiresAt: Scalars['DateTime']['output'];
};

export type ShopifyPaymentsJpChargeStatementDescriptor = ShopifyPaymentsChargeStatementDescriptor & {
  default?: Maybe<Scalars['String']['output']>;
  kana?: Maybe<Scalars['String']['output']>;
  kanji?: Maybe<Scalars['String']['output']>;
  prefix: Scalars['String']['output'];
};

export type ShopifyPaymentsPayout = LegacyInteroperability & Node & {
  /** @deprecated Use `destinationAccount` instead. */
  bankAccount?: Maybe<ShopifyPaymentsBankAccount>;
  businessEntity: BusinessEntity;
  /** @deprecated Use `net` instead. */
  gross: MoneyV2;
  id: Scalars['ID']['output'];
  issuedAt: Scalars['DateTime']['output'];
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  net: MoneyV2;
  status: ShopifyPaymentsPayoutStatus;
  summary: ShopifyPaymentsPayoutSummary;
  transactionType: ShopifyPaymentsPayoutTransactionType;
};

export type ShopifyPaymentsPayoutAlternateCurrencyCreatePayload = {
  payout?: Maybe<ShopifyPaymentsToolingProviderPayout>;
  success?: Maybe<Scalars['Boolean']['output']>;
  userErrors: Array<ShopifyPaymentsPayoutAlternateCurrencyCreateUserError>;
};

export type ShopifyPaymentsPayoutAlternateCurrencyCreateUserError = DisplayableError & {
  code?: Maybe<ShopifyPaymentsPayoutAlternateCurrencyCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ShopifyPaymentsPayoutAlternateCurrencyCreateUserErrorCode = {
  AlternateCurrencyPayoutFailedNoEligibleBalance: 'ALTERNATE_CURRENCY_PAYOUT_FAILED_NO_ELIGIBLE_BALANCE',
  AlternateCurrencyPayoutFailedStripeError: 'ALTERNATE_CURRENCY_PAYOUT_FAILED_STRIPE_ERROR',
  MissingProviderAccount: 'MISSING_PROVIDER_ACCOUNT',
  UnknownCoreError: 'UNKNOWN_CORE_ERROR'
} as const;

export type ShopifyPaymentsPayoutAlternateCurrencyCreateUserErrorCode = typeof ShopifyPaymentsPayoutAlternateCurrencyCreateUserErrorCode[keyof typeof ShopifyPaymentsPayoutAlternateCurrencyCreateUserErrorCode];
export type ShopifyPaymentsPayoutConnection = {
  edges: Array<ShopifyPaymentsPayoutEdge>;
  nodes: Array<ShopifyPaymentsPayout>;
  pageInfo: PageInfo;
};

export type ShopifyPaymentsPayoutEdge = {
  cursor: Scalars['String']['output'];
  node: ShopifyPaymentsPayout;
};

export const ShopifyPaymentsPayoutInterval = {
  Daily: 'DAILY',
  Manual: 'MANUAL',
  Monthly: 'MONTHLY',
  Weekly: 'WEEKLY'
} as const;

export type ShopifyPaymentsPayoutInterval = typeof ShopifyPaymentsPayoutInterval[keyof typeof ShopifyPaymentsPayoutInterval];
export type ShopifyPaymentsPayoutSchedule = {
  interval: ShopifyPaymentsPayoutInterval;
  monthlyAnchor?: Maybe<Scalars['Int']['output']>;
  weeklyAnchor?: Maybe<DayOfTheWeek>;
};

export const ShopifyPaymentsPayoutStatus = {
  Canceled: 'CANCELED',
  Failed: 'FAILED',
  InTransit: 'IN_TRANSIT',
  Paid: 'PAID',
  Scheduled: 'SCHEDULED'
} as const;

export type ShopifyPaymentsPayoutStatus = typeof ShopifyPaymentsPayoutStatus[keyof typeof ShopifyPaymentsPayoutStatus];
export type ShopifyPaymentsPayoutSummary = {
  adjustmentsFee: MoneyV2;
  adjustmentsGross: MoneyV2;
  advanceFees: MoneyV2;
  advanceGross: MoneyV2;
  chargesFee: MoneyV2;
  chargesGross: MoneyV2;
  refundsFee: MoneyV2;
  refundsFeeGross: MoneyV2;
  reservedFundsFee: MoneyV2;
  reservedFundsGross: MoneyV2;
  retriedPayoutsFee: MoneyV2;
  retriedPayoutsGross: MoneyV2;
};

export const ShopifyPaymentsPayoutTransactionType = {
  Deposit: 'DEPOSIT',
  Withdrawal: 'WITHDRAWAL'
} as const;

export type ShopifyPaymentsPayoutTransactionType = typeof ShopifyPaymentsPayoutTransactionType[keyof typeof ShopifyPaymentsPayoutTransactionType];
export type ShopifyPaymentsRefundSet = {
  acquirerReferenceNumber?: Maybe<Scalars['String']['output']>;
};

export const ShopifyPaymentsSourceType = {
  Adjustment: 'ADJUSTMENT',
  AdjustmentReversal: 'ADJUSTMENT_REVERSAL',
  Charge: 'CHARGE',
  Dispute: 'DISPUTE',
  Refund: 'REFUND',
  SystemAdjustment: 'SYSTEM_ADJUSTMENT',
  Transfer: 'TRANSFER'
} as const;

export type ShopifyPaymentsSourceType = typeof ShopifyPaymentsSourceType[keyof typeof ShopifyPaymentsSourceType];
export type ShopifyPaymentsToolingProviderPayout = {
  amount: MoneyV2;
  arrivalDate?: Maybe<Scalars['DateTime']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  currency: Scalars['String']['output'];
  remoteId: Scalars['String']['output'];
};

export type ShopifyPaymentsTransactionSet = {
  extendedAuthorizationSet?: Maybe<ShopifyPaymentsExtendedAuthorization>;
  refundSet?: Maybe<ShopifyPaymentsRefundSet>;
};

export const ShopifyPaymentsTransactionType = {
  Adjustment: 'ADJUSTMENT',
  Advance: 'ADVANCE',
  AdvanceFunding: 'ADVANCE_FUNDING',
  AnomalyCredit: 'ANOMALY_CREDIT',
  AnomalyCreditReversal: 'ANOMALY_CREDIT_REVERSAL',
  AnomalyDebit: 'ANOMALY_DEBIT',
  AnomalyDebitReversal: 'ANOMALY_DEBIT_REVERSAL',
  ApplicationFeeRefund: 'APPLICATION_FEE_REFUND',
  BalanceTransferInbound: 'BALANCE_TRANSFER_INBOUND',
  BillingDebit: 'BILLING_DEBIT',
  BillingDebitReversal: 'BILLING_DEBIT_REVERSAL',
  ChannelCredit: 'CHANNEL_CREDIT',
  ChannelCreditReversal: 'CHANNEL_CREDIT_REVERSAL',
  ChannelPromotionCredit: 'CHANNEL_PROMOTION_CREDIT',
  ChannelPromotionCreditReversal: 'CHANNEL_PROMOTION_CREDIT_REVERSAL',
  ChannelTransferCredit: 'CHANNEL_TRANSFER_CREDIT',
  ChannelTransferCreditReversal: 'CHANNEL_TRANSFER_CREDIT_REVERSAL',
  ChannelTransferDebit: 'CHANNEL_TRANSFER_DEBIT',
  ChannelTransferDebitReversal: 'CHANNEL_TRANSFER_DEBIT_REVERSAL',
  Charge: 'CHARGE',
  ChargebackFee: 'CHARGEBACK_FEE',
  ChargebackFeeRefund: 'CHARGEBACK_FEE_REFUND',
  ChargebackHold: 'CHARGEBACK_HOLD',
  ChargebackHoldRelease: 'CHARGEBACK_HOLD_RELEASE',
  ChargebackProtectionCredit: 'CHARGEBACK_PROTECTION_CREDIT',
  ChargebackProtectionCreditReversal: 'CHARGEBACK_PROTECTION_CREDIT_REVERSAL',
  ChargebackProtectionDebit: 'CHARGEBACK_PROTECTION_DEBIT',
  ChargebackProtectionDebitReversal: 'CHARGEBACK_PROTECTION_DEBIT_REVERSAL',
  ChargeAdjustment: 'CHARGE_ADJUSTMENT',
  CollectionsCredit: 'COLLECTIONS_CREDIT',
  CollectionsCreditReversal: 'COLLECTIONS_CREDIT_REVERSAL',
  CustomsDuty: 'CUSTOMS_DUTY',
  CustomsDutyAdjustment: 'CUSTOMS_DUTY_ADJUSTMENT',
  DisputeReversal: 'DISPUTE_REVERSAL',
  DisputeWithdrawal: 'DISPUTE_WITHDRAWAL',
  ImportTax: 'IMPORT_TAX',
  ImportTaxAdjustment: 'IMPORT_TAX_ADJUSTMENT',
  MarketplaceFeeCredit: 'MARKETPLACE_FEE_CREDIT',
  MarketplaceFeeCreditReversal: 'MARKETPLACE_FEE_CREDIT_REVERSAL',
  MarketsProCredit: 'MARKETS_PRO_CREDIT',
  MerchantGoodwillCredit: 'MERCHANT_GOODWILL_CREDIT',
  MerchantGoodwillCreditReversal: 'MERCHANT_GOODWILL_CREDIT_REVERSAL',
  MerchantToMerchantCredit: 'MERCHANT_TO_MERCHANT_CREDIT',
  MerchantToMerchantCreditReversal: 'MERCHANT_TO_MERCHANT_CREDIT_REVERSAL',
  MerchantToMerchantDebit: 'MERCHANT_TO_MERCHANT_DEBIT',
  MerchantToMerchantDebitReversal: 'MERCHANT_TO_MERCHANT_DEBIT_REVERSAL',
  PromotionCredit: 'PROMOTION_CREDIT',
  PromotionCreditReversal: 'PROMOTION_CREDIT_REVERSAL',
  Refund: 'REFUND',
  RefundAdjustment: 'REFUND_ADJUSTMENT',
  RefundFailure: 'REFUND_FAILURE',
  ReservedFunds: 'RESERVED_FUNDS',
  ReservedFundsReversal: 'RESERVED_FUNDS_REVERSAL',
  ReservedFundsWithdrawal: 'RESERVED_FUNDS_WITHDRAWAL',
  RiskReversal: 'RISK_REVERSAL',
  RiskWithdrawal: 'RISK_WITHDRAWAL',
  SellerProtectionCredit: 'SELLER_PROTECTION_CREDIT',
  SellerProtectionCreditReversal: 'SELLER_PROTECTION_CREDIT_REVERSAL',
  ShippingLabel: 'SHIPPING_LABEL',
  ShippingLabelAdjustment: 'SHIPPING_LABEL_ADJUSTMENT',
  ShippingLabelAdjustmentBase: 'SHIPPING_LABEL_ADJUSTMENT_BASE',
  ShippingLabelAdjustmentSurcharge: 'SHIPPING_LABEL_ADJUSTMENT_SURCHARGE',
  ShippingOtherCarrierChargeAdjustment: 'SHIPPING_OTHER_CARRIER_CHARGE_ADJUSTMENT',
  ShippingReturnToOriginAdjustment: 'SHIPPING_RETURN_TO_ORIGIN_ADJUSTMENT',
  ShopifyCollectiveCredit: 'SHOPIFY_COLLECTIVE_CREDIT',
  ShopifyCollectiveCreditReversal: 'SHOPIFY_COLLECTIVE_CREDIT_REVERSAL',
  ShopifyCollectiveDebit: 'SHOPIFY_COLLECTIVE_DEBIT',
  ShopifyCollectiveDebitReversal: 'SHOPIFY_COLLECTIVE_DEBIT_REVERSAL',
  ShopifySourceCredit: 'SHOPIFY_SOURCE_CREDIT',
  ShopifySourceCreditReversal: 'SHOPIFY_SOURCE_CREDIT_REVERSAL',
  ShopifySourceDebit: 'SHOPIFY_SOURCE_DEBIT',
  ShopifySourceDebitReversal: 'SHOPIFY_SOURCE_DEBIT_REVERSAL',
  ShopCashBillingDebit: 'SHOP_CASH_BILLING_DEBIT',
  ShopCashBillingDebitReversal: 'SHOP_CASH_BILLING_DEBIT_REVERSAL',
  ShopCashCampaignBillingCredit: 'SHOP_CASH_CAMPAIGN_BILLING_CREDIT',
  ShopCashCampaignBillingCreditReversal: 'SHOP_CASH_CAMPAIGN_BILLING_CREDIT_REVERSAL',
  ShopCashCampaignBillingDebit: 'SHOP_CASH_CAMPAIGN_BILLING_DEBIT',
  ShopCashCampaignBillingDebitReversal: 'SHOP_CASH_CAMPAIGN_BILLING_DEBIT_REVERSAL',
  ShopCashCredit: 'SHOP_CASH_CREDIT',
  ShopCashCreditReversal: 'SHOP_CASH_CREDIT_REVERSAL',
  ShopCashRefundDebit: 'SHOP_CASH_REFUND_DEBIT',
  ShopCashRefundDebitReversal: 'SHOP_CASH_REFUND_DEBIT_REVERSAL',
  StripeFee: 'STRIPE_FEE',
  TaxAdjustmentCredit: 'TAX_ADJUSTMENT_CREDIT',
  TaxAdjustmentCreditReversal: 'TAX_ADJUSTMENT_CREDIT_REVERSAL',
  TaxAdjustmentDebit: 'TAX_ADJUSTMENT_DEBIT',
  TaxAdjustmentDebitReversal: 'TAX_ADJUSTMENT_DEBIT_REVERSAL',
  Transfer: 'TRANSFER',
  TransferCancel: 'TRANSFER_CANCEL',
  TransferFailure: 'TRANSFER_FAILURE',
  TransferRefund: 'TRANSFER_REFUND',
  VatRefundCredit: 'VAT_REFUND_CREDIT',
  VatRefundCreditReversal: 'VAT_REFUND_CREDIT_REVERSAL'
} as const;

export type ShopifyPaymentsTransactionType = typeof ShopifyPaymentsTransactionType[keyof typeof ShopifyPaymentsTransactionType];
export type ShopifyPaymentsVerification = Node & {
  id: Scalars['ID']['output'];
  status: ShopifyPaymentsVerificationStatus;
  subject: ShopifyPaymentsVerificationSubject;
};

export const ShopifyPaymentsVerificationStatus = {
  Pending: 'PENDING',
  Unverified: 'UNVERIFIED',
  Verified: 'VERIFIED'
} as const;

export type ShopifyPaymentsVerificationStatus = typeof ShopifyPaymentsVerificationStatus[keyof typeof ShopifyPaymentsVerificationStatus];
export type ShopifyPaymentsVerificationSubject = {
  familyName: Scalars['String']['output'];
  givenName: Scalars['String']['output'];
};

export const ShopifyProtectEligibilityStatus = {
  Eligible: 'ELIGIBLE',
  NotEligible: 'NOT_ELIGIBLE',
  Pending: 'PENDING'
} as const;

export type ShopifyProtectEligibilityStatus = typeof ShopifyProtectEligibilityStatus[keyof typeof ShopifyProtectEligibilityStatus];
export type ShopifyProtectOrderEligibility = {
  status: ShopifyProtectEligibilityStatus;
};

export type ShopifyProtectOrderSummary = {
  eligibility: ShopifyProtectOrderEligibility;
  status: ShopifyProtectStatus;
};

export const ShopifyProtectStatus = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  NotProtected: 'NOT_PROTECTED',
  Pending: 'PENDING',
  Protected: 'PROTECTED'
} as const;

export type ShopifyProtectStatus = typeof ShopifyProtectStatus[keyof typeof ShopifyProtectStatus];
export type StaffMember = Node & {
  accountType?: Maybe<AccountType>;
  active: Scalars['Boolean']['output'];
  avatar: Image;
  email: Scalars['String']['output'];
  exists: Scalars['Boolean']['output'];
  firstName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  initials?: Maybe<Array<Scalars['String']['output']>>;
  isShopOwner: Scalars['Boolean']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  phone?: Maybe<Scalars['String']['output']>;
  privateData: StaffMemberPrivateData;
};


export type StaffMemberAvatarArgs = {
  fallback?: InputMaybe<StaffMemberDefaultImage>;
};

export type StaffMemberConnection = {
  edges: Array<StaffMemberEdge>;
  nodes: Array<StaffMember>;
  pageInfo: PageInfo;
};

export const StaffMemberDefaultImage = {
  Default: 'DEFAULT',
  NotFound: 'NOT_FOUND',
  Transparent: 'TRANSPARENT'
} as const;

export type StaffMemberDefaultImage = typeof StaffMemberDefaultImage[keyof typeof StaffMemberDefaultImage];
export type StaffMemberEdge = {
  cursor: Scalars['String']['output'];
  node: StaffMember;
};

export const StaffMemberPermission = {
  Applications: 'APPLICATIONS',
  Channels: 'CHANNELS',
  CreateAndEditCustomers: 'CREATE_AND_EDIT_CUSTOMERS',
  CreateAndEditGiftCards: 'CREATE_AND_EDIT_GIFT_CARDS',
  Customers: 'CUSTOMERS',
  Dashboard: 'DASHBOARD',
  DeactivateGiftCards: 'DEACTIVATE_GIFT_CARDS',
  DeleteCustomers: 'DELETE_CUSTOMERS',
  Domains: 'DOMAINS',
  DraftOrders: 'DRAFT_ORDERS',
  EditOrders: 'EDIT_ORDERS',
  EraseCustomerData: 'ERASE_CUSTOMER_DATA',
  ExportCustomers: 'EXPORT_CUSTOMERS',
  ExportGiftCards: 'EXPORT_GIFT_CARDS',
  Full: 'FULL',
  GiftCards: 'GIFT_CARDS',
  Links: 'LINKS',
  Locations: 'LOCATIONS',
  Marketing: 'MARKETING',
  MarketingSection: 'MARKETING_SECTION',
  MergeCustomers: 'MERGE_CUSTOMERS',
  Orders: 'ORDERS',
  Overviews: 'OVERVIEWS',
  Pages: 'PAGES',
  PayOrdersByVaultedCard: 'PAY_ORDERS_BY_VAULTED_CARD',
  Preferences: 'PREFERENCES',
  Products: 'PRODUCTS',
  Reports: 'REPORTS',
  RequestCustomerData: 'REQUEST_CUSTOMER_DATA',
  Themes: 'THEMES',
  Translations: 'TRANSLATIONS'
} as const;

export type StaffMemberPermission = typeof StaffMemberPermission[keyof typeof StaffMemberPermission];
export type StaffMemberPrivateData = {
  accountSettingsUrl: Scalars['URL']['output'];
  createdAt: Scalars['DateTime']['output'];
  /** @deprecated There's no alternative field to use instead. */
  permissions: Array<StaffMemberPermission>;
};

export const StaffMembersSortKeys = {
  Email: 'EMAIL',
  FirstName: 'FIRST_NAME',
  Id: 'ID',
  LastName: 'LAST_NAME'
} as const;

export type StaffMembersSortKeys = typeof StaffMembersSortKeys[keyof typeof StaffMembersSortKeys];
export type StageImageInput = {
  filename: Scalars['String']['input'];
  httpMethod?: InputMaybe<StagedUploadHttpMethodType>;
  mimeType: Scalars['String']['input'];
  resource: StagedUploadTargetGenerateUploadResource;
};

export type StagedMediaUploadTarget = {
  parameters: Array<StagedUploadParameter>;
  resourceUrl?: Maybe<Scalars['URL']['output']>;
  url?: Maybe<Scalars['URL']['output']>;
};

export const StagedUploadHttpMethodType = {
  Post: 'POST',
  Put: 'PUT'
} as const;

export type StagedUploadHttpMethodType = typeof StagedUploadHttpMethodType[keyof typeof StagedUploadHttpMethodType];
export type StagedUploadInput = {
  fileSize?: InputMaybe<Scalars['UnsignedInt64']['input']>;
  filename: Scalars['String']['input'];
  httpMethod?: InputMaybe<StagedUploadHttpMethodType>;
  mimeType: Scalars['String']['input'];
  resource: StagedUploadTargetGenerateUploadResource;
};

export type StagedUploadParameter = {
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type StagedUploadTarget = {
  parameters: Array<ImageUploadParameter>;
  url: Scalars['String']['output'];
};

export type StagedUploadTargetGenerateInput = {
  fileSize?: InputMaybe<Scalars['UnsignedInt64']['input']>;
  filename: Scalars['String']['input'];
  httpMethod?: InputMaybe<StagedUploadHttpMethodType>;
  mimeType: Scalars['String']['input'];
  resource: StagedUploadTargetGenerateUploadResource;
};

export type StagedUploadTargetGeneratePayload = {
  parameters: Array<MutationsStagedUploadTargetGenerateUploadParameter>;
  url: Scalars['String']['output'];
  userErrors: Array<UserError>;
};

export const StagedUploadTargetGenerateUploadResource = {
  BulkMutationVariables: 'BULK_MUTATION_VARIABLES',
  CollectionImage: 'COLLECTION_IMAGE',
  File: 'FILE',
  Image: 'IMAGE',
  Model_3D: 'MODEL_3D',
  ProductImage: 'PRODUCT_IMAGE',
  ReturnLabel: 'RETURN_LABEL',
  ShopImage: 'SHOP_IMAGE',
  UrlRedirectImport: 'URL_REDIRECT_IMPORT',
  Video: 'VIDEO'
} as const;

export type StagedUploadTargetGenerateUploadResource = typeof StagedUploadTargetGenerateUploadResource[keyof typeof StagedUploadTargetGenerateUploadResource];
export type StagedUploadTargetsGeneratePayload = {
  urls?: Maybe<Array<StagedUploadTarget>>;
  userErrors: Array<UserError>;
};

export type StagedUploadsCreatePayload = {
  stagedTargets?: Maybe<Array<StagedMediaUploadTarget>>;
  userErrors: Array<UserError>;
};

export type StandardMetafieldDefinitionAccessInput = {
  admin?: InputMaybe<MetafieldAdminAccessInput>;
  customerAccount?: InputMaybe<MetafieldCustomerAccountAccessInput>;
  storefront?: InputMaybe<MetafieldStorefrontAccessInput>;
};

export type StandardMetafieldDefinitionEnablePayload = {
  createdDefinition?: Maybe<MetafieldDefinition>;
  userErrors: Array<StandardMetafieldDefinitionEnableUserError>;
};

export type StandardMetafieldDefinitionEnableUserError = DisplayableError & {
  code?: Maybe<StandardMetafieldDefinitionEnableUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const StandardMetafieldDefinitionEnableUserErrorCode = {
  AdminAccessInputNotAllowed: 'ADMIN_ACCESS_INPUT_NOT_ALLOWED',
  Invalid: 'INVALID',
  InvalidCapability: 'INVALID_CAPABILITY',
  InvalidInputCombination: 'INVALID_INPUT_COMBINATION',
  LimitExceeded: 'LIMIT_EXCEEDED',
  Taken: 'TAKEN',
  TemplateNotFound: 'TEMPLATE_NOT_FOUND',
  TypeNotAllowedForConditions: 'TYPE_NOT_ALLOWED_FOR_CONDITIONS',
  UnstructuredAlreadyExists: 'UNSTRUCTURED_ALREADY_EXISTS',
  UnsupportedPinning: 'UNSUPPORTED_PINNING'
} as const;

export type StandardMetafieldDefinitionEnableUserErrorCode = typeof StandardMetafieldDefinitionEnableUserErrorCode[keyof typeof StandardMetafieldDefinitionEnableUserErrorCode];
export type StandardMetafieldDefinitionTemplate = Node & {
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  name: Scalars['String']['output'];
  namespace: Scalars['String']['output'];
  ownerTypes: Array<MetafieldOwnerType>;
  type: MetafieldDefinitionType;
  validations: Array<MetafieldDefinitionValidation>;
  visibleToStorefrontApi: Scalars['Boolean']['output'];
};

export type StandardMetafieldDefinitionTemplateConnection = {
  edges: Array<StandardMetafieldDefinitionTemplateEdge>;
  nodes: Array<StandardMetafieldDefinitionTemplate>;
  pageInfo: PageInfo;
};

export type StandardMetafieldDefinitionTemplateEdge = {
  cursor: Scalars['String']['output'];
  node: StandardMetafieldDefinitionTemplate;
};

export type StandardMetaobjectDefinitionEnablePayload = {
  metaobjectDefinition?: Maybe<MetaobjectDefinition>;
  userErrors: Array<MetaobjectUserError>;
};

export type StandardizedProductType = {
  productTaxonomyNode?: Maybe<ProductTaxonomyNode>;
};

export type StoreCreditAccount = Node & {
  balance: MoneyV2;
  id: Scalars['ID']['output'];
  owner: HasStoreCreditAccounts;
  transactions: StoreCreditAccountTransactionConnection;
};


export type StoreCreditAccountTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<TransactionSortKeys>;
};

export type StoreCreditAccountConnection = {
  edges: Array<StoreCreditAccountEdge>;
  nodes: Array<StoreCreditAccount>;
  pageInfo: PageInfo;
};

export type StoreCreditAccountCreditInput = {
  creditAmount: MoneyInput;
  expiresAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreditAccountCreditPayload = {
  storeCreditAccountTransaction?: Maybe<StoreCreditAccountCreditTransaction>;
  userErrors: Array<StoreCreditAccountCreditUserError>;
};

export type StoreCreditAccountCreditTransaction = Node & StoreCreditAccountTransaction & {
  account: StoreCreditAccount;
  amount: MoneyV2;
  balanceAfterTransaction: MoneyV2;
  createdAt: Scalars['DateTime']['output'];
  event: StoreCreditSystemEvent;
  expiresAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  origin?: Maybe<StoreCreditAccountTransactionOrigin>;
  remainingAmount: MoneyV2;
};

export type StoreCreditAccountCreditUserError = DisplayableError & {
  code?: Maybe<StoreCreditAccountCreditUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const StoreCreditAccountCreditUserErrorCode = {
  AccountNotFound: 'ACCOUNT_NOT_FOUND',
  CreditLimitExceeded: 'CREDIT_LIMIT_EXCEEDED',
  ExpiresAtInPast: 'EXPIRES_AT_IN_PAST',
  MismatchingCurrency: 'MISMATCHING_CURRENCY',
  NegativeOrZeroAmount: 'NEGATIVE_OR_ZERO_AMOUNT',
  OwnerNotFound: 'OWNER_NOT_FOUND',
  UnsupportedCurrency: 'UNSUPPORTED_CURRENCY'
} as const;

export type StoreCreditAccountCreditUserErrorCode = typeof StoreCreditAccountCreditUserErrorCode[keyof typeof StoreCreditAccountCreditUserErrorCode];
export type StoreCreditAccountDebitInput = {
  debitAmount: MoneyInput;
};

export type StoreCreditAccountDebitPayload = {
  storeCreditAccountTransaction?: Maybe<StoreCreditAccountDebitTransaction>;
  userErrors: Array<StoreCreditAccountDebitUserError>;
};

export type StoreCreditAccountDebitRevertTransaction = Node & StoreCreditAccountTransaction & {
  account: StoreCreditAccount;
  amount: MoneyV2;
  balanceAfterTransaction: MoneyV2;
  createdAt: Scalars['DateTime']['output'];
  debitTransaction: StoreCreditAccountDebitTransaction;
  event: StoreCreditSystemEvent;
  id: Scalars['ID']['output'];
  origin?: Maybe<StoreCreditAccountTransactionOrigin>;
};

export type StoreCreditAccountDebitTransaction = Node & StoreCreditAccountTransaction & {
  account: StoreCreditAccount;
  amount: MoneyV2;
  balanceAfterTransaction: MoneyV2;
  createdAt: Scalars['DateTime']['output'];
  event: StoreCreditSystemEvent;
  id: Scalars['ID']['output'];
  origin?: Maybe<StoreCreditAccountTransactionOrigin>;
};

export type StoreCreditAccountDebitUserError = DisplayableError & {
  code?: Maybe<StoreCreditAccountDebitUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const StoreCreditAccountDebitUserErrorCode = {
  AccountNotFound: 'ACCOUNT_NOT_FOUND',
  InsufficientFunds: 'INSUFFICIENT_FUNDS',
  MismatchingCurrency: 'MISMATCHING_CURRENCY',
  NegativeOrZeroAmount: 'NEGATIVE_OR_ZERO_AMOUNT'
} as const;

export type StoreCreditAccountDebitUserErrorCode = typeof StoreCreditAccountDebitUserErrorCode[keyof typeof StoreCreditAccountDebitUserErrorCode];
export type StoreCreditAccountEdge = {
  cursor: Scalars['String']['output'];
  node: StoreCreditAccount;
};

export type StoreCreditAccountExpirationTransaction = StoreCreditAccountTransaction & {
  account: StoreCreditAccount;
  amount: MoneyV2;
  balanceAfterTransaction: MoneyV2;
  createdAt: Scalars['DateTime']['output'];
  creditTransaction: StoreCreditAccountCreditTransaction;
  event: StoreCreditSystemEvent;
  origin?: Maybe<StoreCreditAccountTransactionOrigin>;
};

export type StoreCreditAccountTransaction = {
  account: StoreCreditAccount;
  amount: MoneyV2;
  balanceAfterTransaction: MoneyV2;
  createdAt: Scalars['DateTime']['output'];
  event: StoreCreditSystemEvent;
  origin?: Maybe<StoreCreditAccountTransactionOrigin>;
};

export type StoreCreditAccountTransactionConnection = {
  edges: Array<StoreCreditAccountTransactionEdge>;
  nodes: Array<StoreCreditAccountTransaction>;
  pageInfo: PageInfo;
};

export type StoreCreditAccountTransactionEdge = {
  cursor: Scalars['String']['output'];
  node: StoreCreditAccountTransaction;
};

export type StoreCreditAccountTransactionOrigin = OrderTransaction;

export const StoreCreditSystemEvent = {
  Adjustment: 'ADJUSTMENT',
  OrderCancellation: 'ORDER_CANCELLATION',
  OrderPayment: 'ORDER_PAYMENT',
  OrderRefund: 'ORDER_REFUND',
  PaymentFailure: 'PAYMENT_FAILURE',
  PaymentReturned: 'PAYMENT_RETURNED',
  TaxFinalization: 'TAX_FINALIZATION'
} as const;

export type StoreCreditSystemEvent = typeof StoreCreditSystemEvent[keyof typeof StoreCreditSystemEvent];
export type StorefrontAccessToken = Node & {
  accessScopes: Array<AccessScope>;
  accessToken: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type StorefrontAccessTokenConnection = {
  edges: Array<StorefrontAccessTokenEdge>;
  nodes: Array<StorefrontAccessToken>;
  pageInfo: PageInfo;
};

export type StorefrontAccessTokenCreatePayload = {
  shop: Shop;
  storefrontAccessToken?: Maybe<StorefrontAccessToken>;
  userErrors: Array<UserError>;
};

export type StorefrontAccessTokenDeleteInput = {
  id: Scalars['ID']['input'];
};

export type StorefrontAccessTokenDeletePayload = {
  deletedStorefrontAccessTokenId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<UserError>;
};

export type StorefrontAccessTokenEdge = {
  cursor: Scalars['String']['output'];
  node: StorefrontAccessToken;
};

export type StorefrontAccessTokenInput = {
  title: Scalars['String']['input'];
};

export type StringConnection = {
  edges: Array<StringEdge>;
  nodes: Array<Scalars['String']['output']>;
  pageInfo: PageInfo;
};

export type StringEdge = {
  cursor: Scalars['String']['output'];
  node: Scalars['String']['output'];
};

export type SubscriptionAppliedCodeDiscount = {
  id: Scalars['ID']['output'];
  redeemCode: Scalars['String']['output'];
  rejectionReason?: Maybe<SubscriptionDiscountRejectionReason>;
};

export type SubscriptionAtomicLineInput = {
  discounts?: InputMaybe<Array<SubscriptionAtomicManualDiscountInput>>;
  line: SubscriptionLineInput;
};

export type SubscriptionAtomicManualDiscountInput = {
  recurringCycleLimit?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<SubscriptionManualDiscountValueInput>;
};

export type SubscriptionBillingAttempt = Node & {
  completedAt?: Maybe<Scalars['DateTime']['output']>;
  createdAt: Scalars['DateTime']['output'];
  /** @deprecated As of API version 2025-01, use `processingError.code` instead to get the errorCode */
  errorCode?: Maybe<SubscriptionBillingAttemptErrorCode>;
  /** @deprecated As of API version 2025-01, use `processingError.message` instead to get the errorMessage */
  errorMessage?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  idempotencyKey: Scalars['String']['output'];
  nextActionUrl?: Maybe<Scalars['URL']['output']>;
  order?: Maybe<Order>;
  originTime?: Maybe<Scalars['DateTime']['output']>;
  paymentGroupId?: Maybe<Scalars['String']['output']>;
  paymentSessionId?: Maybe<Scalars['String']['output']>;
  processingError?: Maybe<SubscriptionBillingAttemptProcessingError>;
  ready: Scalars['Boolean']['output'];
  respectInventoryPolicy: Scalars['Boolean']['output'];
  subscriptionContract: SubscriptionContract;
  transactions: OrderTransactionConnection;
};


export type SubscriptionBillingAttemptTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SubscriptionBillingAttemptConnection = {
  edges: Array<SubscriptionBillingAttemptEdge>;
  nodes: Array<SubscriptionBillingAttempt>;
  pageInfo: PageInfo;
};

export type SubscriptionBillingAttemptCreatePayload = {
  subscriptionBillingAttempt?: Maybe<SubscriptionBillingAttempt>;
  userErrors: Array<BillingAttemptUserError>;
};

export type SubscriptionBillingAttemptEdge = {
  cursor: Scalars['String']['output'];
  node: SubscriptionBillingAttempt;
};

export const SubscriptionBillingAttemptErrorCode = {
  AmountTooSmall: 'AMOUNT_TOO_SMALL',
  AuthenticationError: 'AUTHENTICATION_ERROR',
  BuyerCanceledPaymentMethod: 'BUYER_CANCELED_PAYMENT_METHOD',
  CardNumberIncorrect: 'CARD_NUMBER_INCORRECT',
  CustomerInvalid: 'CUSTOMER_INVALID',
  CustomerNotFound: 'CUSTOMER_NOT_FOUND',
  ExpiredPaymentMethod: 'EXPIRED_PAYMENT_METHOD',
  FraudSuspected: 'FRAUD_SUSPECTED',
  InsufficientFunds: 'INSUFFICIENT_FUNDS',
  InsufficientInventory: 'INSUFFICIENT_INVENTORY',
  InvalidCustomerBillingAgreement: 'INVALID_CUSTOMER_BILLING_AGREEMENT',
  InvalidPaymentMethod: 'INVALID_PAYMENT_METHOD',
  InvalidShippingAddress: 'INVALID_SHIPPING_ADDRESS',
  InventoryAllocationsNotFound: 'INVENTORY_ALLOCATIONS_NOT_FOUND',
  InvoiceAlreadyPaid: 'INVOICE_ALREADY_PAID',
  PaymentMethodDeclined: 'PAYMENT_METHOD_DECLINED',
  PaymentMethodIncompatibleWithGatewayConfig: 'PAYMENT_METHOD_INCOMPATIBLE_WITH_GATEWAY_CONFIG',
  PaymentMethodNotFound: 'PAYMENT_METHOD_NOT_FOUND',
  PaymentProviderIsNotEnabled: 'PAYMENT_PROVIDER_IS_NOT_ENABLED',
  PaypalErrorGeneral: 'PAYPAL_ERROR_GENERAL',
  PurchaseTypeNotSupported: 'PURCHASE_TYPE_NOT_SUPPORTED',
  TestMode: 'TEST_MODE',
  TransientError: 'TRANSIENT_ERROR',
  UnexpectedError: 'UNEXPECTED_ERROR'
} as const;

export type SubscriptionBillingAttemptErrorCode = typeof SubscriptionBillingAttemptErrorCode[keyof typeof SubscriptionBillingAttemptErrorCode];
export type SubscriptionBillingAttemptGenericError = SubscriptionBillingAttemptProcessingError & {
  code: SubscriptionBillingAttemptErrorCode;
  message: Scalars['String']['output'];
};

export type SubscriptionBillingAttemptInput = {
  billingCycleSelector?: InputMaybe<SubscriptionBillingCycleSelector>;
  idempotencyKey: Scalars['String']['input'];
  inventoryPolicy?: InputMaybe<SubscriptionBillingAttemptInventoryPolicy>;
  originTime?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SubscriptionBillingAttemptInsufficientStockProductVariantsError = SubscriptionBillingAttemptProcessingError & {
  code: SubscriptionBillingAttemptErrorCode;
  insufficientStockProductVariants: ProductVariantConnection;
  message: Scalars['String']['output'];
};


export type SubscriptionBillingAttemptInsufficientStockProductVariantsErrorInsufficientStockProductVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export const SubscriptionBillingAttemptInventoryPolicy = {
  AllowOverselling: 'ALLOW_OVERSELLING',
  ProductVariantInventoryPolicy: 'PRODUCT_VARIANT_INVENTORY_POLICY'
} as const;

export type SubscriptionBillingAttemptInventoryPolicy = typeof SubscriptionBillingAttemptInventoryPolicy[keyof typeof SubscriptionBillingAttemptInventoryPolicy];
export type SubscriptionBillingAttemptOutOfStockProductVariantsError = SubscriptionBillingAttemptProcessingError & {
  code: SubscriptionBillingAttemptErrorCode;
  message: Scalars['String']['output'];
  /** @deprecated Use `subscriptionBillingAttemptInsufficientStockProductVariantsError` type instead. */
  outOfStockProductVariants: ProductVariantConnection;
};


export type SubscriptionBillingAttemptOutOfStockProductVariantsErrorOutOfStockProductVariantsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SubscriptionBillingAttemptProcessingError = {
  code: SubscriptionBillingAttemptErrorCode;
  message: Scalars['String']['output'];
};

export const SubscriptionBillingAttemptsSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type SubscriptionBillingAttemptsSortKeys = typeof SubscriptionBillingAttemptsSortKeys[keyof typeof SubscriptionBillingAttemptsSortKeys];
export type SubscriptionBillingCycle = {
  billingAttemptExpectedDate: Scalars['DateTime']['output'];
  billingAttempts: SubscriptionBillingAttemptConnection;
  cycleEndAt: Scalars['DateTime']['output'];
  cycleIndex: Scalars['Int']['output'];
  cycleStartAt: Scalars['DateTime']['output'];
  edited: Scalars['Boolean']['output'];
  editedContract?: Maybe<SubscriptionBillingCycleEditedContract>;
  skipped: Scalars['Boolean']['output'];
  sourceContract: SubscriptionContract;
  status: SubscriptionBillingCycleBillingCycleStatus;
};


export type SubscriptionBillingCycleBillingAttemptsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export const SubscriptionBillingCycleBillingAttemptStatus = {
  Any: 'ANY',
  HasAttempt: 'HAS_ATTEMPT',
  NoAttempt: 'NO_ATTEMPT'
} as const;

export type SubscriptionBillingCycleBillingAttemptStatus = typeof SubscriptionBillingCycleBillingAttemptStatus[keyof typeof SubscriptionBillingCycleBillingAttemptStatus];
export const SubscriptionBillingCycleBillingCycleStatus = {
  Billed: 'BILLED',
  Unbilled: 'UNBILLED'
} as const;

export type SubscriptionBillingCycleBillingCycleStatus = typeof SubscriptionBillingCycleBillingCycleStatus[keyof typeof SubscriptionBillingCycleBillingCycleStatus];
export type SubscriptionBillingCycleBulkChargePayload = {
  job?: Maybe<Job>;
  userErrors: Array<SubscriptionBillingCycleBulkUserError>;
};

export type SubscriptionBillingCycleBulkFilters = {
  billingAttemptStatus?: InputMaybe<SubscriptionBillingCycleBillingAttemptStatus>;
  billingCycleStatus?: InputMaybe<Array<SubscriptionBillingCycleBillingCycleStatus>>;
  contractStatus?: InputMaybe<Array<SubscriptionContractSubscriptionStatus>>;
};

export type SubscriptionBillingCycleBulkSearchPayload = {
  job?: Maybe<Job>;
  userErrors: Array<SubscriptionBillingCycleBulkUserError>;
};

export type SubscriptionBillingCycleBulkUserError = DisplayableError & {
  code?: Maybe<SubscriptionBillingCycleBulkUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const SubscriptionBillingCycleBulkUserErrorCode = {
  Blank: 'BLANK',
  EndDateInTheFuture: 'END_DATE_IN_THE_FUTURE',
  Invalid: 'INVALID',
  InvalidDateRange: 'INVALID_DATE_RANGE',
  StartDateBeforeEndDate: 'START_DATE_BEFORE_END_DATE'
} as const;

export type SubscriptionBillingCycleBulkUserErrorCode = typeof SubscriptionBillingCycleBulkUserErrorCode[keyof typeof SubscriptionBillingCycleBulkUserErrorCode];
export type SubscriptionBillingCycleChargePayload = {
  subscriptionBillingAttempt?: Maybe<SubscriptionBillingAttempt>;
  userErrors: Array<BillingAttemptUserError>;
};

export type SubscriptionBillingCycleConnection = {
  edges: Array<SubscriptionBillingCycleEdge>;
  nodes: Array<SubscriptionBillingCycle>;
  pageInfo: PageInfo;
};

export type SubscriptionBillingCycleContractDraftCommitPayload = {
  contract?: Maybe<SubscriptionBillingCycleEditedContract>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionBillingCycleContractDraftConcatenatePayload = {
  draft?: Maybe<SubscriptionDraft>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionBillingCycleContractEditPayload = {
  draft?: Maybe<SubscriptionDraft>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionBillingCycleEdge = {
  cursor: Scalars['String']['output'];
  node: SubscriptionBillingCycle;
};

export type SubscriptionBillingCycleEditDeletePayload = {
  billingCycles?: Maybe<Array<SubscriptionBillingCycle>>;
  userErrors: Array<SubscriptionBillingCycleUserError>;
};

export type SubscriptionBillingCycleEditedContract = SubscriptionContractBase & {
  app?: Maybe<App>;
  appAdminUrl?: Maybe<Scalars['URL']['output']>;
  billingCycles: SubscriptionBillingCycleConnection;
  createdAt: Scalars['DateTime']['output'];
  currencyCode: CurrencyCode;
  customAttributes: Array<Attribute>;
  customer?: Maybe<Customer>;
  customerPaymentMethod?: Maybe<CustomerPaymentMethod>;
  deliveryMethod?: Maybe<SubscriptionDeliveryMethod>;
  deliveryPrice: MoneyV2;
  discounts: SubscriptionManualDiscountConnection;
  /** @deprecated Use `linesCount` instead. */
  lineCount: Scalars['Int']['output'];
  lines: SubscriptionLineConnection;
  linesCount?: Maybe<Count>;
  note?: Maybe<Scalars['String']['output']>;
  orders: OrderConnection;
  updatedAt: Scalars['DateTime']['output'];
};


export type SubscriptionBillingCycleEditedContractBillingCyclesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<SubscriptionBillingCyclesSortKeys>;
};


export type SubscriptionBillingCycleEditedContractCustomerPaymentMethodArgs = {
  showRevoked?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionBillingCycleEditedContractDiscountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionBillingCycleEditedContractLinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionBillingCycleEditedContractOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SubscriptionBillingCycleEditsDeletePayload = {
  billingCycles?: Maybe<Array<SubscriptionBillingCycle>>;
  userErrors: Array<SubscriptionBillingCycleUserError>;
};

export const SubscriptionBillingCycleErrorCode = {
  BillingDateSetOnSkipped: 'BILLING_DATE_SET_ON_SKIPPED',
  CycleIndexOutOfRange: 'CYCLE_INDEX_OUT_OF_RANGE',
  CycleNotFound: 'CYCLE_NOT_FOUND',
  CycleStartDateOutOfRange: 'CYCLE_START_DATE_OUT_OF_RANGE',
  EmptyBillingCycleEditScheduleInput: 'EMPTY_BILLING_CYCLE_EDIT_SCHEDULE_INPUT',
  IncompleteBillingAttempts: 'INCOMPLETE_BILLING_ATTEMPTS',
  Invalid: 'INVALID',
  InvalidCycleIndex: 'INVALID_CYCLE_INDEX',
  InvalidDate: 'INVALID_DATE',
  NoCycleEdits: 'NO_CYCLE_EDITS',
  OutOfBounds: 'OUT_OF_BOUNDS',
  UpcomingCycleLimitExceeded: 'UPCOMING_CYCLE_LIMIT_EXCEEDED'
} as const;

export type SubscriptionBillingCycleErrorCode = typeof SubscriptionBillingCycleErrorCode[keyof typeof SubscriptionBillingCycleErrorCode];
export type SubscriptionBillingCycleInput = {
  contractId: Scalars['ID']['input'];
  selector: SubscriptionBillingCycleSelector;
};

export type SubscriptionBillingCycleScheduleEditInput = {
  billingDate?: InputMaybe<Scalars['DateTime']['input']>;
  reason: SubscriptionBillingCycleScheduleEditInputScheduleEditReason;
  skip?: InputMaybe<Scalars['Boolean']['input']>;
};

export const SubscriptionBillingCycleScheduleEditInputScheduleEditReason = {
  BuyerInitiated: 'BUYER_INITIATED',
  DevInitiated: 'DEV_INITIATED',
  MerchantInitiated: 'MERCHANT_INITIATED'
} as const;

export type SubscriptionBillingCycleScheduleEditInputScheduleEditReason = typeof SubscriptionBillingCycleScheduleEditInputScheduleEditReason[keyof typeof SubscriptionBillingCycleScheduleEditInputScheduleEditReason];
export type SubscriptionBillingCycleScheduleEditPayload = {
  billingCycle?: Maybe<SubscriptionBillingCycle>;
  userErrors: Array<SubscriptionBillingCycleUserError>;
};

export type SubscriptionBillingCycleSelector = {
  date?: InputMaybe<Scalars['DateTime']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
};

export type SubscriptionBillingCycleSkipPayload = {
  billingCycle?: Maybe<SubscriptionBillingCycle>;
  userErrors: Array<SubscriptionBillingCycleSkipUserError>;
};

export type SubscriptionBillingCycleSkipUserError = DisplayableError & {
  code?: Maybe<SubscriptionBillingCycleSkipUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const SubscriptionBillingCycleSkipUserErrorCode = {
  Invalid: 'INVALID'
} as const;

export type SubscriptionBillingCycleSkipUserErrorCode = typeof SubscriptionBillingCycleSkipUserErrorCode[keyof typeof SubscriptionBillingCycleSkipUserErrorCode];
export type SubscriptionBillingCycleUnskipPayload = {
  billingCycle?: Maybe<SubscriptionBillingCycle>;
  userErrors: Array<SubscriptionBillingCycleUnskipUserError>;
};

export type SubscriptionBillingCycleUnskipUserError = DisplayableError & {
  code?: Maybe<SubscriptionBillingCycleUnskipUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const SubscriptionBillingCycleUnskipUserErrorCode = {
  Invalid: 'INVALID'
} as const;

export type SubscriptionBillingCycleUnskipUserErrorCode = typeof SubscriptionBillingCycleUnskipUserErrorCode[keyof typeof SubscriptionBillingCycleUnskipUserErrorCode];
export type SubscriptionBillingCycleUserError = DisplayableError & {
  code?: Maybe<SubscriptionBillingCycleErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type SubscriptionBillingCyclesDateRangeSelector = {
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
};

export type SubscriptionBillingCyclesIndexRangeSelector = {
  endIndex: Scalars['Int']['input'];
  startIndex: Scalars['Int']['input'];
};

export const SubscriptionBillingCyclesSortKeys = {
  CycleIndex: 'CYCLE_INDEX',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type SubscriptionBillingCyclesSortKeys = typeof SubscriptionBillingCyclesSortKeys[keyof typeof SubscriptionBillingCyclesSortKeys];
export const SubscriptionBillingCyclesTargetSelection = {
  All: 'ALL'
} as const;

export type SubscriptionBillingCyclesTargetSelection = typeof SubscriptionBillingCyclesTargetSelection[keyof typeof SubscriptionBillingCyclesTargetSelection];
export type SubscriptionBillingPolicy = {
  anchors: Array<SellingPlanAnchor>;
  interval: SellingPlanInterval;
  intervalCount: Scalars['Int']['output'];
  maxCycles?: Maybe<Scalars['Int']['output']>;
  minCycles?: Maybe<Scalars['Int']['output']>;
};

export type SubscriptionBillingPolicyInput = {
  anchors?: InputMaybe<Array<SellingPlanAnchorInput>>;
  interval: SellingPlanInterval;
  intervalCount: Scalars['Int']['input'];
  maxCycles?: InputMaybe<Scalars['Int']['input']>;
  minCycles?: InputMaybe<Scalars['Int']['input']>;
};

export type SubscriptionContract = Node & SubscriptionContractBase & {
  app?: Maybe<App>;
  appAdminUrl?: Maybe<Scalars['URL']['output']>;
  billingAttempts: SubscriptionBillingAttemptConnection;
  billingPolicy: SubscriptionBillingPolicy;
  createdAt: Scalars['DateTime']['output'];
  currencyCode: CurrencyCode;
  customAttributes: Array<Attribute>;
  customer?: Maybe<Customer>;
  customerPaymentMethod?: Maybe<CustomerPaymentMethod>;
  deliveryMethod?: Maybe<SubscriptionDeliveryMethod>;
  deliveryPolicy: SubscriptionDeliveryPolicy;
  deliveryPrice: MoneyV2;
  discounts: SubscriptionManualDiscountConnection;
  id: Scalars['ID']['output'];
  lastBillingAttemptErrorType?: Maybe<SubscriptionContractLastBillingErrorType>;
  lastPaymentStatus?: Maybe<SubscriptionContractLastPaymentStatus>;
  /** @deprecated Use `linesCount` instead. */
  lineCount: Scalars['Int']['output'];
  lines: SubscriptionLineConnection;
  linesCount?: Maybe<Count>;
  nextBillingDate?: Maybe<Scalars['DateTime']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  orders: OrderConnection;
  originOrder?: Maybe<Order>;
  revisionId: Scalars['UnsignedInt64']['output'];
  status: SubscriptionContractSubscriptionStatus;
  updatedAt: Scalars['DateTime']['output'];
};


export type SubscriptionContractBillingAttemptsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionContractCustomerPaymentMethodArgs = {
  showRevoked?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionContractDiscountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionContractLinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionContractOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SubscriptionContractActivatePayload = {
  contract?: Maybe<SubscriptionContract>;
  userErrors: Array<SubscriptionContractStatusUpdateUserError>;
};

export type SubscriptionContractAtomicCreateInput = {
  contract: SubscriptionDraftInput;
  currencyCode: CurrencyCode;
  customerId: Scalars['ID']['input'];
  discountCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  lines: Array<SubscriptionAtomicLineInput>;
  nextBillingDate: Scalars['DateTime']['input'];
};

export type SubscriptionContractAtomicCreatePayload = {
  contract?: Maybe<SubscriptionContract>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionContractBase = {
  app?: Maybe<App>;
  appAdminUrl?: Maybe<Scalars['URL']['output']>;
  currencyCode: CurrencyCode;
  customAttributes: Array<Attribute>;
  customer?: Maybe<Customer>;
  customerPaymentMethod?: Maybe<CustomerPaymentMethod>;
  deliveryMethod?: Maybe<SubscriptionDeliveryMethod>;
  deliveryPrice: MoneyV2;
  discounts: SubscriptionManualDiscountConnection;
  /** @deprecated Use `linesCount` instead. */
  lineCount: Scalars['Int']['output'];
  lines: SubscriptionLineConnection;
  linesCount?: Maybe<Count>;
  note?: Maybe<Scalars['String']['output']>;
  orders: OrderConnection;
  updatedAt: Scalars['DateTime']['output'];
};


export type SubscriptionContractBaseCustomerPaymentMethodArgs = {
  showRevoked?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionContractBaseDiscountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionContractBaseLinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionContractBaseOrdersArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SubscriptionContractCancelPayload = {
  contract?: Maybe<SubscriptionContract>;
  userErrors: Array<SubscriptionContractStatusUpdateUserError>;
};

export type SubscriptionContractConnection = {
  edges: Array<SubscriptionContractEdge>;
  nodes: Array<SubscriptionContract>;
  pageInfo: PageInfo;
};

export type SubscriptionContractCreateInput = {
  contract: SubscriptionDraftInput;
  currencyCode: CurrencyCode;
  customerId: Scalars['ID']['input'];
  nextBillingDate: Scalars['DateTime']['input'];
};

export type SubscriptionContractCreatePayload = {
  draft?: Maybe<SubscriptionDraft>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionContractEdge = {
  cursor: Scalars['String']['output'];
  node: SubscriptionContract;
};

export const SubscriptionContractErrorCode = {
  Invalid: 'INVALID'
} as const;

export type SubscriptionContractErrorCode = typeof SubscriptionContractErrorCode[keyof typeof SubscriptionContractErrorCode];
export type SubscriptionContractExpirePayload = {
  contract?: Maybe<SubscriptionContract>;
  userErrors: Array<SubscriptionContractStatusUpdateUserError>;
};

export type SubscriptionContractFailPayload = {
  contract?: Maybe<SubscriptionContract>;
  userErrors: Array<SubscriptionContractStatusUpdateUserError>;
};

export const SubscriptionContractLastBillingErrorType = {
  CustomerError: 'CUSTOMER_ERROR',
  InventoryError: 'INVENTORY_ERROR',
  Other: 'OTHER',
  PaymentError: 'PAYMENT_ERROR'
} as const;

export type SubscriptionContractLastBillingErrorType = typeof SubscriptionContractLastBillingErrorType[keyof typeof SubscriptionContractLastBillingErrorType];
export const SubscriptionContractLastPaymentStatus = {
  Failed: 'FAILED',
  Succeeded: 'SUCCEEDED'
} as const;

export type SubscriptionContractLastPaymentStatus = typeof SubscriptionContractLastPaymentStatus[keyof typeof SubscriptionContractLastPaymentStatus];
export type SubscriptionContractPausePayload = {
  contract?: Maybe<SubscriptionContract>;
  userErrors: Array<SubscriptionContractStatusUpdateUserError>;
};

export type SubscriptionContractProductChangeInput = {
  currentPrice?: InputMaybe<Scalars['Decimal']['input']>;
  productVariantId?: InputMaybe<Scalars['ID']['input']>;
};

export type SubscriptionContractProductChangePayload = {
  contract?: Maybe<SubscriptionContract>;
  lineUpdated?: Maybe<SubscriptionLine>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionContractSetNextBillingDatePayload = {
  contract?: Maybe<SubscriptionContract>;
  userErrors: Array<SubscriptionContractUserError>;
};

export const SubscriptionContractStatusUpdateErrorCode = {
  ContractTerminated: 'CONTRACT_TERMINATED',
  Invalid: 'INVALID'
} as const;

export type SubscriptionContractStatusUpdateErrorCode = typeof SubscriptionContractStatusUpdateErrorCode[keyof typeof SubscriptionContractStatusUpdateErrorCode];
export type SubscriptionContractStatusUpdateUserError = DisplayableError & {
  code?: Maybe<SubscriptionContractStatusUpdateErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const SubscriptionContractSubscriptionStatus = {
  Active: 'ACTIVE',
  Cancelled: 'CANCELLED',
  Expired: 'EXPIRED',
  Failed: 'FAILED',
  Paused: 'PAUSED'
} as const;

export type SubscriptionContractSubscriptionStatus = typeof SubscriptionContractSubscriptionStatus[keyof typeof SubscriptionContractSubscriptionStatus];
export type SubscriptionContractUpdatePayload = {
  draft?: Maybe<SubscriptionDraft>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionContractUserError = DisplayableError & {
  code?: Maybe<SubscriptionContractErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type SubscriptionCyclePriceAdjustment = {
  adjustmentType: SellingPlanPricingPolicyAdjustmentType;
  adjustmentValue: SellingPlanPricingPolicyAdjustmentValue;
  afterCycle: Scalars['Int']['output'];
  computedPrice: MoneyV2;
};

export type SubscriptionDeliveryMethod = SubscriptionDeliveryMethodLocalDelivery | SubscriptionDeliveryMethodPickup | SubscriptionDeliveryMethodShipping;

export type SubscriptionDeliveryMethodInput = {
  localDelivery?: InputMaybe<SubscriptionDeliveryMethodLocalDeliveryInput>;
  pickup?: InputMaybe<SubscriptionDeliveryMethodPickupInput>;
  shipping?: InputMaybe<SubscriptionDeliveryMethodShippingInput>;
};

export type SubscriptionDeliveryMethodLocalDelivery = {
  address: SubscriptionMailingAddress;
  localDeliveryOption: SubscriptionDeliveryMethodLocalDeliveryOption;
};

export type SubscriptionDeliveryMethodLocalDeliveryInput = {
  address?: InputMaybe<MailingAddressInput>;
  localDeliveryOption?: InputMaybe<SubscriptionDeliveryMethodLocalDeliveryOptionInput>;
};

export type SubscriptionDeliveryMethodLocalDeliveryOption = {
  code?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  instructions?: Maybe<Scalars['String']['output']>;
  phone: Scalars['String']['output'];
  presentmentTitle?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};

export type SubscriptionDeliveryMethodLocalDeliveryOptionInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  instructions?: InputMaybe<Scalars['String']['input']>;
  phone: Scalars['String']['input'];
  presentmentTitle?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type SubscriptionDeliveryMethodPickup = {
  pickupOption: SubscriptionDeliveryMethodPickupOption;
};

export type SubscriptionDeliveryMethodPickupInput = {
  pickupOption?: InputMaybe<SubscriptionDeliveryMethodPickupOptionInput>;
};

export type SubscriptionDeliveryMethodPickupOption = {
  code?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  location: Location;
  presentmentTitle?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};

export type SubscriptionDeliveryMethodPickupOptionInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  locationId: Scalars['ID']['input'];
  presentmentTitle?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type SubscriptionDeliveryMethodShipping = {
  address: SubscriptionMailingAddress;
  shippingOption: SubscriptionDeliveryMethodShippingOption;
};

export type SubscriptionDeliveryMethodShippingInput = {
  address?: InputMaybe<MailingAddressInput>;
  shippingOption?: InputMaybe<SubscriptionDeliveryMethodShippingOptionInput>;
};

export type SubscriptionDeliveryMethodShippingOption = {
  /** @deprecated This field has never been implemented. */
  carrierService?: Maybe<DeliveryCarrierService>;
  code?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  presentmentTitle?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};

export type SubscriptionDeliveryMethodShippingOptionInput = {
  carrierServiceId?: InputMaybe<Scalars['ID']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  presentmentTitle?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type SubscriptionDeliveryOption = SubscriptionLocalDeliveryOption | SubscriptionPickupOption | SubscriptionShippingOption;

export type SubscriptionDeliveryOptionResult = SubscriptionDeliveryOptionResultFailure | SubscriptionDeliveryOptionResultSuccess;

export type SubscriptionDeliveryOptionResultFailure = {
  message?: Maybe<Scalars['String']['output']>;
};

export type SubscriptionDeliveryOptionResultSuccess = {
  deliveryOptions: Array<SubscriptionDeliveryOption>;
};

export type SubscriptionDeliveryPolicy = {
  anchors: Array<SellingPlanAnchor>;
  interval: SellingPlanInterval;
  intervalCount: Scalars['Int']['output'];
};

export type SubscriptionDeliveryPolicyInput = {
  anchors?: InputMaybe<Array<SellingPlanAnchorInput>>;
  interval: SellingPlanInterval;
  intervalCount: Scalars['Int']['input'];
};

export type SubscriptionDiscount = SubscriptionAppliedCodeDiscount | SubscriptionManualDiscount;

export type SubscriptionDiscountAllocation = {
  amount: MoneyV2;
  discount: SubscriptionDiscount;
};

export type SubscriptionDiscountConnection = {
  edges: Array<SubscriptionDiscountEdge>;
  nodes: Array<SubscriptionDiscount>;
  pageInfo: PageInfo;
};

export type SubscriptionDiscountEdge = {
  cursor: Scalars['String']['output'];
  node: SubscriptionDiscount;
};

export type SubscriptionDiscountEntitledLines = {
  all: Scalars['Boolean']['output'];
  lines: SubscriptionLineConnection;
};


export type SubscriptionDiscountEntitledLinesLinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SubscriptionDiscountFixedAmountValue = {
  amount: MoneyV2;
  appliesOnEachItem: Scalars['Boolean']['output'];
};

export type SubscriptionDiscountPercentageValue = {
  percentage: Scalars['Int']['output'];
};

export const SubscriptionDiscountRejectionReason = {
  CurrentlyInactive: 'CURRENTLY_INACTIVE',
  CustomerNotEligible: 'CUSTOMER_NOT_ELIGIBLE',
  CustomerUsageLimitReached: 'CUSTOMER_USAGE_LIMIT_REACHED',
  IncompatiblePurchaseType: 'INCOMPATIBLE_PURCHASE_TYPE',
  InternalError: 'INTERNAL_ERROR',
  NotFound: 'NOT_FOUND',
  NoEntitledLineItems: 'NO_ENTITLED_LINE_ITEMS',
  NoEntitledShippingLines: 'NO_ENTITLED_SHIPPING_LINES',
  PurchaseNotInRange: 'PURCHASE_NOT_IN_RANGE',
  QuantityNotInRange: 'QUANTITY_NOT_IN_RANGE',
  UsageLimitReached: 'USAGE_LIMIT_REACHED'
} as const;

export type SubscriptionDiscountRejectionReason = typeof SubscriptionDiscountRejectionReason[keyof typeof SubscriptionDiscountRejectionReason];
export type SubscriptionDiscountValue = SubscriptionDiscountFixedAmountValue | SubscriptionDiscountPercentageValue;

export type SubscriptionDraft = Node & {
  billingCycle?: Maybe<SubscriptionBillingCycle>;
  billingPolicy: SubscriptionBillingPolicy;
  concatenatedBillingCycles: SubscriptionBillingCycleConnection;
  currencyCode: CurrencyCode;
  customAttributes: Array<Attribute>;
  customer: Customer;
  customerPaymentMethod?: Maybe<CustomerPaymentMethod>;
  deliveryMethod?: Maybe<SubscriptionDeliveryMethod>;
  deliveryOptions?: Maybe<SubscriptionDeliveryOptionResult>;
  deliveryPolicy: SubscriptionDeliveryPolicy;
  deliveryPrice?: Maybe<MoneyV2>;
  discounts: SubscriptionDiscountConnection;
  discountsAdded: SubscriptionDiscountConnection;
  discountsRemoved: SubscriptionDiscountConnection;
  discountsUpdated: SubscriptionDiscountConnection;
  id: Scalars['ID']['output'];
  lines: SubscriptionLineConnection;
  linesAdded: SubscriptionLineConnection;
  linesRemoved: SubscriptionLineConnection;
  nextBillingDate?: Maybe<Scalars['DateTime']['output']>;
  note?: Maybe<Scalars['String']['output']>;
  originalContract?: Maybe<SubscriptionContract>;
  /** @deprecated Use `deliveryOptions` instead. */
  shippingOptions?: Maybe<SubscriptionShippingOptionResult>;
  status?: Maybe<SubscriptionContractSubscriptionStatus>;
};


export type SubscriptionDraftConcatenatedBillingCyclesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<SubscriptionBillingCyclesSortKeys>;
};


export type SubscriptionDraftCustomerPaymentMethodArgs = {
  showRevoked?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionDraftDeliveryOptionsArgs = {
  deliveryAddress?: InputMaybe<MailingAddressInput>;
};


export type SubscriptionDraftDiscountsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionDraftDiscountsAddedArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionDraftDiscountsRemovedArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionDraftDiscountsUpdatedArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionDraftLinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionDraftLinesAddedArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionDraftLinesRemovedArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SubscriptionDraftShippingOptionsArgs = {
  deliveryAddress?: InputMaybe<MailingAddressInput>;
};

export type SubscriptionDraftCommitPayload = {
  contract?: Maybe<SubscriptionContract>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionDraftDiscountAddPayload = {
  discountAdded?: Maybe<SubscriptionManualDiscount>;
  draft?: Maybe<SubscriptionDraft>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionDraftDiscountCodeApplyPayload = {
  appliedDiscount?: Maybe<SubscriptionAppliedCodeDiscount>;
  draft?: Maybe<SubscriptionDraft>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionDraftDiscountRemovePayload = {
  discountRemoved?: Maybe<SubscriptionDiscount>;
  draft?: Maybe<SubscriptionDraft>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionDraftDiscountUpdatePayload = {
  discountUpdated?: Maybe<SubscriptionManualDiscount>;
  draft?: Maybe<SubscriptionDraft>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export const SubscriptionDraftErrorCode = {
  AlreadyRemoved: 'ALREADY_REMOVED',
  BillingCycleAbsent: 'BILLING_CYCLE_ABSENT',
  BillingCycleContractDraftBillingPolicyInvalid: 'BILLING_CYCLE_CONTRACT_DRAFT_BILLING_POLICY_INVALID',
  BillingCycleContractDraftDeliveryPolicyInvalid: 'BILLING_CYCLE_CONTRACT_DRAFT_DELIVERY_POLICY_INVALID',
  BillingCyclePresent: 'BILLING_CYCLE_PRESENT',
  Blank: 'BLANK',
  Committed: 'COMMITTED',
  ConcatenationBillingCycleContractDraftRequired: 'CONCATENATION_BILLING_CYCLE_CONTRACT_DRAFT_REQUIRED',
  CurrencyNotEnabled: 'CURRENCY_NOT_ENABLED',
  CustomerDoesNotExist: 'CUSTOMER_DOES_NOT_EXIST',
  CustomerMismatch: 'CUSTOMER_MISMATCH',
  CustomerRedacted: 'CUSTOMER_REDACTED',
  CycleDiscountsUniqueAfterCycle: 'CYCLE_DISCOUNTS_UNIQUE_AFTER_CYCLE',
  CycleIndexOutOfRange: 'CYCLE_INDEX_OUT_OF_RANGE',
  CycleSelectorValidateOneOf: 'CYCLE_SELECTOR_VALIDATE_ONE_OF',
  CycleStartDateOutOfRange: 'CYCLE_START_DATE_OUT_OF_RANGE',
  DeliveryMethodRequired: 'DELIVERY_METHOD_REQUIRED',
  DeliveryMustBeMultipleOfBilling: 'DELIVERY_MUST_BE_MULTIPLE_OF_BILLING',
  DuplicateConcatenatedContracts: 'DUPLICATE_CONCATENATED_CONTRACTS',
  ExceededMaxConcatenatedContracts: 'EXCEEDED_MAX_CONCATENATED_CONTRACTS',
  GreaterThan: 'GREATER_THAN',
  GreaterThanOrEqualTo: 'GREATER_THAN_OR_EQUAL_TO',
  HasFutureEdits: 'HAS_FUTURE_EDITS',
  Invalid: 'INVALID',
  InvalidAdjustmentType: 'INVALID_ADJUSTMENT_TYPE',
  InvalidAdjustmentValue: 'INVALID_ADJUSTMENT_VALUE',
  InvalidBillingDate: 'INVALID_BILLING_DATE',
  InvalidLines: 'INVALID_LINES',
  InvalidNoteLength: 'INVALID_NOTE_LENGTH',
  LessThan: 'LESS_THAN',
  LessThanOrEqualTo: 'LESS_THAN_OR_EQUAL_TO',
  MissingCustomerPaymentMethod: 'MISSING_CUSTOMER_PAYMENT_METHOD',
  MissingLocalDeliveryOptions: 'MISSING_LOCAL_DELIVERY_OPTIONS',
  NotAnInteger: 'NOT_AN_INTEGER',
  NotInRange: 'NOT_IN_RANGE',
  NoEntitledLines: 'NO_ENTITLED_LINES',
  Presence: 'PRESENCE',
  SellingPlanMaxCyclesMustBeGreaterThanMinCycles: 'SELLING_PLAN_MAX_CYCLES_MUST_BE_GREATER_THAN_MIN_CYCLES',
  StaleContract: 'STALE_CONTRACT',
  TooLong: 'TOO_LONG',
  TooShort: 'TOO_SHORT',
  UpcomingCycleLimitExceeded: 'UPCOMING_CYCLE_LIMIT_EXCEEDED'
} as const;

export type SubscriptionDraftErrorCode = typeof SubscriptionDraftErrorCode[keyof typeof SubscriptionDraftErrorCode];
export type SubscriptionDraftFreeShippingDiscountAddPayload = {
  discountAdded?: Maybe<SubscriptionManualDiscount>;
  draft?: Maybe<SubscriptionDraft>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionDraftFreeShippingDiscountUpdatePayload = {
  discountUpdated?: Maybe<SubscriptionManualDiscount>;
  draft?: Maybe<SubscriptionDraft>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionDraftInput = {
  billingPolicy?: InputMaybe<SubscriptionBillingPolicyInput>;
  customAttributes?: InputMaybe<Array<AttributeInput>>;
  deliveryMethod?: InputMaybe<SubscriptionDeliveryMethodInput>;
  deliveryPolicy?: InputMaybe<SubscriptionDeliveryPolicyInput>;
  deliveryPrice?: InputMaybe<Scalars['Decimal']['input']>;
  nextBillingDate?: InputMaybe<Scalars['DateTime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  paymentMethodId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<SubscriptionContractSubscriptionStatus>;
};

export type SubscriptionDraftLineAddPayload = {
  draft?: Maybe<SubscriptionDraft>;
  lineAdded?: Maybe<SubscriptionLine>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionDraftLineRemovePayload = {
  discountsUpdated?: Maybe<Array<SubscriptionManualDiscount>>;
  draft?: Maybe<SubscriptionDraft>;
  lineRemoved?: Maybe<SubscriptionLine>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionDraftLineUpdatePayload = {
  draft?: Maybe<SubscriptionDraft>;
  lineUpdated?: Maybe<SubscriptionLine>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionDraftUpdatePayload = {
  draft?: Maybe<SubscriptionDraft>;
  userErrors: Array<SubscriptionDraftUserError>;
};

export type SubscriptionDraftUserError = DisplayableError & {
  code?: Maybe<SubscriptionDraftErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type SubscriptionFreeShippingDiscountInput = {
  recurringCycleLimit?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type SubscriptionLine = {
  concatenatedOriginContract?: Maybe<SubscriptionContract>;
  currentPrice: MoneyV2;
  customAttributes: Array<Attribute>;
  discountAllocations: Array<SubscriptionDiscountAllocation>;
  id: Scalars['ID']['output'];
  lineDiscountedPrice: MoneyV2;
  pricingPolicy?: Maybe<SubscriptionPricingPolicy>;
  productId?: Maybe<Scalars['ID']['output']>;
  quantity: Scalars['Int']['output'];
  requiresShipping: Scalars['Boolean']['output'];
  sellingPlanId?: Maybe<Scalars['ID']['output']>;
  sellingPlanName?: Maybe<Scalars['String']['output']>;
  sku?: Maybe<Scalars['String']['output']>;
  taxable: Scalars['Boolean']['output'];
  title: Scalars['String']['output'];
  variantId?: Maybe<Scalars['ID']['output']>;
  variantImage?: Maybe<Image>;
  variantTitle?: Maybe<Scalars['String']['output']>;
};

export type SubscriptionLineConnection = {
  edges: Array<SubscriptionLineEdge>;
  nodes: Array<SubscriptionLine>;
  pageInfo: PageInfo;
};

export type SubscriptionLineEdge = {
  cursor: Scalars['String']['output'];
  node: SubscriptionLine;
};

export type SubscriptionLineInput = {
  currentPrice: Scalars['Decimal']['input'];
  customAttributes?: InputMaybe<Array<AttributeInput>>;
  pricingPolicy?: InputMaybe<SubscriptionPricingPolicyInput>;
  productVariantId: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
  sellingPlanId?: InputMaybe<Scalars['ID']['input']>;
  sellingPlanName?: InputMaybe<Scalars['String']['input']>;
};

export type SubscriptionLineUpdateInput = {
  currentPrice?: InputMaybe<Scalars['Decimal']['input']>;
  customAttributes?: InputMaybe<Array<AttributeInput>>;
  pricingPolicy?: InputMaybe<SubscriptionPricingPolicyInput>;
  productVariantId?: InputMaybe<Scalars['ID']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  sellingPlanId?: InputMaybe<Scalars['ID']['input']>;
  sellingPlanName?: InputMaybe<Scalars['String']['input']>;
};

export type SubscriptionLocalDeliveryOption = {
  code: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  phoneRequired: Scalars['Boolean']['output'];
  presentmentTitle?: Maybe<Scalars['String']['output']>;
  price?: Maybe<MoneyV2>;
  title: Scalars['String']['output'];
};

export type SubscriptionMailingAddress = {
  address1?: Maybe<Scalars['String']['output']>;
  address2?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  company?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  countryCode?: Maybe<CountryCode>;
  firstName?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  provinceCode?: Maybe<Scalars['String']['output']>;
  zip?: Maybe<Scalars['String']['output']>;
};

export type SubscriptionManualDiscount = {
  entitledLines: SubscriptionDiscountEntitledLines;
  id: Scalars['ID']['output'];
  recurringCycleLimit?: Maybe<Scalars['Int']['output']>;
  rejectionReason?: Maybe<SubscriptionDiscountRejectionReason>;
  targetType: DiscountTargetType;
  title?: Maybe<Scalars['String']['output']>;
  type: DiscountType;
  usageCount: Scalars['Int']['output'];
  value: SubscriptionDiscountValue;
};

export type SubscriptionManualDiscountConnection = {
  edges: Array<SubscriptionManualDiscountEdge>;
  nodes: Array<SubscriptionManualDiscount>;
  pageInfo: PageInfo;
};

export type SubscriptionManualDiscountEdge = {
  cursor: Scalars['String']['output'];
  node: SubscriptionManualDiscount;
};

export type SubscriptionManualDiscountEntitledLinesInput = {
  all?: InputMaybe<Scalars['Boolean']['input']>;
  lines?: InputMaybe<SubscriptionManualDiscountLinesInput>;
};

export type SubscriptionManualDiscountFixedAmountInput = {
  amount?: InputMaybe<Scalars['Float']['input']>;
  appliesOnEachItem?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SubscriptionManualDiscountInput = {
  entitledLines?: InputMaybe<SubscriptionManualDiscountEntitledLinesInput>;
  recurringCycleLimit?: InputMaybe<Scalars['Int']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<SubscriptionManualDiscountValueInput>;
};

export type SubscriptionManualDiscountLinesInput = {
  add?: InputMaybe<Array<Scalars['ID']['input']>>;
  remove?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type SubscriptionManualDiscountValueInput = {
  fixedAmount?: InputMaybe<SubscriptionManualDiscountFixedAmountInput>;
  percentage?: InputMaybe<Scalars['Int']['input']>;
};

export type SubscriptionPickupOption = {
  code: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  location: Location;
  phoneRequired: Scalars['Boolean']['output'];
  pickupTime: Scalars['String']['output'];
  presentmentTitle?: Maybe<Scalars['String']['output']>;
  price?: Maybe<MoneyV2>;
  title: Scalars['String']['output'];
};

export type SubscriptionPricingPolicy = {
  basePrice: MoneyV2;
  cycleDiscounts: Array<SubscriptionCyclePriceAdjustment>;
};

export type SubscriptionPricingPolicyCycleDiscountsInput = {
  adjustmentType: SellingPlanPricingPolicyAdjustmentType;
  adjustmentValue: SellingPlanPricingPolicyValueInput;
  afterCycle: Scalars['Int']['input'];
  computedPrice: Scalars['Decimal']['input'];
};

export type SubscriptionPricingPolicyInput = {
  basePrice: Scalars['Decimal']['input'];
  cycleDiscounts: Array<SubscriptionPricingPolicyCycleDiscountsInput>;
};

export type SubscriptionShippingOption = {
  /** @deprecated This field has never been implemented. */
  carrierService?: Maybe<DeliveryCarrierService>;
  code: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  phoneRequired?: Maybe<Scalars['Boolean']['output']>;
  presentmentTitle?: Maybe<Scalars['String']['output']>;
  price?: Maybe<MoneyV2>;
  title: Scalars['String']['output'];
};

export type SubscriptionShippingOptionResult = SubscriptionShippingOptionResultFailure | SubscriptionShippingOptionResultSuccess;

export type SubscriptionShippingOptionResultFailure = {
  message?: Maybe<Scalars['String']['output']>;
};

export type SubscriptionShippingOptionResultSuccess = {
  shippingOptions: Array<SubscriptionShippingOption>;
};

export type SuggestedOrderTransaction = {
  accountNumber?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use `amountSet` instead. */
  amount: Scalars['Money']['output'];
  amountSet: MoneyBag;
  formattedGateway?: Maybe<Scalars['String']['output']>;
  gateway?: Maybe<Scalars['String']['output']>;
  kind: SuggestedOrderTransactionKind;
  /** @deprecated Use `maximumRefundableSet` instead. */
  maximumRefundable?: Maybe<Scalars['Money']['output']>;
  maximumRefundableSet?: Maybe<MoneyBag>;
  parentTransaction?: Maybe<OrderTransaction>;
  paymentDetails?: Maybe<PaymentDetails>;
};

export const SuggestedOrderTransactionKind = {
  SuggestedRefund: 'SUGGESTED_REFUND'
} as const;

export type SuggestedOrderTransactionKind = typeof SuggestedOrderTransactionKind[keyof typeof SuggestedOrderTransactionKind];
export type SuggestedRefund = {
  /** @deprecated Use `amountSet` instead. */
  amount: Scalars['Money']['output'];
  amountSet: MoneyBag;
  discountedSubtotalSet: MoneyBag;
  /** @deprecated Use `maximumRefundableSet` instead. */
  maximumRefundable: Scalars['Money']['output'];
  maximumRefundableSet: MoneyBag;
  refundDuties: Array<RefundDuty>;
  refundLineItems: Array<RefundLineItem>;
  shipping: ShippingRefund;
  /** @deprecated Use `subtotalSet` instead. */
  subtotal: Scalars['Money']['output'];
  subtotalSet: MoneyBag;
  suggestedTransactions: Array<SuggestedOrderTransaction>;
  totalCartDiscountAmountSet: MoneyBag;
  totalDutiesSet: MoneyBag;
  totalTaxSet: MoneyBag;
  /** @deprecated Use `totalTaxSet` instead. */
  totalTaxes: Scalars['Money']['output'];
};

export type SuggestedReturnRefund = {
  amount: MoneyBag;
  discountedSubtotal: MoneyBag;
  maximumRefundable: MoneyBag;
  refundDuties: Array<RefundDuty>;
  shipping: ShippingRefund;
  subtotal: MoneyBag;
  suggestedTransactions: Array<SuggestedOrderTransaction>;
  totalCartDiscountAmount: MoneyBag;
  totalDuties: MoneyBag;
  totalTax: MoneyBag;
};

export type TagsAddPayload = {
  node?: Maybe<Node>;
  userErrors: Array<UserError>;
};

export type TagsRemovePayload = {
  node?: Maybe<Node>;
  userErrors: Array<UserError>;
};

export type TaxAppConfiguration = {
  state: TaxPartnerState;
};

export type TaxAppConfigurePayload = {
  taxAppConfiguration?: Maybe<TaxAppConfiguration>;
  userErrors: Array<TaxAppConfigureUserError>;
};

export type TaxAppConfigureUserError = DisplayableError & {
  code?: Maybe<TaxAppConfigureUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const TaxAppConfigureUserErrorCode = {
  TaxPartnerAlreadyActive: 'TAX_PARTNER_ALREADY_ACTIVE',
  TaxPartnerNotFound: 'TAX_PARTNER_NOT_FOUND',
  TaxPartnerStateUpdateFailed: 'TAX_PARTNER_STATE_UPDATE_FAILED'
} as const;

export type TaxAppConfigureUserErrorCode = typeof TaxAppConfigureUserErrorCode[keyof typeof TaxAppConfigureUserErrorCode];
export const TaxExemption = {
  CaBcCommercialFisheryExemption: 'CA_BC_COMMERCIAL_FISHERY_EXEMPTION',
  CaBcContractorExemption: 'CA_BC_CONTRACTOR_EXEMPTION',
  CaBcProductionAndMachineryExemption: 'CA_BC_PRODUCTION_AND_MACHINERY_EXEMPTION',
  CaBcResellerExemption: 'CA_BC_RESELLER_EXEMPTION',
  CaBcSubContractorExemption: 'CA_BC_SUB_CONTRACTOR_EXEMPTION',
  CaDiplomatExemption: 'CA_DIPLOMAT_EXEMPTION',
  CaMbCommercialFisheryExemption: 'CA_MB_COMMERCIAL_FISHERY_EXEMPTION',
  CaMbFarmerExemption: 'CA_MB_FARMER_EXEMPTION',
  CaMbResellerExemption: 'CA_MB_RESELLER_EXEMPTION',
  CaNsCommercialFisheryExemption: 'CA_NS_COMMERCIAL_FISHERY_EXEMPTION',
  CaNsFarmerExemption: 'CA_NS_FARMER_EXEMPTION',
  CaOnPurchaseExemption: 'CA_ON_PURCHASE_EXEMPTION',
  CaPeCommercialFisheryExemption: 'CA_PE_COMMERCIAL_FISHERY_EXEMPTION',
  CaSkCommercialFisheryExemption: 'CA_SK_COMMERCIAL_FISHERY_EXEMPTION',
  CaSkContractorExemption: 'CA_SK_CONTRACTOR_EXEMPTION',
  CaSkFarmerExemption: 'CA_SK_FARMER_EXEMPTION',
  CaSkProductionAndMachineryExemption: 'CA_SK_PRODUCTION_AND_MACHINERY_EXEMPTION',
  CaSkResellerExemption: 'CA_SK_RESELLER_EXEMPTION',
  CaSkSubContractorExemption: 'CA_SK_SUB_CONTRACTOR_EXEMPTION',
  CaStatusCardExemption: 'CA_STATUS_CARD_EXEMPTION',
  EuReverseChargeExemptionRule: 'EU_REVERSE_CHARGE_EXEMPTION_RULE',
  UsAkResellerExemption: 'US_AK_RESELLER_EXEMPTION',
  UsAlResellerExemption: 'US_AL_RESELLER_EXEMPTION',
  UsArResellerExemption: 'US_AR_RESELLER_EXEMPTION',
  UsAzResellerExemption: 'US_AZ_RESELLER_EXEMPTION',
  UsCaResellerExemption: 'US_CA_RESELLER_EXEMPTION',
  UsCoResellerExemption: 'US_CO_RESELLER_EXEMPTION',
  UsCtResellerExemption: 'US_CT_RESELLER_EXEMPTION',
  UsDcResellerExemption: 'US_DC_RESELLER_EXEMPTION',
  UsDeResellerExemption: 'US_DE_RESELLER_EXEMPTION',
  UsFlResellerExemption: 'US_FL_RESELLER_EXEMPTION',
  UsGaResellerExemption: 'US_GA_RESELLER_EXEMPTION',
  UsHiResellerExemption: 'US_HI_RESELLER_EXEMPTION',
  UsIaResellerExemption: 'US_IA_RESELLER_EXEMPTION',
  UsIdResellerExemption: 'US_ID_RESELLER_EXEMPTION',
  UsIlResellerExemption: 'US_IL_RESELLER_EXEMPTION',
  UsInResellerExemption: 'US_IN_RESELLER_EXEMPTION',
  UsKsResellerExemption: 'US_KS_RESELLER_EXEMPTION',
  UsKyResellerExemption: 'US_KY_RESELLER_EXEMPTION',
  UsLaResellerExemption: 'US_LA_RESELLER_EXEMPTION',
  UsMaResellerExemption: 'US_MA_RESELLER_EXEMPTION',
  UsMdResellerExemption: 'US_MD_RESELLER_EXEMPTION',
  UsMeResellerExemption: 'US_ME_RESELLER_EXEMPTION',
  UsMiResellerExemption: 'US_MI_RESELLER_EXEMPTION',
  UsMnResellerExemption: 'US_MN_RESELLER_EXEMPTION',
  UsMoResellerExemption: 'US_MO_RESELLER_EXEMPTION',
  UsMsResellerExemption: 'US_MS_RESELLER_EXEMPTION',
  UsMtResellerExemption: 'US_MT_RESELLER_EXEMPTION',
  UsNcResellerExemption: 'US_NC_RESELLER_EXEMPTION',
  UsNdResellerExemption: 'US_ND_RESELLER_EXEMPTION',
  UsNeResellerExemption: 'US_NE_RESELLER_EXEMPTION',
  UsNhResellerExemption: 'US_NH_RESELLER_EXEMPTION',
  UsNjResellerExemption: 'US_NJ_RESELLER_EXEMPTION',
  UsNmResellerExemption: 'US_NM_RESELLER_EXEMPTION',
  UsNvResellerExemption: 'US_NV_RESELLER_EXEMPTION',
  UsNyResellerExemption: 'US_NY_RESELLER_EXEMPTION',
  UsOhResellerExemption: 'US_OH_RESELLER_EXEMPTION',
  UsOkResellerExemption: 'US_OK_RESELLER_EXEMPTION',
  UsOrResellerExemption: 'US_OR_RESELLER_EXEMPTION',
  UsPaResellerExemption: 'US_PA_RESELLER_EXEMPTION',
  UsRiResellerExemption: 'US_RI_RESELLER_EXEMPTION',
  UsScResellerExemption: 'US_SC_RESELLER_EXEMPTION',
  UsSdResellerExemption: 'US_SD_RESELLER_EXEMPTION',
  UsTnResellerExemption: 'US_TN_RESELLER_EXEMPTION',
  UsTxResellerExemption: 'US_TX_RESELLER_EXEMPTION',
  UsUtResellerExemption: 'US_UT_RESELLER_EXEMPTION',
  UsVaResellerExemption: 'US_VA_RESELLER_EXEMPTION',
  UsVtResellerExemption: 'US_VT_RESELLER_EXEMPTION',
  UsWaResellerExemption: 'US_WA_RESELLER_EXEMPTION',
  UsWiResellerExemption: 'US_WI_RESELLER_EXEMPTION',
  UsWvResellerExemption: 'US_WV_RESELLER_EXEMPTION',
  UsWyResellerExemption: 'US_WY_RESELLER_EXEMPTION'
} as const;

export type TaxExemption = typeof TaxExemption[keyof typeof TaxExemption];
export type TaxLine = {
  channelLiable?: Maybe<Scalars['Boolean']['output']>;
  /** @deprecated Use `priceSet` instead. */
  price: Scalars['Money']['output'];
  priceSet: MoneyBag;
  rate?: Maybe<Scalars['Float']['output']>;
  ratePercentage?: Maybe<Scalars['Float']['output']>;
  source?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
};

export const TaxPartnerState = {
  Active: 'ACTIVE',
  Pending: 'PENDING',
  Ready: 'READY'
} as const;

export type TaxPartnerState = typeof TaxPartnerState[keyof typeof TaxPartnerState];
export type Taxonomy = {
  categories: TaxonomyCategoryConnection;
};


export type TaxonomyCategoriesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  childrenOf?: InputMaybe<Scalars['ID']['input']>;
  descendantsOf?: InputMaybe<Scalars['ID']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  siblingsOf?: InputMaybe<Scalars['ID']['input']>;
};

export type TaxonomyAttribute = Node & {
  id: Scalars['ID']['output'];
};

export type TaxonomyCategory = Node & {
  ancestorIds: Array<Scalars['ID']['output']>;
  attributes: TaxonomyCategoryAttributeConnection;
  childrenIds: Array<Scalars['ID']['output']>;
  fullName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isArchived: Scalars['Boolean']['output'];
  isLeaf: Scalars['Boolean']['output'];
  isRoot: Scalars['Boolean']['output'];
  level: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  parentId?: Maybe<Scalars['ID']['output']>;
};


export type TaxonomyCategoryAttributesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type TaxonomyCategoryAttribute = TaxonomyAttribute | TaxonomyChoiceListAttribute | TaxonomyMeasurementAttribute;

export type TaxonomyCategoryAttributeConnection = {
  edges: Array<TaxonomyCategoryAttributeEdge>;
  nodes: Array<TaxonomyCategoryAttribute>;
  pageInfo: PageInfo;
};

export type TaxonomyCategoryAttributeEdge = {
  cursor: Scalars['String']['output'];
  node: TaxonomyCategoryAttribute;
};

export type TaxonomyCategoryConnection = {
  edges: Array<TaxonomyCategoryEdge>;
  nodes: Array<TaxonomyCategory>;
  pageInfo: PageInfo;
};

export type TaxonomyCategoryEdge = {
  cursor: Scalars['String']['output'];
  node: TaxonomyCategory;
};

export type TaxonomyChoiceListAttribute = Node & {
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  values: TaxonomyValueConnection;
};


export type TaxonomyChoiceListAttributeValuesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type TaxonomyMeasurementAttribute = Node & {
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  options: Array<Attribute>;
};

export type TaxonomyValue = Node & {
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type TaxonomyValueConnection = {
  edges: Array<TaxonomyValueEdge>;
  nodes: Array<TaxonomyValue>;
  pageInfo: PageInfo;
};

export type TaxonomyValueEdge = {
  cursor: Scalars['String']['output'];
  node: TaxonomyValue;
};

export type TenderTransaction = Node & {
  amount: MoneyV2;
  id: Scalars['ID']['output'];
  order?: Maybe<Order>;
  paymentMethod?: Maybe<Scalars['String']['output']>;
  processedAt?: Maybe<Scalars['DateTime']['output']>;
  remoteReference?: Maybe<Scalars['String']['output']>;
  test: Scalars['Boolean']['output'];
  transactionDetails?: Maybe<TenderTransactionDetails>;
  user?: Maybe<StaffMember>;
};

export type TenderTransactionConnection = {
  edges: Array<TenderTransactionEdge>;
  nodes: Array<TenderTransaction>;
  pageInfo: PageInfo;
};

export type TenderTransactionCreditCardDetails = {
  creditCardCompany?: Maybe<Scalars['String']['output']>;
  creditCardNumber?: Maybe<Scalars['String']['output']>;
};

export type TenderTransactionDetails = TenderTransactionCreditCardDetails;

export type TenderTransactionEdge = {
  cursor: Scalars['String']['output'];
  node: TenderTransaction;
};

export type ThemeCreatePayload = {
  theme?: Maybe<OnlineStoreTheme>;
  userErrors: Array<ThemeCreateUserError>;
};

export type ThemeCreateUserError = DisplayableError & {
  code?: Maybe<ThemeCreateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ThemeCreateUserErrorCode = {
  InvalidThemeRoleForThemeCreation: 'INVALID_THEME_ROLE_FOR_THEME_CREATION',
  InvalidZip: 'INVALID_ZIP',
  ThemeCreationNotAllowedForThemeLimitedPlan: 'THEME_CREATION_NOT_ALLOWED_FOR_THEME_LIMITED_PLAN',
  ZipIsEmpty: 'ZIP_IS_EMPTY',
  ZipTooLarge: 'ZIP_TOO_LARGE'
} as const;

export type ThemeCreateUserErrorCode = typeof ThemeCreateUserErrorCode[keyof typeof ThemeCreateUserErrorCode];
export type ThemeDeletePayload = {
  deletedThemeId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<ThemeDeleteUserError>;
};

export type ThemeDeleteUserError = DisplayableError & {
  code?: Maybe<ThemeDeleteUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ThemeDeleteUserErrorCode = {
  NotFound: 'NOT_FOUND'
} as const;

export type ThemeDeleteUserErrorCode = typeof ThemeDeleteUserErrorCode[keyof typeof ThemeDeleteUserErrorCode];
export type ThemeFilesCopyFileInput = {
  dstFilename: Scalars['String']['input'];
  srcFilename: Scalars['String']['input'];
};

export type ThemeFilesCopyPayload = {
  copiedThemeFiles?: Maybe<Array<OnlineStoreThemeFileOperationResult>>;
  userErrors: Array<OnlineStoreThemeFilesUserErrors>;
};

export type ThemeFilesDeletePayload = {
  deletedThemeFiles?: Maybe<Array<OnlineStoreThemeFileOperationResult>>;
  userErrors: Array<OnlineStoreThemeFilesUserErrors>;
};

export type ThemeFilesUpsertPayload = {
  job?: Maybe<Job>;
  upsertedThemeFiles?: Maybe<Array<OnlineStoreThemeFileOperationResult>>;
  userErrors: Array<OnlineStoreThemeFilesUserErrors>;
};

export type ThemePublishPayload = {
  theme?: Maybe<OnlineStoreTheme>;
  userErrors: Array<ThemePublishUserError>;
};

export type ThemePublishUserError = DisplayableError & {
  code?: Maybe<ThemePublishUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ThemePublishUserErrorCode = {
  CannotPublishThemeDuringInstall: 'CANNOT_PUBLISH_THEME_DURING_INSTALL',
  NotFound: 'NOT_FOUND',
  ThemePublishNotAvailableForThemeLimitedPlan: 'THEME_PUBLISH_NOT_AVAILABLE_FOR_THEME_LIMITED_PLAN'
} as const;

export type ThemePublishUserErrorCode = typeof ThemePublishUserErrorCode[keyof typeof ThemePublishUserErrorCode];
export const ThemeRole = {
  Archived: 'ARCHIVED',
  Demo: 'DEMO',
  Development: 'DEVELOPMENT',
  Locked: 'LOCKED',
  Main: 'MAIN',
  Mobile: 'MOBILE',
  Unpublished: 'UNPUBLISHED'
} as const;

export type ThemeRole = typeof ThemeRole[keyof typeof ThemeRole];
export type ThemeUpdatePayload = {
  theme?: Maybe<OnlineStoreTheme>;
  userErrors: Array<ThemeUpdateUserError>;
};

export type ThemeUpdateUserError = DisplayableError & {
  code?: Maybe<ThemeUpdateUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ThemeUpdateUserErrorCode = {
  Invalid: 'INVALID',
  NotFound: 'NOT_FOUND',
  TooLong: 'TOO_LONG'
} as const;

export type ThemeUpdateUserErrorCode = typeof ThemeUpdateUserErrorCode[keyof typeof ThemeUpdateUserErrorCode];
export type TipSale = Sale & {
  actionType: SaleActionType;
  id: Scalars['ID']['output'];
  lineItem: LineItem;
  lineType: SaleLineType;
  quantity?: Maybe<Scalars['Int']['output']>;
  taxes: Array<SaleTax>;
  totalAmount: MoneyBag;
  totalDiscountAmountAfterTaxes: MoneyBag;
  totalDiscountAmountBeforeTaxes: MoneyBag;
  totalTaxAmount: MoneyBag;
};

export type TransactionFee = Node & {
  amount: MoneyV2;
  flatFee: MoneyV2;
  flatFeeName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  rate: Scalars['Decimal']['output'];
  rateName?: Maybe<Scalars['String']['output']>;
  taxAmount: MoneyV2;
  type: Scalars['String']['output'];
};

export const TransactionSortKeys = {
  CreatedAt: 'CREATED_AT',
  ExpiresAt: 'EXPIRES_AT'
} as const;

export type TransactionSortKeys = typeof TransactionSortKeys[keyof typeof TransactionSortKeys];
export type TransactionVoidPayload = {
  transaction?: Maybe<OrderTransaction>;
  userErrors: Array<TransactionVoidUserError>;
};

export type TransactionVoidUserError = DisplayableError & {
  code?: Maybe<TransactionVoidUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const TransactionVoidUserErrorCode = {
  AuthNotSuccessful: 'AUTH_NOT_SUCCESSFUL',
  AuthNotVoidable: 'AUTH_NOT_VOIDABLE',
  GenericError: 'GENERIC_ERROR',
  TransactionNotFound: 'TRANSACTION_NOT_FOUND'
} as const;

export type TransactionVoidUserErrorCode = typeof TransactionVoidUserErrorCode[keyof typeof TransactionVoidUserErrorCode];
export type TranslatableContent = {
  digest?: Maybe<Scalars['String']['output']>;
  key: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  type: LocalizableContentType;
  value?: Maybe<Scalars['String']['output']>;
};

export type TranslatableResource = {
  nestedTranslatableResources: TranslatableResourceConnection;
  resourceId: Scalars['ID']['output'];
  translatableContent: Array<TranslatableContent>;
  translations: Array<Translation>;
};


export type TranslatableResourceNestedTranslatableResourcesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  resourceType?: InputMaybe<TranslatableResourceType>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};


export type TranslatableResourceTranslatableContentArgs = {
  marketId?: InputMaybe<Scalars['ID']['input']>;
};


export type TranslatableResourceTranslationsArgs = {
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
  outdated?: InputMaybe<Scalars['Boolean']['input']>;
};

export type TranslatableResourceConnection = {
  edges: Array<TranslatableResourceEdge>;
  nodes: Array<TranslatableResource>;
  pageInfo: PageInfo;
};

export type TranslatableResourceEdge = {
  cursor: Scalars['String']['output'];
  node: TranslatableResource;
};

export const TranslatableResourceType = {
  Article: 'ARTICLE',
  Blog: 'BLOG',
  Collection: 'COLLECTION',
  DeliveryMethodDefinition: 'DELIVERY_METHOD_DEFINITION',
  EmailTemplate: 'EMAIL_TEMPLATE',
  Filter: 'FILTER',
  Link: 'LINK',
  Menu: 'MENU',
  Metafield: 'METAFIELD',
  Metaobject: 'METAOBJECT',
  OnlineStoreTheme: 'ONLINE_STORE_THEME',
  OnlineStoreThemeAppEmbed: 'ONLINE_STORE_THEME_APP_EMBED',
  OnlineStoreThemeJsonTemplate: 'ONLINE_STORE_THEME_JSON_TEMPLATE',
  OnlineStoreThemeLocaleContent: 'ONLINE_STORE_THEME_LOCALE_CONTENT',
  OnlineStoreThemeSectionGroup: 'ONLINE_STORE_THEME_SECTION_GROUP',
  OnlineStoreThemeSettingsCategory: 'ONLINE_STORE_THEME_SETTINGS_CATEGORY',
  OnlineStoreThemeSettingsDataSections: 'ONLINE_STORE_THEME_SETTINGS_DATA_SECTIONS',
  PackingSlipTemplate: 'PACKING_SLIP_TEMPLATE',
  Page: 'PAGE',
  PaymentGateway: 'PAYMENT_GATEWAY',
  Product: 'PRODUCT',
  ProductOption: 'PRODUCT_OPTION',
  ProductOptionValue: 'PRODUCT_OPTION_VALUE',
  SellingPlan: 'SELLING_PLAN',
  SellingPlanGroup: 'SELLING_PLAN_GROUP',
  Shop: 'SHOP',
  ShopPolicy: 'SHOP_POLICY'
} as const;

export type TranslatableResourceType = typeof TranslatableResourceType[keyof typeof TranslatableResourceType];
export type Translation = {
  key: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  market?: Maybe<Market>;
  outdated: Scalars['Boolean']['output'];
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

export const TranslationErrorCode = {
  Blank: 'BLANK',
  FailsResourceValidation: 'FAILS_RESOURCE_VALIDATION',
  Invalid: 'INVALID',
  InvalidCode: 'INVALID_CODE',
  InvalidFormat: 'INVALID_FORMAT',
  InvalidKeyForModel: 'INVALID_KEY_FOR_MODEL',
  InvalidLocaleForMarket: 'INVALID_LOCALE_FOR_MARKET',
  InvalidLocaleForShop: 'INVALID_LOCALE_FOR_SHOP',
  InvalidMarketLocalizableContent: 'INVALID_MARKET_LOCALIZABLE_CONTENT',
  InvalidTranslatableContent: 'INVALID_TRANSLATABLE_CONTENT',
  InvalidValueForHandleTranslation: 'INVALID_VALUE_FOR_HANDLE_TRANSLATION',
  MarketCustomContentNotAllowed: 'MARKET_CUSTOM_CONTENT_NOT_ALLOWED',
  MarketDoesNotExist: 'MARKET_DOES_NOT_EXIST',
  MarketLocaleCreationFailed: 'MARKET_LOCALE_CREATION_FAILED',
  ResourceNotFound: 'RESOURCE_NOT_FOUND',
  ResourceNotMarketCustomizable: 'RESOURCE_NOT_MARKET_CUSTOMIZABLE',
  ResourceNotTranslatable: 'RESOURCE_NOT_TRANSLATABLE',
  TooManyKeysForResource: 'TOO_MANY_KEYS_FOR_RESOURCE'
} as const;

export type TranslationErrorCode = typeof TranslationErrorCode[keyof typeof TranslationErrorCode];
export type TranslationInput = {
  key: Scalars['String']['input'];
  locale: Scalars['String']['input'];
  marketId?: InputMaybe<Scalars['ID']['input']>;
  translatableContentDigest: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type TranslationUserError = DisplayableError & {
  code?: Maybe<TranslationErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type TranslationsRegisterPayload = {
  translations?: Maybe<Array<Translation>>;
  userErrors: Array<TranslationUserError>;
};

export type TranslationsRemovePayload = {
  translations?: Maybe<Array<Translation>>;
  userErrors: Array<TranslationUserError>;
};

export type TypedAttribute = {
  key: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type UtmInput = {
  campaign: Scalars['String']['input'];
  medium: Scalars['String']['input'];
  source: Scalars['String']['input'];
};

export type UtmParameters = {
  campaign?: Maybe<Scalars['String']['output']>;
  content?: Maybe<Scalars['String']['output']>;
  medium?: Maybe<Scalars['String']['output']>;
  source?: Maybe<Scalars['String']['output']>;
  term?: Maybe<Scalars['String']['output']>;
};

export type UniqueMetafieldValueInput = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};

export type UnitPriceMeasurement = {
  measuredType?: Maybe<UnitPriceMeasurementMeasuredType>;
  quantityUnit?: Maybe<UnitPriceMeasurementMeasuredUnit>;
  quantityValue: Scalars['Float']['output'];
  referenceUnit?: Maybe<UnitPriceMeasurementMeasuredUnit>;
  referenceValue: Scalars['Int']['output'];
};

export const UnitPriceMeasurementMeasuredType = {
  Area: 'AREA',
  Length: 'LENGTH',
  Volume: 'VOLUME',
  Weight: 'WEIGHT'
} as const;

export type UnitPriceMeasurementMeasuredType = typeof UnitPriceMeasurementMeasuredType[keyof typeof UnitPriceMeasurementMeasuredType];
export const UnitPriceMeasurementMeasuredUnit = {
  Cl: 'CL',
  Cm: 'CM',
  G: 'G',
  Kg: 'KG',
  L: 'L',
  M: 'M',
  M2: 'M2',
  M3: 'M3',
  Mg: 'MG',
  Ml: 'ML',
  Mm: 'MM'
} as const;

export type UnitPriceMeasurementMeasuredUnit = typeof UnitPriceMeasurementMeasuredUnit[keyof typeof UnitPriceMeasurementMeasuredUnit];
export const UnitSystem = {
  ImperialSystem: 'IMPERIAL_SYSTEM',
  MetricSystem: 'METRIC_SYSTEM'
} as const;

export type UnitSystem = typeof UnitSystem[keyof typeof UnitSystem];
export type UnknownSale = Sale & {
  actionType: SaleActionType;
  id: Scalars['ID']['output'];
  lineType: SaleLineType;
  quantity?: Maybe<Scalars['Int']['output']>;
  taxes: Array<SaleTax>;
  totalAmount: MoneyBag;
  totalDiscountAmountAfterTaxes: MoneyBag;
  totalDiscountAmountBeforeTaxes: MoneyBag;
  totalTaxAmount: MoneyBag;
};

export type UnverifiedReturnLineItem = Node & ReturnLineItemType & {
  customerNote?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  quantity: Scalars['Int']['output'];
  refundableQuantity: Scalars['Int']['output'];
  refundedQuantity: Scalars['Int']['output'];
  returnReason: ReturnReason;
  returnReasonNote: Scalars['String']['output'];
  unitPrice: MoneyV2;
};

export type UpdateMediaInput = {
  alt?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  previewImageSource?: InputMaybe<Scalars['String']['input']>;
};

export type UrlRedirect = Node & {
  id: Scalars['ID']['output'];
  path: Scalars['String']['output'];
  target: Scalars['String']['output'];
};

export type UrlRedirectBulkDeleteAllPayload = {
  job?: Maybe<Job>;
  userErrors: Array<UserError>;
};

export type UrlRedirectBulkDeleteByIdsPayload = {
  job?: Maybe<Job>;
  userErrors: Array<UrlRedirectBulkDeleteByIdsUserError>;
};

export type UrlRedirectBulkDeleteByIdsUserError = DisplayableError & {
  code?: Maybe<UrlRedirectBulkDeleteByIdsUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const UrlRedirectBulkDeleteByIdsUserErrorCode = {
  IdsEmpty: 'IDS_EMPTY'
} as const;

export type UrlRedirectBulkDeleteByIdsUserErrorCode = typeof UrlRedirectBulkDeleteByIdsUserErrorCode[keyof typeof UrlRedirectBulkDeleteByIdsUserErrorCode];
export type UrlRedirectBulkDeleteBySavedSearchPayload = {
  job?: Maybe<Job>;
  userErrors: Array<UrlRedirectBulkDeleteBySavedSearchUserError>;
};

export type UrlRedirectBulkDeleteBySavedSearchUserError = DisplayableError & {
  code?: Maybe<UrlRedirectBulkDeleteBySavedSearchUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const UrlRedirectBulkDeleteBySavedSearchUserErrorCode = {
  InvalidSavedSearchQuery: 'INVALID_SAVED_SEARCH_QUERY',
  SavedSearchNotFound: 'SAVED_SEARCH_NOT_FOUND'
} as const;

export type UrlRedirectBulkDeleteBySavedSearchUserErrorCode = typeof UrlRedirectBulkDeleteBySavedSearchUserErrorCode[keyof typeof UrlRedirectBulkDeleteBySavedSearchUserErrorCode];
export type UrlRedirectBulkDeleteBySearchPayload = {
  job?: Maybe<Job>;
  userErrors: Array<UrlRedirectBulkDeleteBySearchUserError>;
};

export type UrlRedirectBulkDeleteBySearchUserError = DisplayableError & {
  code?: Maybe<UrlRedirectBulkDeleteBySearchUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const UrlRedirectBulkDeleteBySearchUserErrorCode = {
  InvalidSearchArgument: 'INVALID_SEARCH_ARGUMENT'
} as const;

export type UrlRedirectBulkDeleteBySearchUserErrorCode = typeof UrlRedirectBulkDeleteBySearchUserErrorCode[keyof typeof UrlRedirectBulkDeleteBySearchUserErrorCode];
export type UrlRedirectConnection = {
  edges: Array<UrlRedirectEdge>;
  nodes: Array<UrlRedirect>;
  pageInfo: PageInfo;
};

export type UrlRedirectCreatePayload = {
  urlRedirect?: Maybe<UrlRedirect>;
  userErrors: Array<UrlRedirectUserError>;
};

export type UrlRedirectDeletePayload = {
  deletedUrlRedirectId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<UrlRedirectUserError>;
};

export type UrlRedirectEdge = {
  cursor: Scalars['String']['output'];
  node: UrlRedirect;
};

export const UrlRedirectErrorCode = {
  CreateFailed: 'CREATE_FAILED',
  DeleteFailed: 'DELETE_FAILED',
  DoesNotExist: 'DOES_NOT_EXIST',
  UpdateFailed: 'UPDATE_FAILED'
} as const;

export type UrlRedirectErrorCode = typeof UrlRedirectErrorCode[keyof typeof UrlRedirectErrorCode];
export type UrlRedirectImport = Node & {
  count?: Maybe<Scalars['Int']['output']>;
  createdCount?: Maybe<Scalars['Int']['output']>;
  failedCount?: Maybe<Scalars['Int']['output']>;
  finished: Scalars['Boolean']['output'];
  finishedAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  previewRedirects: Array<UrlRedirectImportPreview>;
  updatedCount?: Maybe<Scalars['Int']['output']>;
};

export type UrlRedirectImportCreatePayload = {
  urlRedirectImport?: Maybe<UrlRedirectImport>;
  userErrors: Array<UrlRedirectImportUserError>;
};

export const UrlRedirectImportErrorCode = {
  AlreadyImported: 'ALREADY_IMPORTED',
  FileDoesNotExist: 'FILE_DOES_NOT_EXIST',
  InProgress: 'IN_PROGRESS',
  NotFound: 'NOT_FOUND'
} as const;

export type UrlRedirectImportErrorCode = typeof UrlRedirectImportErrorCode[keyof typeof UrlRedirectImportErrorCode];
export type UrlRedirectImportPreview = {
  path: Scalars['String']['output'];
  target: Scalars['String']['output'];
};

export type UrlRedirectImportSubmitPayload = {
  job?: Maybe<Job>;
  userErrors: Array<UrlRedirectImportUserError>;
};

export type UrlRedirectImportUserError = DisplayableError & {
  code?: Maybe<UrlRedirectImportErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type UrlRedirectInput = {
  path?: InputMaybe<Scalars['String']['input']>;
  target?: InputMaybe<Scalars['String']['input']>;
};

export const UrlRedirectSortKeys = {
  Id: 'ID',
  Path: 'PATH',
  Relevance: 'RELEVANCE'
} as const;

export type UrlRedirectSortKeys = typeof UrlRedirectSortKeys[keyof typeof UrlRedirectSortKeys];
export type UrlRedirectUpdatePayload = {
  urlRedirect?: Maybe<UrlRedirect>;
  userErrors: Array<UrlRedirectUserError>;
};

export type UrlRedirectUserError = DisplayableError & {
  code?: Maybe<UrlRedirectErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type UserError = DisplayableError & {
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export type Validation = HasMetafieldDefinitions & HasMetafields & Node & {
  blockOnFailure: Scalars['Boolean']['output'];
  enabled: Scalars['Boolean']['output'];
  errorHistory?: Maybe<FunctionsErrorHistory>;
  id: Scalars['ID']['output'];
  metafield?: Maybe<Metafield>;
  /** @deprecated This field will be removed in a future version. Use the root `metafieldDefinitions` field instead. */
  metafieldDefinitions: MetafieldDefinitionConnection;
  metafields: MetafieldConnection;
  shopifyFunction: ShopifyFunction;
  title: Scalars['String']['output'];
};


export type ValidationMetafieldArgs = {
  key: Scalars['String']['input'];
  namespace?: InputMaybe<Scalars['String']['input']>;
};


export type ValidationMetafieldDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  pinnedStatus?: InputMaybe<MetafieldDefinitionPinnedStatus>;
  query?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
  sortKey?: InputMaybe<MetafieldDefinitionSortKeys>;
};


export type ValidationMetafieldsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  keys?: InputMaybe<Array<Scalars['String']['input']>>;
  last?: InputMaybe<Scalars['Int']['input']>;
  namespace?: InputMaybe<Scalars['String']['input']>;
  reverse?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ValidationConnection = {
  edges: Array<ValidationEdge>;
  nodes: Array<Validation>;
  pageInfo: PageInfo;
};

export type ValidationCreateInput = {
  blockOnFailure?: InputMaybe<Scalars['Boolean']['input']>;
  enable?: InputMaybe<Scalars['Boolean']['input']>;
  functionId: Scalars['String']['input'];
  metafields?: InputMaybe<Array<MetafieldInput>>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ValidationCreatePayload = {
  userErrors: Array<ValidationUserError>;
  validation?: Maybe<Validation>;
};

export type ValidationDeletePayload = {
  deletedId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<ValidationUserError>;
};

export type ValidationEdge = {
  cursor: Scalars['String']['output'];
  node: Validation;
};

export const ValidationSortKeys = {
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type ValidationSortKeys = typeof ValidationSortKeys[keyof typeof ValidationSortKeys];
export type ValidationUpdateInput = {
  blockOnFailure?: InputMaybe<Scalars['Boolean']['input']>;
  enable?: InputMaybe<Scalars['Boolean']['input']>;
  metafields?: InputMaybe<Array<MetafieldInput>>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type ValidationUpdatePayload = {
  userErrors: Array<ValidationUserError>;
  validation?: Maybe<Validation>;
};

export type ValidationUserError = DisplayableError & {
  code?: Maybe<ValidationUserErrorCode>;
  field?: Maybe<Array<Scalars['String']['output']>>;
  message: Scalars['String']['output'];
};

export const ValidationUserErrorCode = {
  AppNotAuthorized: 'APP_NOT_AUTHORIZED',
  Blank: 'BLANK',
  CapabilityViolation: 'CAPABILITY_VIOLATION',
  CustomAppFunctionNotEligible: 'CUSTOM_APP_FUNCTION_NOT_ELIGIBLE',
  DisallowedOwnerType: 'DISALLOWED_OWNER_TYPE',
  FunctionDoesNotImplement: 'FUNCTION_DOES_NOT_IMPLEMENT',
  FunctionNotFound: 'FUNCTION_NOT_FOUND',
  FunctionPendingDeletion: 'FUNCTION_PENDING_DELETION',
  Inclusion: 'INCLUSION',
  InternalError: 'INTERNAL_ERROR',
  InvalidType: 'INVALID_TYPE',
  InvalidValue: 'INVALID_VALUE',
  MaxValidationsActivated: 'MAX_VALIDATIONS_ACTIVATED',
  NotFound: 'NOT_FOUND',
  Present: 'PRESENT',
  PublicAppNotAllowed: 'PUBLIC_APP_NOT_ALLOWED',
  Taken: 'TAKEN',
  TooLong: 'TOO_LONG',
  TooShort: 'TOO_SHORT',
  UnstructuredReservedNamespace: 'UNSTRUCTURED_RESERVED_NAMESPACE'
} as const;

export type ValidationUserErrorCode = typeof ValidationUserErrorCode[keyof typeof ValidationUserErrorCode];
export type VariantOptionValueInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  linkedMetafieldValue?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  optionId?: InputMaybe<Scalars['ID']['input']>;
  optionName?: InputMaybe<Scalars['String']['input']>;
};

export type VaultCreditCard = {
  billingAddress?: Maybe<CustomerCreditCardBillingAddress>;
  brand: Scalars['String']['output'];
  expired: Scalars['Boolean']['output'];
  expiryMonth: Scalars['Int']['output'];
  expiryYear: Scalars['Int']['output'];
  lastDigits: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export type VaultPaypalBillingAgreement = {
  inactive: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  paypalAccountEmail: Scalars['String']['output'];
};

export type Vector3 = {
  x: Scalars['Float']['output'];
  y: Scalars['Float']['output'];
  z: Scalars['Float']['output'];
};

export type Video = File & Media & Node & {
  alt?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  duration?: Maybe<Scalars['Int']['output']>;
  fileErrors: Array<FileError>;
  fileStatus: FileStatus;
  filename: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  mediaContentType: MediaContentType;
  mediaErrors: Array<MediaError>;
  mediaWarnings: Array<MediaWarning>;
  originalSource?: Maybe<VideoSource>;
  preview?: Maybe<MediaPreviewImage>;
  sources: Array<VideoSource>;
  status: MediaStatus;
  updatedAt: Scalars['DateTime']['output'];
};

export type VideoSource = {
  fileSize?: Maybe<Scalars['Int']['output']>;
  format: Scalars['String']['output'];
  height: Scalars['Int']['output'];
  mimeType: Scalars['String']['output'];
  url: Scalars['String']['output'];
  width: Scalars['Int']['output'];
};

export type WebPixel = Node & {
  id: Scalars['ID']['output'];
  settings: Scalars['JSON']['output'];
};

export type WebPixelCreatePayload = {
  userErrors: Array<ErrorsWebPixelUserError>;
  webPixel?: Maybe<WebPixel>;
};

export type WebPixelDeletePayload = {
  deletedWebPixelId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<ErrorsWebPixelUserError>;
};

export type WebPixelInput = {
  settings: Scalars['JSON']['input'];
};

export type WebPixelUpdatePayload = {
  userErrors: Array<ErrorsWebPixelUserError>;
  webPixel?: Maybe<WebPixel>;
};

export type WebhookEventBridgeEndpoint = {
  arn: Scalars['ARN']['output'];
};

export type WebhookHttpEndpoint = {
  callbackUrl: Scalars['URL']['output'];
};

export type WebhookPubSubEndpoint = {
  pubSubProject: Scalars['String']['output'];
  pubSubTopic: Scalars['String']['output'];
};

export type WebhookSubscription = LegacyInteroperability & Node & {
  apiVersion: ApiVersion;
  /** @deprecated Use `endpoint` instead. */
  callbackUrl: Scalars['URL']['output'];
  createdAt: Scalars['DateTime']['output'];
  endpoint: WebhookSubscriptionEndpoint;
  filter?: Maybe<Scalars['String']['output']>;
  format: WebhookSubscriptionFormat;
  id: Scalars['ID']['output'];
  includeFields: Array<Scalars['String']['output']>;
  legacyResourceId: Scalars['UnsignedInt64']['output'];
  metafieldNamespaces: Array<Scalars['String']['output']>;
  topic: WebhookSubscriptionTopic;
  updatedAt: Scalars['DateTime']['output'];
};

export type WebhookSubscriptionConnection = {
  edges: Array<WebhookSubscriptionEdge>;
  nodes: Array<WebhookSubscription>;
  pageInfo: PageInfo;
};

export type WebhookSubscriptionCreatePayload = {
  userErrors: Array<UserError>;
  webhookSubscription?: Maybe<WebhookSubscription>;
};

export type WebhookSubscriptionDeletePayload = {
  deletedWebhookSubscriptionId?: Maybe<Scalars['ID']['output']>;
  userErrors: Array<UserError>;
};

export type WebhookSubscriptionEdge = {
  cursor: Scalars['String']['output'];
  node: WebhookSubscription;
};

export type WebhookSubscriptionEndpoint = WebhookEventBridgeEndpoint | WebhookHttpEndpoint | WebhookPubSubEndpoint;

export const WebhookSubscriptionFormat = {
  Json: 'JSON',
  Xml: 'XML'
} as const;

export type WebhookSubscriptionFormat = typeof WebhookSubscriptionFormat[keyof typeof WebhookSubscriptionFormat];
export type WebhookSubscriptionInput = {
  callbackUrl?: InputMaybe<Scalars['URL']['input']>;
  filter?: InputMaybe<Scalars['String']['input']>;
  format?: InputMaybe<WebhookSubscriptionFormat>;
  includeFields?: InputMaybe<Array<Scalars['String']['input']>>;
  metafieldNamespaces?: InputMaybe<Array<Scalars['String']['input']>>;
};

export const WebhookSubscriptionSortKeys = {
  CreatedAt: 'CREATED_AT',
  Id: 'ID',
  Relevance: 'RELEVANCE'
} as const;

export type WebhookSubscriptionSortKeys = typeof WebhookSubscriptionSortKeys[keyof typeof WebhookSubscriptionSortKeys];
export const WebhookSubscriptionTopic = {
  AppPurchasesOneTimeUpdate: 'APP_PURCHASES_ONE_TIME_UPDATE',
  AppScopesUpdate: 'APP_SCOPES_UPDATE',
  AppSubscriptionsApproachingCappedAmount: 'APP_SUBSCRIPTIONS_APPROACHING_CAPPED_AMOUNT',
  AppSubscriptionsUpdate: 'APP_SUBSCRIPTIONS_UPDATE',
  AppUninstalled: 'APP_UNINSTALLED',
  AttributedSessionsFirst: 'ATTRIBUTED_SESSIONS_FIRST',
  AttributedSessionsLast: 'ATTRIBUTED_SESSIONS_LAST',
  AuditEventsAdminApiActivity: 'AUDIT_EVENTS_ADMIN_API_ACTIVITY',
  BulkOperationsFinish: 'BULK_OPERATIONS_FINISH',
  CartsCreate: 'CARTS_CREATE',
  CartsUpdate: 'CARTS_UPDATE',
  ChannelsDelete: 'CHANNELS_DELETE',
  CheckoutsCreate: 'CHECKOUTS_CREATE',
  CheckoutsDelete: 'CHECKOUTS_DELETE',
  CheckoutsUpdate: 'CHECKOUTS_UPDATE',
  CollectionsCreate: 'COLLECTIONS_CREATE',
  CollectionsDelete: 'COLLECTIONS_DELETE',
  CollectionsUpdate: 'COLLECTIONS_UPDATE',
  CollectionListingsAdd: 'COLLECTION_LISTINGS_ADD',
  CollectionListingsRemove: 'COLLECTION_LISTINGS_REMOVE',
  CollectionListingsUpdate: 'COLLECTION_LISTINGS_UPDATE',
  CollectionPublicationsCreate: 'COLLECTION_PUBLICATIONS_CREATE',
  CollectionPublicationsDelete: 'COLLECTION_PUBLICATIONS_DELETE',
  CollectionPublicationsUpdate: 'COLLECTION_PUBLICATIONS_UPDATE',
  CompaniesCreate: 'COMPANIES_CREATE',
  CompaniesDelete: 'COMPANIES_DELETE',
  CompaniesUpdate: 'COMPANIES_UPDATE',
  CompanyContactsCreate: 'COMPANY_CONTACTS_CREATE',
  CompanyContactsDelete: 'COMPANY_CONTACTS_DELETE',
  CompanyContactsUpdate: 'COMPANY_CONTACTS_UPDATE',
  CompanyContactRolesAssign: 'COMPANY_CONTACT_ROLES_ASSIGN',
  CompanyContactRolesRevoke: 'COMPANY_CONTACT_ROLES_REVOKE',
  CompanyLocationsCreate: 'COMPANY_LOCATIONS_CREATE',
  CompanyLocationsDelete: 'COMPANY_LOCATIONS_DELETE',
  CompanyLocationsUpdate: 'COMPANY_LOCATIONS_UPDATE',
  CustomersCreate: 'CUSTOMERS_CREATE',
  CustomersDelete: 'CUSTOMERS_DELETE',
  CustomersDisable: 'CUSTOMERS_DISABLE',
  CustomersEmailMarketingConsentUpdate: 'CUSTOMERS_EMAIL_MARKETING_CONSENT_UPDATE',
  CustomersEnable: 'CUSTOMERS_ENABLE',
  CustomersMarketingConsentUpdate: 'CUSTOMERS_MARKETING_CONSENT_UPDATE',
  CustomersMerge: 'CUSTOMERS_MERGE',
  CustomersPurchasingSummary: 'CUSTOMERS_PURCHASING_SUMMARY',
  CustomersUpdate: 'CUSTOMERS_UPDATE',
  CustomerAccountSettingsUpdate: 'CUSTOMER_ACCOUNT_SETTINGS_UPDATE',
  CustomerGroupsCreate: 'CUSTOMER_GROUPS_CREATE',
  CustomerGroupsDelete: 'CUSTOMER_GROUPS_DELETE',
  CustomerGroupsUpdate: 'CUSTOMER_GROUPS_UPDATE',
  CustomerJoinedSegment: 'CUSTOMER_JOINED_SEGMENT',
  CustomerLeftSegment: 'CUSTOMER_LEFT_SEGMENT',
  CustomerPaymentMethodsCreate: 'CUSTOMER_PAYMENT_METHODS_CREATE',
  CustomerPaymentMethodsRevoke: 'CUSTOMER_PAYMENT_METHODS_REVOKE',
  CustomerPaymentMethodsUpdate: 'CUSTOMER_PAYMENT_METHODS_UPDATE',
  CustomerTagsAdded: 'CUSTOMER_TAGS_ADDED',
  CustomerTagsRemoved: 'CUSTOMER_TAGS_REMOVED',
  DeliveryPromiseSettingsUpdate: 'DELIVERY_PROMISE_SETTINGS_UPDATE',
  DiscountsCreate: 'DISCOUNTS_CREATE',
  DiscountsDelete: 'DISCOUNTS_DELETE',
  DiscountsRedeemcodeAdded: 'DISCOUNTS_REDEEMCODE_ADDED',
  DiscountsRedeemcodeRemoved: 'DISCOUNTS_REDEEMCODE_REMOVED',
  DiscountsUpdate: 'DISCOUNTS_UPDATE',
  DisputesCreate: 'DISPUTES_CREATE',
  DisputesUpdate: 'DISPUTES_UPDATE',
  DomainsCreate: 'DOMAINS_CREATE',
  DomainsDestroy: 'DOMAINS_DESTROY',
  DomainsUpdate: 'DOMAINS_UPDATE',
  DraftOrdersCreate: 'DRAFT_ORDERS_CREATE',
  DraftOrdersDelete: 'DRAFT_ORDERS_DELETE',
  DraftOrdersUpdate: 'DRAFT_ORDERS_UPDATE',
  FulfillmentsCreate: 'FULFILLMENTS_CREATE',
  FulfillmentsUpdate: 'FULFILLMENTS_UPDATE',
  FulfillmentEventsCreate: 'FULFILLMENT_EVENTS_CREATE',
  FulfillmentEventsDelete: 'FULFILLMENT_EVENTS_DELETE',
  FulfillmentHoldsAdded: 'FULFILLMENT_HOLDS_ADDED',
  FulfillmentHoldsReleased: 'FULFILLMENT_HOLDS_RELEASED',
  FulfillmentOrdersCancellationRequestAccepted: 'FULFILLMENT_ORDERS_CANCELLATION_REQUEST_ACCEPTED',
  FulfillmentOrdersCancellationRequestRejected: 'FULFILLMENT_ORDERS_CANCELLATION_REQUEST_REJECTED',
  FulfillmentOrdersCancellationRequestSubmitted: 'FULFILLMENT_ORDERS_CANCELLATION_REQUEST_SUBMITTED',
  FulfillmentOrdersCancelled: 'FULFILLMENT_ORDERS_CANCELLED',
  FulfillmentOrdersFulfillmentRequestAccepted: 'FULFILLMENT_ORDERS_FULFILLMENT_REQUEST_ACCEPTED',
  FulfillmentOrdersFulfillmentRequestRejected: 'FULFILLMENT_ORDERS_FULFILLMENT_REQUEST_REJECTED',
  FulfillmentOrdersFulfillmentRequestSubmitted: 'FULFILLMENT_ORDERS_FULFILLMENT_REQUEST_SUBMITTED',
  FulfillmentOrdersFulfillmentServiceFailedToComplete: 'FULFILLMENT_ORDERS_FULFILLMENT_SERVICE_FAILED_TO_COMPLETE',
  FulfillmentOrdersHoldReleased: 'FULFILLMENT_ORDERS_HOLD_RELEASED',
  FulfillmentOrdersLineItemsPreparedForLocalDelivery: 'FULFILLMENT_ORDERS_LINE_ITEMS_PREPARED_FOR_LOCAL_DELIVERY',
  FulfillmentOrdersLineItemsPreparedForPickup: 'FULFILLMENT_ORDERS_LINE_ITEMS_PREPARED_FOR_PICKUP',
  FulfillmentOrdersMerged: 'FULFILLMENT_ORDERS_MERGED',
  FulfillmentOrdersMoved: 'FULFILLMENT_ORDERS_MOVED',
  FulfillmentOrdersOrderRoutingComplete: 'FULFILLMENT_ORDERS_ORDER_ROUTING_COMPLETE',
  FulfillmentOrdersPlacedOnHold: 'FULFILLMENT_ORDERS_PLACED_ON_HOLD',
  FulfillmentOrdersRescheduled: 'FULFILLMENT_ORDERS_RESCHEDULED',
  FulfillmentOrdersScheduledFulfillmentOrderReady: 'FULFILLMENT_ORDERS_SCHEDULED_FULFILLMENT_ORDER_READY',
  FulfillmentOrdersSplit: 'FULFILLMENT_ORDERS_SPLIT',
  InventoryItemsCreate: 'INVENTORY_ITEMS_CREATE',
  InventoryItemsDelete: 'INVENTORY_ITEMS_DELETE',
  InventoryItemsUpdate: 'INVENTORY_ITEMS_UPDATE',
  InventoryLevelsConnect: 'INVENTORY_LEVELS_CONNECT',
  InventoryLevelsDisconnect: 'INVENTORY_LEVELS_DISCONNECT',
  InventoryLevelsUpdate: 'INVENTORY_LEVELS_UPDATE',
  LocalesCreate: 'LOCALES_CREATE',
  LocalesUpdate: 'LOCALES_UPDATE',
  LocationsActivate: 'LOCATIONS_ACTIVATE',
  LocationsCreate: 'LOCATIONS_CREATE',
  LocationsDeactivate: 'LOCATIONS_DEACTIVATE',
  LocationsDelete: 'LOCATIONS_DELETE',
  LocationsUpdate: 'LOCATIONS_UPDATE',
  MarketsCreate: 'MARKETS_CREATE',
  MarketsDelete: 'MARKETS_DELETE',
  MarketsUpdate: 'MARKETS_UPDATE',
  MetafieldDefinitionsCreate: 'METAFIELD_DEFINITIONS_CREATE',
  MetafieldDefinitionsDelete: 'METAFIELD_DEFINITIONS_DELETE',
  MetafieldDefinitionsUpdate: 'METAFIELD_DEFINITIONS_UPDATE',
  MetaobjectsCreate: 'METAOBJECTS_CREATE',
  MetaobjectsDelete: 'METAOBJECTS_DELETE',
  MetaobjectsUpdate: 'METAOBJECTS_UPDATE',
  OrdersCancelled: 'ORDERS_CANCELLED',
  OrdersCreate: 'ORDERS_CREATE',
  OrdersDelete: 'ORDERS_DELETE',
  OrdersEdited: 'ORDERS_EDITED',
  OrdersFulfilled: 'ORDERS_FULFILLED',
  OrdersPaid: 'ORDERS_PAID',
  OrdersPartiallyFulfilled: 'ORDERS_PARTIALLY_FULFILLED',
  OrdersRiskAssessmentChanged: 'ORDERS_RISK_ASSESSMENT_CHANGED',
  OrdersShopifyProtectEligibilityChanged: 'ORDERS_SHOPIFY_PROTECT_ELIGIBILITY_CHANGED',
  OrdersUpdated: 'ORDERS_UPDATED',
  OrderTransactionsCreate: 'ORDER_TRANSACTIONS_CREATE',
  PaymentSchedulesDue: 'PAYMENT_SCHEDULES_DUE',
  PaymentTermsCreate: 'PAYMENT_TERMS_CREATE',
  PaymentTermsDelete: 'PAYMENT_TERMS_DELETE',
  PaymentTermsUpdate: 'PAYMENT_TERMS_UPDATE',
  ProductsCreate: 'PRODUCTS_CREATE',
  ProductsDelete: 'PRODUCTS_DELETE',
  ProductsUpdate: 'PRODUCTS_UPDATE',
  ProductFeedsCreate: 'PRODUCT_FEEDS_CREATE',
  ProductFeedsFullSync: 'PRODUCT_FEEDS_FULL_SYNC',
  ProductFeedsFullSyncFinish: 'PRODUCT_FEEDS_FULL_SYNC_FINISH',
  ProductFeedsIncrementalSync: 'PRODUCT_FEEDS_INCREMENTAL_SYNC',
  ProductFeedsUpdate: 'PRODUCT_FEEDS_UPDATE',
  ProductListingsAdd: 'PRODUCT_LISTINGS_ADD',
  ProductListingsRemove: 'PRODUCT_LISTINGS_REMOVE',
  ProductListingsUpdate: 'PRODUCT_LISTINGS_UPDATE',
  ProductPublicationsCreate: 'PRODUCT_PUBLICATIONS_CREATE',
  ProductPublicationsDelete: 'PRODUCT_PUBLICATIONS_DELETE',
  ProductPublicationsUpdate: 'PRODUCT_PUBLICATIONS_UPDATE',
  ProfilesCreate: 'PROFILES_CREATE',
  ProfilesDelete: 'PROFILES_DELETE',
  ProfilesUpdate: 'PROFILES_UPDATE',
  PublicationsDelete: 'PUBLICATIONS_DELETE',
  RefundsCreate: 'REFUNDS_CREATE',
  ReturnsApprove: 'RETURNS_APPROVE',
  ReturnsCancel: 'RETURNS_CANCEL',
  ReturnsClose: 'RETURNS_CLOSE',
  ReturnsDecline: 'RETURNS_DECLINE',
  ReturnsReopen: 'RETURNS_REOPEN',
  ReturnsRequest: 'RETURNS_REQUEST',
  ReturnsUpdate: 'RETURNS_UPDATE',
  ReverseDeliveriesAttachDeliverable: 'REVERSE_DELIVERIES_ATTACH_DELIVERABLE',
  ReverseFulfillmentOrdersDispose: 'REVERSE_FULFILLMENT_ORDERS_DISPOSE',
  ScheduledProductListingsAdd: 'SCHEDULED_PRODUCT_LISTINGS_ADD',
  ScheduledProductListingsRemove: 'SCHEDULED_PRODUCT_LISTINGS_REMOVE',
  ScheduledProductListingsUpdate: 'SCHEDULED_PRODUCT_LISTINGS_UPDATE',
  SegmentsCreate: 'SEGMENTS_CREATE',
  SegmentsDelete: 'SEGMENTS_DELETE',
  SegmentsUpdate: 'SEGMENTS_UPDATE',
  SellingPlanGroupsCreate: 'SELLING_PLAN_GROUPS_CREATE',
  SellingPlanGroupsDelete: 'SELLING_PLAN_GROUPS_DELETE',
  SellingPlanGroupsUpdate: 'SELLING_PLAN_GROUPS_UPDATE',
  ShippingAddressesCreate: 'SHIPPING_ADDRESSES_CREATE',
  ShippingAddressesUpdate: 'SHIPPING_ADDRESSES_UPDATE',
  ShopUpdate: 'SHOP_UPDATE',
  SubscriptionBillingAttemptsChallenged: 'SUBSCRIPTION_BILLING_ATTEMPTS_CHALLENGED',
  SubscriptionBillingAttemptsFailure: 'SUBSCRIPTION_BILLING_ATTEMPTS_FAILURE',
  SubscriptionBillingAttemptsSuccess: 'SUBSCRIPTION_BILLING_ATTEMPTS_SUCCESS',
  SubscriptionBillingCyclesSkip: 'SUBSCRIPTION_BILLING_CYCLES_SKIP',
  SubscriptionBillingCyclesUnskip: 'SUBSCRIPTION_BILLING_CYCLES_UNSKIP',
  SubscriptionBillingCycleEditsCreate: 'SUBSCRIPTION_BILLING_CYCLE_EDITS_CREATE',
  SubscriptionBillingCycleEditsDelete: 'SUBSCRIPTION_BILLING_CYCLE_EDITS_DELETE',
  SubscriptionBillingCycleEditsUpdate: 'SUBSCRIPTION_BILLING_CYCLE_EDITS_UPDATE',
  SubscriptionContractsActivate: 'SUBSCRIPTION_CONTRACTS_ACTIVATE',
  SubscriptionContractsCancel: 'SUBSCRIPTION_CONTRACTS_CANCEL',
  SubscriptionContractsCreate: 'SUBSCRIPTION_CONTRACTS_CREATE',
  SubscriptionContractsExpire: 'SUBSCRIPTION_CONTRACTS_EXPIRE',
  SubscriptionContractsFail: 'SUBSCRIPTION_CONTRACTS_FAIL',
  SubscriptionContractsPause: 'SUBSCRIPTION_CONTRACTS_PAUSE',
  SubscriptionContractsUpdate: 'SUBSCRIPTION_CONTRACTS_UPDATE',
  TaxPartnersUpdate: 'TAX_PARTNERS_UPDATE',
  TaxServicesCreate: 'TAX_SERVICES_CREATE',
  TaxServicesUpdate: 'TAX_SERVICES_UPDATE',
  TenderTransactionsCreate: 'TENDER_TRANSACTIONS_CREATE',
  ThemesCreate: 'THEMES_CREATE',
  ThemesDelete: 'THEMES_DELETE',
  ThemesPublish: 'THEMES_PUBLISH',
  ThemesUpdate: 'THEMES_UPDATE',
  VariantsInStock: 'VARIANTS_IN_STOCK',
  VariantsOutOfStock: 'VARIANTS_OUT_OF_STOCK'
} as const;

export type WebhookSubscriptionTopic = typeof WebhookSubscriptionTopic[keyof typeof WebhookSubscriptionTopic];
export type WebhookSubscriptionUpdatePayload = {
  userErrors: Array<UserError>;
  webhookSubscription?: Maybe<WebhookSubscription>;
};

export type Weight = {
  unit: WeightUnit;
  value: Scalars['Float']['output'];
};

export type WeightInput = {
  unit: WeightUnit;
  value: Scalars['Float']['input'];
};

export const WeightUnit = {
  Grams: 'GRAMS',
  Kilograms: 'KILOGRAMS',
  Ounces: 'OUNCES',
  Pounds: 'POUNDS'
} as const;

export type WeightUnit = typeof WeightUnit[keyof typeof WeightUnit];